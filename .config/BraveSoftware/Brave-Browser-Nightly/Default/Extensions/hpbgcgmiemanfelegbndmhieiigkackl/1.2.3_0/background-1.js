LavaPack.loadBundle([
[36, {"../../../../shared/constants/transaction":3599,"../../../../shared/modules/random-id":3606,"../../../../shared/modules/transaction.utils":3609,"../../metamask-controller":79,"./lib/tx-state-history-helpers":32,"./lib/util":33,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@metamask/obs-store":981,"lodash":2646,"loglevel":2657,"safe-event-emitter":3238}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../../shared/modules/random-id"));

var _transaction = require("../../../../shared/constants/transaction");

var _metamaskController = require("../../metamask-controller");

var _transaction2 = require("../../../../shared/modules/transaction.utils");

var _txStateHistoryHelpers = require("./lib/tx-state-history-helpers");

var _util = require("./lib/util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * TransactionStatuses reimported from the shared transaction constants file
 * @typedef {import(
 *  '../../../../shared/constants/transaction'
 * ).TransactionStatusString} TransactionStatusString
 */

/**
 * @typedef {import('../../../../shared/constants/transaction').TxParams} TxParams
 */

/**
 * @typedef {import(
 *  '../../../../shared/constants/transaction'
 * ).TransactionMeta} TransactionMeta
 */

/**
 * @typedef {Object} TransactionState
 * @property {Record<string, TransactionMeta>} transactions - TransactionMeta
 *  keyed by the transaction's id.
 */

/**
 * TransactionStateManager is responsible for the state of a transaction and
 * storing the transaction. It also has some convenience methods for finding
 * subsets of transactions.
 * @param {Object} opts
 * @param {TransactionState} [opts.initState={ transactions: {} }] - initial
 *  transactions list keyed by id
 * @param {number} [opts.txHistoryLimit] - limit for how many finished
 *  transactions can hang around in state
 * @param {Function} opts.getNetwork - return network number
 * @class
 */
class TransactionStateManager extends _safeEventEmitter.default {
  constructor({
    initState,
    txHistoryLimit,
    getNetwork,
    getCurrentChainId
  }) {
    super();
    this.store = new _obsStore.ObservableStore(_objectSpread({
      transactions: {}
    }, initState));
    this.txHistoryLimit = txHistoryLimit;
    this.getNetwork = getNetwork;
    this.getCurrentChainId = getCurrentChainId;
  }
  /**
   * Generates a TransactionMeta object consisting of the fields required for
   * use throughout the extension. The argument here will override everything
   * in the resulting transaction meta.
   *
   * TODO: Don't overwrite everything?
   *
   * @param {Partial<TransactionMeta>} opts - the object to use when
   *  overwriting default keys of the TransactionMeta
   * @returns {TransactionMeta} the default txMeta object
   */


  generateTxMeta(opts = {}) {
    const netId = this.getNetwork();
    const chainId = this.getCurrentChainId();

    if (netId === 'loading') {
      throw new Error('MetaMask is having trouble connecting to the network');
    }

    let dappSuggestedGasFees = null; // If we are dealing with a transaction suggested by a dapp and not
    // an internally created metamask transaction, we need to keep record of
    // the originally submitted gasParams.

    if (opts.txParams && typeof opts.origin === 'string' && opts.origin !== 'metamask') {
      if (typeof opts.txParams.gasPrice !== 'undefined') {
        dappSuggestedGasFees = {
          gasPrice: opts.txParams.gasPrice
        };
      } else if (typeof opts.txParams.maxFeePerGas !== 'undefined' || typeof opts.txParams.maxPriorityFeePerGas !== 'undefined') {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.txParams.maxPriorityFeePerGas,
          maxFeePerGas: opts.txParams.maxFeePerGas
        };
      }

      if (typeof opts.txParams.gas !== 'undefined') {
        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {
          gas: opts.txParams.gas
        });
      }
    }

    return _objectSpread({
      id: (0, _randomId.default)(),
      time: new Date().getTime(),
      status: _transaction.TRANSACTION_STATUSES.UNAPPROVED,
      metamaskNetworkId: netId,
      chainId,
      loadingDefaults: true,
      dappSuggestedGasFees
    }, opts);
  }
  /**
   * Get an object containing all unapproved transactions for the current
   * network. This is the only transaction fetching method that returns an
   * object, so it doesn't use getTransactions like everything else.
   *
   * @returns {Record<string, TransactionMeta>} Unapproved transactions keyed
   *  by id
   */


  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork();
    return (0, _lodash.pickBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network));
  }
  /**
   * Get all approved transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getApprovedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.APPROVED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all pending transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getPendingTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.SUBMITTED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all confirmed transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.CONFIRMED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Adds the txMeta to the list of transactions in the store.
   * if the list is over txHistoryLimit it will remove a transaction that
   * is in its final state.
   * it will also add the key `history` to the txMeta with the snap shot of
   * the original object
   * @param {TransactionMeta} txMeta - The TransactionMeta object to add.
   * @returns {TransactionMeta} The same TransactionMeta, but with validated
   *  txParams and transaction history.
   */


  addTransaction(txMeta) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    }

    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    }); // initialize history

    txMeta.history = []; // capture initial snapshot of txMeta for history

    const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this; // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // TODO: we are already limiting what we send to the UI, and in the future
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.

    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce
      } = tx.txParams;
      const {
        chainId,
        metamaskNetworkId,
        status
      } = tx;
      const key = `${nonce}-${chainId !== null && chainId !== void 0 ? chainId : metamaskNetworkId}`;

      if (nonceNetworkSet.has(key)) {
        return false;
      } else if (nonceNetworkSet.size < txHistoryLimit - 1 || (0, _util.getFinalStates)().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }

      return true;
    }).map(tx => tx.id);

    this._deleteTransactions(txsToDelete);

    this._addTransactionsToState([txMeta]);

    return txMeta;
  }
  /**
   * @param {number} txId
   * @returns {TransactionMeta} the txMeta who matches the given id if none found
   * for the network returns undefined
   */


  getTransaction(txId) {
    const {
      transactions
    } = this.store.getState();
    return transactions[txId];
  }
  /**
   * updates the txMeta in the list and adds a history entry
   * @param {Object} txMeta - the txMeta to update
   * @param {string} [note] - a note about the update for history
   */


  updateTransaction(txMeta, note) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    } // create txMeta snapshot for history


    const currentState = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta); // recover previous tx state obj

    const previousState = (0, _txStateHistoryHelpers.replayHistory)(txMeta.history); // generate history entry and add to history

    const entry = (0, _txStateHistoryHelpers.generateHistoryEntry)(previousState, currentState, note);

    if (entry.length) {
      txMeta.history.push(entry);
    } // commit txMeta to state


    const txId = txMeta.id;
    this.store.updateState({
      transactions: _objectSpread(_objectSpread({}, this.store.getState().transactions), {}, {
        [txId]: txMeta
      })
    });
  }
  /**
   * SearchCriteria can search in any key in TxParams or the base
   * TransactionMeta. This type represents any key on either of those two
   * types.
   * @typedef {TxParams[keyof TxParams] | TransactionMeta[keyof TransactionMeta]} SearchableKeys
   */

  /**
   * Predicates can either be strict values, which is shorthand for using
   * strict equality, or a method that receives he value of the specified key
   * and returns a boolean.
   * @typedef {(v: unknown) => boolean | unknown} FilterPredicate
   */

  /**
   * Retrieve a list of transactions from state. By default this will return
   * the full list of Transactions for the currently selected chain/network.
   * Additional options can be provided to change what is included in the final
   * list.
   *
   * @param opts - options to change filter behavior
   * @param {Record<SearchableKeys, FilterPredicate>} [opts.searchCriteria] -
   *  an object with keys that match keys in TransactionMeta or TxParams, and
   *  values that are predicates. Predicates can either be strict values,
   *  which is shorthand for using strict equality, or a method that receives
   *  the value of the specified key and returns a boolean. The transaction
   *  list will be filtered to only those items that the predicate returns
   *  truthy for. **HINT**: `err: undefined` is like looking for a tx with no
   *  err. so you can also search txs that don't have something as well by
   *  setting the value as undefined.
   * @param {TransactionMeta[]} [opts.initialList] - If provided the filtering
   *  will occur on the provided list. By default this will be the full list
   *  from state sorted by time ASC.
   * @param {boolean} [opts.filterToCurrentNetwork=true] - Filter transaction
   *  list to only those that occurred on the current chain or network.
   *  Defaults to true.
   * @param {number} [opts.limit] - limit the number of transactions returned
   *  to N unique nonces.
   * @returns {TransactionMeta[]} The TransactionMeta objects that all provided
   *  predicates return truthy for.
   */


  getTransactions({
    searchCriteria = {},
    initialList,
    filterToCurrentNetwork = true,
    limit
  } = {}) {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork(); // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.

    const predicateMethods = (0, _lodash.mapValues)(searchCriteria, predicate => {
      return typeof predicate === 'function' ? predicate : v => v === predicate;
    }); // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.

    const transactionsToFilter = initialList ? (0, _lodash.keyBy)(initialList, 'id') : this.store.getState().transactions; // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.

    const filteredTransactions = (0, _lodash.sortBy)((0, _lodash.pickBy)(transactionsToFilter, transaction => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      if (filterToCurrentNetwork && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network) === false) {
        return false;
      } // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria


      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in transaction.txParams) {
          if (predicate(transaction.txParams[key]) === false) {
            return false;
          }
        } else if (predicate(transaction[key]) === false) {
          return false;
        }
      }

      return true;
    }), 'time');

    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = []; // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.

      for (let i = filteredTransactions.length - 1; i > -1; i--) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.txParams;

        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        } // Push transaction into the beginning of our array to ensure the
        // original order is preserved.


        txs.unshift(txMeta);
      }

      return txs;
    }

    return filteredTransactions;
  }
  /**
   * Update status of the TransactionMeta with provided id to 'rejected'.
   * After setting the status, the TransactionMeta is deleted from state.
   *
   * TODO: Should we show historically rejected transactions somewhere in the
   * UI? Seems like it could be valuable for information purposes. Of course
   * only after limit issues are reduced.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusRejected(txId) {
    this._setTransactionStatus(txId, 'rejected');

    this._deleteTransaction(txId);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'unapproved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusUnapproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.UNAPPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'approved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusApproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.APPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'signed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSigned(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SIGNED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'submitted'
   * and sets the 'submittedTime' property with the current Unix epoch time.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSubmitted(txId) {
    const txMeta = this.getTransaction(txId);
    txMeta.submittedTime = new Date().getTime();
    this.updateTransaction(txMeta, 'txStateManager - add submitted time stamp');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SUBMITTED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'confirmed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusConfirmed(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.CONFIRMED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'dropped'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusDropped(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.DROPPED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'failed' and put
   * the error on the TransactionMeta object.
   *
   * @param {number} txId - the target TransactionMeta's Id
   * @param {Error} err - error object
   */


  setTxStatusFailed(txId, err) {
    var _error$message;

    const error = err || new Error('Internal metamask failure');
    const txMeta = this.getTransaction(txId);
    txMeta.err = {
      message: ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.toString()) || error.toString(),
      rpc: error.value,
      stack: error.stack
    };
    this.updateTransaction(txMeta, 'transactions:tx-state-manager#fail - add error');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.FAILED);
  }
  /**
   * Removes all transactions for the given address on the current network,
   * preferring chainId for comparison over networkId.
   *
   * @param {string} address - hex string of the from address on the txParams
   *  to remove
   */


  wipeTransactions(address) {
    // network only tx
    const {
      transactions
    } = this.store.getState();
    const network = this.getNetwork();
    const chainId = this.getCurrentChainId(); // Update state

    this.store.updateState({
      transactions: (0, _lodash.omitBy)(transactions, transaction => transaction.txParams.from === address && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network))
    });
  }
  /**
   * Filters out the unapproved transactions from state
   */


  clearUnapprovedTxs() {
    this.store.updateState({
      transactions: (0, _lodash.omitBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED)
    });
  } //
  //           PRIVATE METHODS
  //

  /**
   * Updates a transaction's status in state, and then emits events that are
   * subscribed to elsewhere. See below for best guesses on where and how these
   * events are received.
   * @param {number} txId - the TransactionMeta Id
   * @param {TransactionStatusString} status - the status to set on the
   *  TransactionMeta
   * @emits txMeta.id:txMeta.status - every time a transaction's status changes
   *  we emit the change passing along the id. This does not appear to be used
   *  outside of this file, which only listens to this to unsubscribe listeners
   *  of :rejected and :signed statuses when the inverse status changes. Likely
   *  safe to drop.
   * @emits tx:status-update - every time a transaction's status changes we
   *  emit this event and pass txId and status. This event is subscribed to in
   *  the TransactionController and re-broadcast by the TransactionController.
   *  It is used internally within the TransactionController to try and update
   *  pending transactions on each new block (from blockTracker). It's also
   *  subscribed to in metamask-controller to display a browser notification on
   *  confirmed or failed transactions.
   * @emits txMeta.id:finished - When a transaction moves to a finished state
   *  this event is emitted, which is used in the TransactionController to pass
   *  along details of the transaction to the dapp that suggested them. This
   *  pattern is replicated across all of the message managers and can likely
   *  be supplemented or replaced by the ApprovalController.
   * @emits updateBadge - When the number of transactions changes in state,
   *  the badge in the browser extension bar should be updated to reflect the
   *  number of pending transactions. This particular emit doesn't appear to
   *  bubble up anywhere that is actually used. TransactionController emits
   *  this *anytime the state changes*, so this is probably superfluous.
   */


  _setTransactionStatus(txId, status) {
    const txMeta = this.getTransaction(txId);

    if (!txMeta) {
      return;
    }

    txMeta.status = status;

    try {
      this.updateTransaction(txMeta, `txStateManager: setting status to ${status}`);
      this.emit(`${txMeta.id}:${status}`, txId);
      this.emit(`tx:status-update`, txId, status);

      if ([_transaction.TRANSACTION_STATUSES.SUBMITTED, _transaction.TRANSACTION_STATUSES.REJECTED, _transaction.TRANSACTION_STATUSES.FAILED].includes(status)) {
        this.emit(`${txMeta.id}:finished`, txMeta);
      }

      this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
    } catch (error) {
      _loglevel.default.error(error);
    }
  }
  /**
   * Adds one or more transactions into state. This is not intended for
   * external use.
   *
   * @private
   * @param {TransactionMeta[]} transactions - the list of transactions to save
   */


  _addTransactionsToState(transactions) {
    this.store.updateState({
      transactions: transactions.reduce((result, newTx) => {
        result[newTx.id] = newTx;
        return result;
      }, this.store.getState().transactions)
    });
  }
  /**
   * removes one transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number} targetTransactionId - the transaction to delete
   */


  _deleteTransaction(targetTransactionId) {
    const {
      transactions
    } = this.store.getState();
    delete transactions[targetTransactionId];
    this.store.updateState({
      transactions
    });
  }
  /**
   * removes multiple transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number[]} targetTransactionIds - the transactions to delete
   */


  _deleteTransactions(targetTransactionIds) {
    const {
      transactions
    } = this.store.getState();
    targetTransactionIds.forEach(transactionId => {
      delete transactions[transactionId];
    });
    this.store.updateState({
      transactions
    });
  }

}

exports.default = TransactionStateManager;

//# sourceMappingURL=app/scripts/controllers/transactions/tx-state-manager.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/transactions/tx-state-manager.js",}],
[11, {"@babel/runtime/helpers/interopRequireDefault":186,"ethereum-ens-network-map":1780,"ethjs-ens":1842}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethjsEns = _interopRequireDefault(require("ethjs-ens"));

var _ethereumEnsNetworkMap = _interopRequireDefault(require("ethereum-ens-network-map"));

class Ens {
  static getNetworkEnsSupport(network) {
    return Boolean(_ethereumEnsNetworkMap.default[network]);
  }

  constructor({
    network,
    provider
  } = {}) {
    this._ethJsEns = new _ethjsEns.default({
      network,
      provider
    });
  }

  lookup(ensName) {
    return this._ethJsEns.lookup(ensName);
  }

  reverse(address) {
    return this._ethJsEns.reverse(address);
  }

}

exports.default = Ens;

//# sourceMappingURL=app/scripts/controllers/ens/ens.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/ens/ens.js",}],
[1075, {"./package.json":1076,"@segment/loosely-validate-event":991,"_process":2892,"assert":1095,"axios":1178,"axios-retry":1176,"lodash.isstring":2504,"md5":2665,"ms":2677,"remove-trailing-slash":3158,"uuid/v4":3464}, function (require, module, exports) {
(function (process,global){
'use strict'

const assert = require('assert')
const removeSlash = require('remove-trailing-slash')
const looselyValidate = require('@segment/loosely-validate-event')
const axios = require('axios')
const axiosRetry = require('axios-retry')
const ms = require('ms')
const uuid = require('uuid/v4')
const md5 = require('md5')
const version = require('./package.json').version
const isString = require('lodash.isstring')

const setImmediate = global.setImmediate || process.nextTick.bind(process)
const noop = () => {}

class Analytics {
  /**
   * Initialize a new `Analytics` with your Segment project's `writeKey` and an
   * optional dictionary of `options`.
   *
   * @param {String} writeKey
   * @param {Object} [options] (optional)
   *   @property {Number} flushAt (default: 20)
   *   @property {Number} flushInterval (default: 10000)
   *   @property {String} host (default: 'https://api.segment.io')
   *   @property {Boolean} enable (default: true)
   */

  constructor (writeKey, options) {
    options = options || {}

    assert(writeKey, 'You must pass your Segment project\'s write key.')

    this.queue = []
    this.writeKey = writeKey
    this.host = removeSlash(options.host || 'https://api.segment.io')
    this.timeout = options.timeout || false
    this.flushAt = Math.max(options.flushAt, 1) || 20
    this.flushInterval = options.flushInterval || 10000
    this.flushed = false
    Object.defineProperty(this, 'enable', {
      configurable: false,
      writable: false,
      enumerable: true,
      value: typeof options.enable === 'boolean' ? options.enable : true
    })
    this.axiosClient = axios.create()
    axiosRetry(this.axiosClient, {
      retries: options.retryCount || 3,
      retryCondition: this._isErrorRetryable,
      retryDelay: axiosRetry.exponentialDelay
    })
  }

  _validate (message, type) {
    try {
      looselyValidate(message, type)
    } catch (e) {
      if (e.message === 'Your message must be < 32kb.') {
        console.log('Your message must be < 32kb. This is currently surfaced as a warning to allow clients to update. Versions released after August 1, 2018 will throw an error instead. Please update your code before then.', message)
        return
      }
      throw e
    }
  }

  /**
   * Send an identify `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  identify (message, callback) {
    this._validate(message, 'identify')
    this.enqueue('identify', message, callback)
    return this
  }

  /**
   * Send a group `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  group (message, callback) {
    this._validate(message, 'group')
    this.enqueue('group', message, callback)
    return this
  }

  /**
   * Send a track `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  track (message, callback) {
    this._validate(message, 'track')
    this.enqueue('track', message, callback)
    return this
  }

  /**
   * Send a page `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  page (message, callback) {
    this._validate(message, 'page')
    this.enqueue('page', message, callback)
    return this
  }

  /**
   * Send a screen `message`.
   *
   * @param {Object} message
   * @param {Function} fn (optional)
   * @return {Analytics}
   */

  screen (message, callback) {
    this._validate(message, 'screen')
    this.enqueue('screen', message, callback)
    return this
  }

  /**
   * Send an alias `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  alias (message, callback) {
    this._validate(message, 'alias')
    this.enqueue('alias', message, callback)
    return this
  }

  /**
   * Add a `message` of type `type` to the queue and
   * check whether it should be flushed.
   *
   * @param {String} type
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @api private
   */

  enqueue (type, message, callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    message = Object.assign({}, message)
    message.type = type
    message.context = Object.assign({
      library: {
        name: 'analytics-node',
        version
      }
    }, message.context)

    message._metadata = Object.assign({
      nodeVersion: process.versions.node
    }, message._metadata)

    if (!message.timestamp) {
      message.timestamp = new Date()
    }

    if (!message.messageId) {
      // We md5 the messaage to add more randomness. This is primarily meant
      // for use in the browser where the uuid package falls back to Math.random()
      // which is not a great source of randomness.
      // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).
      message.messageId = `node-${md5(JSON.stringify(message))}-${uuid()}`
    }

    // Historically this library has accepted strings and numbers as IDs.
    // However, our spec only allows strings. To avoid breaking compatibility,
    // we'll coerce these to strings if they aren't already.
    if (message.anonymousId && !isString(message.anonymousId)) {
      message.anonymousId = JSON.stringify(message.anonymousId)
    }
    if (message.userId && !isString(message.userId)) {
      message.userId = JSON.stringify(message.userId)
    }

    this.queue.push({ message, callback })

    if (!this.flushed) {
      this.flushed = true
      this.flush()
      return
    }

    if (this.queue.length >= this.flushAt) {
      this.flush()
    }

    if (this.flushInterval && !this.timer) {
      this.timer = setTimeout(this.flush.bind(this), this.flushInterval)
    }
  }

  /**
   * Flush the current queue
   *
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  flush (callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }

    if (!this.queue.length) {
      return setImmediate(callback)
    }

    const items = this.queue.splice(0, this.flushAt)
    const callbacks = items.map(item => item.callback)
    const messages = items.map(item => item.message)

    const data = {
      batch: messages,
      timestamp: new Date(),
      sentAt: new Date()
    }

    const done = err => {
      callbacks.forEach(callback => callback(err))
      callback(err, data)
    }

    // Don't set the user agent if we're not on a browser. The latest spec allows
    // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers
    // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),
    // but browsers such as Chrome and Safari have not caught up.
    const headers = {}
    if (typeof window === 'undefined') {
      headers['user-agent'] = `analytics-node/${version}`
    }

    const req = {
      method: 'POST',
      url: `${this.host}/v1/batch`,
      auth: {
        username: this.writeKey
      },
      data,
      headers
    }

    if (this.timeout) {
      req.timeout = typeof this.timeout === 'string' ? ms(this.timeout) : this.timeout
    }

    this.axiosClient(req)
      .then(() => done())
      .catch(err => {
        if (err.response) {
          const error = new Error(err.response.statusText)
          return done(error)
        }

        done(err)
      })
  }

  _isErrorRetryable (error) {
    // Retry Network Errors.
    if (axiosRetry.isNetworkError(error)) {
      return true
    }

    if (!error.response) {
      // Cannot determine if the request can be retried
      return false
    }

    // Retry Server Errors (5xx).
    if (error.response.status >= 500 && error.response.status <= 599) {
      return true
    }

    // Retry if rate limited.
    if (error.response.status === 429) {
      return true
    }

    return false
  }
}

module.exports = Analytics

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

//# sourceMappingURL=node_modules/analytics-node/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/analytics-node/index.js",}],
[1829, {"./index.js":1816,"aes-js":1817,"crypto":1478,"ethereumjs-util":1822,"safe-buffer":3237,"scryptsy":3252,"utf8":3455}, function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Wallet = require('./index.js');
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var scryptsy = require('scryptsy');
var utf8 = require('utf8');
var aesjs = require('aes-js');
var Buffer = require('safe-buffer').Buffer;

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Thirdparty = {};

/*
 * opts:
 * - digest - digest algorithm, defaults to md5
 * - count - hash iterations
 * - keysize - desired key size
 * - ivsize - desired IV size
 *
 * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html
 *
 * FIXME: not optimised at all
 */
function evp_kdf(data, salt, opts) {
  // eslint-disable-line
  // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`
  function iter(block) {
    var hash = crypto.createHash(opts.digest || 'md5');
    hash.update(block);
    hash.update(data);
    hash.update(salt);
    block = hash.digest();

    for (var i = 1; i < (opts.count || 1); i++) {
      hash = crypto.createHash(opts.digest || 'md5');
      hash.update(block);
      block = hash.digest();
    }

    return block;
  }

  var keysize = opts.keysize || 16;
  var ivsize = opts.ivsize || 16;

  var ret = [];

  var i = 0;
  while (Buffer.concat(ret).length < keysize + ivsize) {
    ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);
    i++;
  }

  var tmp = Buffer.concat(ret);

  return {
    key: tmp.slice(0, keysize),
    iv: tmp.slice(keysize, keysize + ivsize)
  };
}

// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with
function decodeCryptojsSalt(input) {
  var ciphertext = Buffer.from(input, 'base64');
  if (ciphertext.slice(0, 8).toString() === 'Salted__') {
    return {
      salt: ciphertext.slice(8, 16),
      ciphertext: ciphertext.slice(16)
    };
  } else {
    return {
      ciphertext: ciphertext
    };
  }
}

/*
 * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts
 * and used on https://www.myetherwallet.com/
 */
Thirdparty.fromEtherWallet = function (input, password) {
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var privKey;
  if (!json.locked) {
    if (json.private.length !== 64) {
      throw new Error('Invalid private key length');
    }

    privKey = Buffer.from(json.private, 'hex');
  } else {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }
    if (password.length < 7) {
      throw new Error('Password must be at least 7 characters');
    }

    // the "encrypted" version has the low 4 bytes
    // of the hash of the address appended
    var cipher = json.encrypted ? json.private.slice(0, 128) : json.private;

    // decode openssl ciphertext + salt encoding
    cipher = decodeCryptojsSalt(cipher);

    if (!cipher.salt) {
      throw new Error('Unsupported EtherWallet key format');
    }

    // derive key/iv using OpenSSL EVP as implemented in CryptoJS
    var evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });

    var decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);
    privKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));

    // NOTE: yes, they've run it through UTF8
    privKey = Buffer.from(utf8.decode(privKey.toString()), 'hex');
  }

  var wallet = new Wallet(privKey);

  if (wallet.getAddressString() !== json.address) {
    throw new Error('Invalid private key or address');
  }

  return wallet;
};

Thirdparty.fromEtherCamp = function (passphrase) {
  return new Wallet(ethUtil.keccak256(Buffer.from(passphrase)));
};

Thirdparty.fromKryptoKit = function (entropy, password) {
  function kryptoKitBrokenScryptSeed(buf) {
    // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer
    //
    // The `buffer`` implementation used does the below transformation (doesn't matches the current version):
    // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js

    function decodeUtf8Char(str) {
      try {
        return decodeURIComponent(str);
      } catch (err) {
        return String.fromCharCode(0xFFFD); // UTF 8 invalid char
      }
    }

    var res = '';
    var tmp = '';

    for (var i = 0; i < buf.length; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }

    return Buffer.from(res + decodeUtf8Char(tmp));
  }

  if (entropy[0] === '#') {
    entropy = entropy.slice(1);
  }

  var type = entropy[0];
  entropy = entropy.slice(1);

  var privKey;
  if (type === 'd') {
    privKey = ethUtil.sha256(Buffer.from(entropy));
  } else if (type === 'q') {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }

    var encryptedSeed = ethUtil.sha256(Buffer.from(entropy.slice(0, 30)));
    var checksum = entropy.slice(30, 46);

    var salt = kryptoKitBrokenScryptSeed(encryptedSeed);
    var aesKey = scryptsy(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32);

    /* FIXME: try to use `crypto` instead of `aesjs`
     // NOTE: ECB doesn't use the IV, so it can be anything
    var decipher = crypto.createDecipheriv("aes-256-ecb", aesKey, Buffer.from(0))
     // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works
    privKey = Buffer.concat([
      decipher.update(encryptedSeed).slice(0, 16),
      decipher.update(encryptedSeed).slice(0, 16),
    ])
    */

    /* eslint-disable new-cap */
    var decipher = new aesjs.ModeOfOperation.ecb(aesKey);
    /* eslint-enable new-cap */
    /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */
    privKey = Buffer.concat([Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))), Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32)))]);

    if (checksum.length > 0) {
      if (checksum !== ethUtil.sha256(ethUtil.sha256(privKey)).slice(0, 8).toString('hex')) {
        throw new Error('Failed to decrypt input - possibly invalid passphrase');
      }
    }
  } else {
    throw new Error('Unsupported or invalid entropy type');
  }

  return new Wallet(privKey);
};

Thirdparty.fromQuorumWallet = function (passphrase, userid) {
  assert(passphrase.length >= 10);
  assert(userid.length >= 10);

  var seed = passphrase + userid;
  seed = crypto.pbkdf2Sync(seed, seed, 2000, 32, 'sha256');

  return new Wallet(seed);
};

module.exports = Thirdparty;
//# sourceMappingURL=node_modules/ethereumjs-wallet/thirdparty.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/thirdparty.js",}],
[1816, {"bs58check":1435,"crypto":1478,"ethereumjs-util":1822,"randombytes":3000,"safe-buffer":3237,"scryptsy":3252,"uuid/v4":3464}, function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Buffer = require('safe-buffer').Buffer;
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var randomBytes = require('randombytes');
var scryptsy = require('scryptsy');
var uuidv4 = require('uuid/v4');
var bs58check = require('bs58check');

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Wallet = function Wallet(priv, pub) {
  if (priv && pub) {
    throw new Error('Cannot supply both a private and a public key to the constructor');
  }

  if (priv && !ethUtil.isValidPrivate(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (pub && !ethUtil.isValidPublic(pub)) {
    throw new Error('Invalid public key');
  }

  this._privKey = priv;
  this._pubKey = pub;
};

Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    assert(this._privKey, 'This is a public key only wallet');
    return this._privKey;
  }
});

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = ethUtil.privateToPublic(this.privKey);
    }
    return this._pubKey;
  }
});

Wallet.generate = function (icapDirect) {
  if (icapDirect) {
    var max = new ethUtil.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);
    while (true) {
      var privKey = randomBytes(32);
      if (new ethUtil.BN(ethUtil.privateToAddress(privKey)).lte(max)) {
        return new Wallet(privKey);
      }
    }
  } else {
    return new Wallet(randomBytes(32));
  }
};

Wallet.generateVanityAddress = function (pattern) {
  if ((typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
    pattern = new RegExp(pattern);
  }

  while (true) {
    var privKey = randomBytes(32);
    var address = ethUtil.privateToAddress(privKey);

    if (pattern.test(address.toString('hex'))) {
      return new Wallet(privKey);
    }
  }
};

Wallet.prototype.getPrivateKey = function () {
  return this.privKey;
};

Wallet.prototype.getPrivateKeyString = function () {
  return ethUtil.bufferToHex(this.getPrivateKey());
};

Wallet.prototype.getPublicKey = function () {
  return this.pubKey;
};

Wallet.prototype.getPublicKeyString = function () {
  return ethUtil.bufferToHex(this.getPublicKey());
};

Wallet.prototype.getAddress = function () {
  return ethUtil.publicToAddress(this.pubKey);
};

Wallet.prototype.getAddressString = function () {
  return ethUtil.bufferToHex(this.getAddress());
};

Wallet.prototype.getChecksumAddressString = function () {
  return ethUtil.toChecksumAddress(this.getAddressString());
};

// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
Wallet.prototype.toV3 = function (password, opts) {
  assert(this._privKey, 'This is a public key only wallet');

  opts = opts || {};
  var salt = opts.salt || randomBytes(32);
  var iv = opts.iv || randomBytes(16);

  var derivedKey;
  var kdf = opts.kdf || 'scrypt';
  var kdfparams = {
    dklen: opts.dklen || 32,
    salt: salt.toString('hex')
  };

  if (kdf === 'pbkdf2') {
    kdfparams.c = opts.c || 262144;
    kdfparams.prf = 'hmac-sha256';
    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');
  } else if (kdf === 'scrypt') {
    // FIXME: support progress reporting callback
    kdfparams.n = opts.n || 262144;
    kdfparams.r = opts.r || 8;
    kdfparams.p = opts.p || 1;
    derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else {
    throw new Error('Unsupported kdf');
  }

  var cipher = crypto.createCipheriv(opts.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);
  if (!cipher) {
    throw new Error('Unsupported cipher');
  }

  var ciphertext = runCipherBuffer(cipher, this.privKey);

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')]));

  return {
    version: 3,
    id: uuidv4({ random: opts.uuid || randomBytes(16) }),
    address: this.getAddress().toString('hex'),
    crypto: {
      ciphertext: ciphertext.toString('hex'),
      cipherparams: {
        iv: iv.toString('hex')
      },
      cipher: opts.cipher || 'aes-128-ctr',
      kdf: kdf,
      kdfparams: kdfparams,
      mac: mac.toString('hex')
    }
  };
};

Wallet.prototype.getV3Filename = function (timestamp) {
  /*
   * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting
   * is a pain in Javascript, everbody knows that. We could use moment.js,
   * but decide to do it manually in order to save space.
   *
   * toJSON() returns a pretty close version, so let's use it. It is not UTC though,
   * but does it really matter?
   *
   * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819
   *
   */
  var ts = timestamp ? new Date(timestamp) : new Date();

  return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');
};

Wallet.prototype.toV3String = function (password, opts) {
  return JSON.stringify(this.toV3(password, opts));
};

Wallet.fromPublicKey = function (pub, nonStrict) {
  if (nonStrict) {
    pub = ethUtil.importPublic(pub);
  }
  return new Wallet(null, pub);
};

Wallet.fromExtendedPublicKey = function (pub) {
  assert(pub.slice(0, 4) === 'xpub', 'Not an extended public key');
  pub = bs58check.decode(pub).slice(45);
  // Convert to an Ethereum public key
  return Wallet.fromPublicKey(pub, true);
};

Wallet.fromPrivateKey = function (priv) {
  return new Wallet(priv);
};

Wallet.fromExtendedPrivateKey = function (priv) {
  assert(priv.slice(0, 4) === 'xprv', 'Not an extended private key');
  var tmp = bs58check.decode(priv);
  assert(tmp[45] === 0, 'Invalid extended private key');
  return Wallet.fromPrivateKey(tmp.slice(46));
};

// https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec
Wallet.fromV1 = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  if (json.Version !== '1') {
    throw new Error('Not a V1 wallet');
  }

  if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {
    throw new Error('Unsupported key derivation scheme');
  }

  var kdfparams = json.Crypto.KeyHeader.KdfParams;
  var derivedKey = scryptsy(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);

  var ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));

  if (mac.toString('hex') !== json.Crypto.MAC) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv('aes-128-cbc', ethUtil.keccak256(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

Wallet.fromV3 = function (input, password, nonStrict) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);

  if (json.version !== 3) {
    throw new Error('Not a V3 wallet');
  }

  var derivedKey;
  var kdfparams;
  if (json.crypto.kdf === 'scrypt') {
    kdfparams = json.crypto.kdfparams;

    // FIXME: support progress reporting callback
    derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else if (json.crypto.kdf === 'pbkdf2') {
    kdfparams = json.crypto.kdfparams;

    if (kdfparams.prf !== 'hmac-sha256') {
      throw new Error('Unsupported parameters to PBKDF2');
    }

    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');
  } else {
    throw new Error('Unsupported key derivation scheme');
  }

  var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
  if (mac.toString('hex') !== json.crypto.mac) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

/*
 * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
 * JSON fields: encseed, ethaddr, btcaddr, email
 */
Wallet.fromEthSale = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var encseed = Buffer.from(json.encseed, 'hex');

  // key derivation
  var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);

  // seed decoding (IV is first 16 bytes)
  // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally
  //       see also http://stackoverflow.com/a/31614770/4964819
  var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));
  var seed = runCipherBuffer(decipher, encseed.slice(16));

  var wallet = new Wallet(ethUtil.keccak256(seed));
  if (wallet.getAddress().toString('hex') !== json.ethaddr) {
    throw new Error('Decoded key mismatch - possibly wrong passphrase');
  }
  return wallet;
};

module.exports = Wallet;
//# sourceMappingURL=node_modules/ethereumjs-wallet/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/index.js",}],
[20, {"../../../../shared/constants/network":3595,"../../../../shared/constants/time":3598,"../../../../shared/modules/fetch-with-timeout":3602,"../../../../shared/modules/network.utils":3605,"./createInfuraClient":15,"./createJsonRpcClient":16,"./createMetamaskMiddleware":17,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@metamask/obs-store":981,"_process":2892,"assert":1095,"eth-json-rpc-middleware/providerFromEngine":1733,"eth-query":1744,"events":1429,"json-rpc-engine":2274,"loglevel":2657,"swappable-obj-proxy":3380}, function (require, module, exports) {
(function (process){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NETWORK_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("assert");

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _jsonRpcEngine = require("json-rpc-engine");

var _providerFromEngine = _interopRequireDefault(require("eth-json-rpc-middleware/providerFromEngine"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _swappableObjProxy = require("swappable-obj-proxy");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _network = require("../../../../shared/constants/network");

var _time = require("../../../../shared/constants/time");

var _network2 = require("../../../../shared/modules/network.utils");

var _fetchWithTimeout = _interopRequireDefault(require("../../../../shared/modules/fetch-with-timeout"));

var _createMetamaskMiddleware = _interopRequireDefault(require("./createMetamaskMiddleware"));

var _createInfuraClient = _interopRequireDefault(require("./createInfuraClient"));

var _createJsonRpcClient = _interopRequireDefault(require("./createJsonRpcClient"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const env = process.env.METAMASK_ENV;
const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
let defaultProviderConfigOpts;

if (false === 'true') {
  defaultProviderConfigOpts = {
    type: _network.NETWORK_TYPE_RPC,
    rpcUrl: _network.MONSTA_RPC_URL,
    chainId: _network.MONSTA_CHAIN_ID,
    nickname: 'Monsta Network'
  };
} else if (process.env.METAMASK_DEBUG || env === 'test') {
  defaultProviderConfigOpts = // infura type-based endpoints, network name is needed.
  // { type: MONSTA, chainId: MONSTA_CHAIN_ID };
  // url-based rpc endpoints
  {
    type: _network.NETWORK_TYPE_RPC,
    rpcUrl: _network.MONSTA_RPC_URL,
    chainId: _network.MONSTA_CHAIN_ID,
    nickname: 'Monsta Network'
  };
} else {
  defaultProviderConfigOpts = {
    type: _network.NETWORK_TYPE_RPC,
    rpcUrl: _network.MONSTA_RPC_URL,
    chainId: _network.MONSTA_CHAIN_ID,
    nickname: 'Monsta Network'
  };
}

const defaultProviderConfig = _objectSpread({
  ticker: 'xMONI'
}, defaultProviderConfigOpts);

const defaultNetworkDetailsState = {
  EIPS: {
    1559: undefined
  }
};
const NETWORK_EVENTS = {
  // Fired after the actively selected network is changed
  NETWORK_DID_CHANGE: 'networkDidChange',
  // Fired when the actively selected network *will* change
  NETWORK_WILL_CHANGE: 'networkWillChange',
  // Fired when Infura returns an error indicating no support
  INFURA_IS_BLOCKED: 'infuraIsBlocked',
  // Fired when not using an Infura network or when Infura returns no error, indicating support
  INFURA_IS_UNBLOCKED: 'infuraIsUnblocked'
};
exports.NETWORK_EVENTS = NETWORK_EVENTS;

class NetworkController extends _events.default {
  constructor(opts = {}) {
    super(); // create stores

    this.providerStore = new _obsStore.ObservableStore(opts.provider || _objectSpread({}, defaultProviderConfig));
    this.previousProviderStore = new _obsStore.ObservableStore(this.providerStore.getState());
    this.networkStore = new _obsStore.ObservableStore('loading'); // We need to keep track of a few details about the current network
    // Ideally we'd merge this.networkStore with this new store, but doing so
    // will require a decent sized refactor of how we're accessing network
    // state. Currently this is only used for detecting EIP 1559 support but
    // can be extended to track other network details.

    this.networkDetails = new _obsStore.ObservableStore(opts.networkDetails || _objectSpread({}, defaultNetworkDetailsState));
    this.store = new _obsStore.ComposedStore({
      provider: this.providerStore,
      previousProviderStore: this.previousProviderStore,
      network: this.networkStore,
      networkDetails: this.networkDetails
    }); // provider and block tracker

    this._provider = null;
    this._blockTracker = null; // provider and block tracker proxies - because the network changes

    this._providerProxy = null;
    this._blockTrackerProxy = null;
    this.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, this.lookupNetwork);
  }
  /**
   * Sets the Infura project ID
   *
   * @param {string} projectId - The Infura project ID
   * @throws {Error} if the project ID is not a valid string
   * @return {void}
   */


  setInfuraProjectId(projectId) {
    if (!projectId || typeof projectId !== 'string') {
      throw new Error('Invalid Infura project ID');
    }

    this._infuraProjectId = projectId;
  }

  initializeProvider(providerParams) {
    this._baseProviderParams = providerParams;
    const {
      type,
      rpcUrl,
      chainId
    } = this.getProviderConfig();

    this._configureProvider({
      type,
      rpcUrl,
      chainId
    });

    this.lookupNetwork();
  } // return the proxies so the references will always be good


  getProviderAndBlockTracker() {
    const provider = this._providerProxy;
    const blockTracker = this._blockTrackerProxy;
    return {
      provider,
      blockTracker
    };
  }
  /**
   * Method to return the latest block for the current network
   * @returns {Object} Block header
   */


  getLatestBlock() {
    return new Promise((resolve, reject) => {
      const {
        provider
      } = this.getProviderAndBlockTracker();
      const ethQuery = new _ethQuery.default(provider);
      ethQuery.sendAsync({
        method: 'eth_getBlockByNumber',
        params: ['latest', false]
      }, (err, block) => {
        if (err) {
          return reject(err);
        }

        return resolve(block);
      });
    });
  }
  /**
   * Method to check if the block header contains fields that indicate EIP 1559
   * support (baseFeePerGas).
   * @returns {Promise<boolean>} true if current network supports EIP 1559
   */


  async getEIP1559Compatibility() {
    const {
      EIPS
    } = this.networkDetails.getState();

    if (EIPS[1559] !== undefined) {
      return EIPS[1559];
    }

    const latestBlock = await this.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.setNetworkEIPSupport(1559, supportsEIP1559);
    return supportsEIP1559;
  }

  verifyNetwork() {
    // Check network when restoring connectivity:
    if (this.isNetworkLoading()) {
      this.lookupNetwork();
    }
  }

  getNetworkState() {
    return this.networkStore.getState();
  }

  setNetworkState(network) {
    this.networkStore.putState(network);
  }
  /**
   * Set EIP support indication in the networkDetails store
   * @param {number} EIPNumber - The number of the EIP to mark support for
   * @param {boolean} isSupported - True if the EIP is supported
   */


  setNetworkEIPSupport(EIPNumber, isSupported) {
    this.networkDetails.updateState({
      EIPS: {
        [EIPNumber]: isSupported
      }
    });
  }
  /**
   * Reset EIP support to default (no support)
   */


  clearNetworkDetails() {
    this.networkDetails.putState(_objectSpread({}, defaultNetworkDetailsState));
  }

  isNetworkLoading() {
    return this.getNetworkState() === 'loading';
  }

  lookupNetwork() {
    // Prevent firing when provider is not defined.
    if (!this._provider) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing provider');

      return;
    }

    const chainId = this.getCurrentChainId();

    if (!chainId) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing chainId');

      this.setNetworkState('loading'); // keep network details in sync with network state

      this.clearNetworkDetails();
      return;
    } // Ping the RPC endpoint so we can confirm that it works


    const ethQuery = new _ethQuery.default(this._provider);
    const initialNetwork = this.getNetworkState();
    const {
      type
    } = this.getProviderConfig();

    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._checkInfuraAvailability(type);
    } else {
      this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
    }

    ethQuery.sendAsync({
      method: 'net_version'
    }, (err, networkVersion) => {
      const currentNetwork = this.getNetworkState();

      if (initialNetwork === currentNetwork) {
        if (err) {
          this.setNetworkState('loading'); // keep network details in sync with network state

          this.clearNetworkDetails();
          return;
        }

        this.setNetworkState(networkVersion); // look up EIP-1559 support

        this.getEIP1559Compatibility();
      }
    });
  }

  getCurrentChainId() {
    var _NETWORK_TYPE_TO_ID_M;

    const {
      type,
      chainId: configChainId
    } = this.getProviderConfig();
    return ((_NETWORK_TYPE_TO_ID_M = _network.NETWORK_TYPE_TO_ID_MAP[type]) === null || _NETWORK_TYPE_TO_ID_M === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M.chainId) || configChainId;
  }

  setRpcTarget(rpcUrl, chainId, ticker = 'xMONI', nickname = '', rpcPrefs) {
    _assert.strict.ok((0, _network2.isPrefixedFormattedHexString)(chainId), `Invalid chain ID "${chainId}": invalid hex string.`);

    _assert.strict.ok((0, _network2.isSafeChainId)(parseInt(chainId, 16)), `Invalid chain ID "${chainId}": numerical value greater than max safe value.`);

    this.setProviderConfig({
      type: _network.NETWORK_TYPE_RPC,
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
  }

  async setProviderType(type) {
    _assert.strict.notStrictEqual(type, _network.NETWORK_TYPE_RPC, `NetworkController - cannot call "setProviderType" with type "${_network.NETWORK_TYPE_RPC}". Use "setRpcTarget"`);

    _assert.strict.ok(_network.INFURA_PROVIDER_TYPES.includes(type), `Unknown Infura provider type "${type}".`);

    const {
      chainId
    } = _network.NETWORK_TYPE_TO_ID_MAP[type];
    this.setProviderConfig({
      type,
      rpcUrl: '',
      chainId,
      ticker: 'xMONI',
      nickname: ''
    });
  }

  resetConnection() {
    this.setProviderConfig(this.getProviderConfig());
  }
  /**
   * Sets the provider config and switches the network.
   */


  setProviderConfig(config) {
    this.previousProviderStore.updateState(this.getProviderConfig());
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  rollbackToPreviousProvider() {
    const config = this.previousProviderStore.getState();
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  getProviderConfig() {
    return this.providerStore.getState();
  }

  getNetworkIdentifier() {
    const provider = this.providerStore.getState();
    return provider.type === _network.NETWORK_TYPE_RPC ? provider.rpcUrl : provider.type;
  } //
  // Private
  //


  async _checkInfuraAvailability(network) {
    const rpcUrl = `https://mainnet.monstachain.org`;
    let networkChanged = false;
    this.once(NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      networkChanged = true;
    });

    try {
      const response = await fetchWithTimeout(rpcUrl, {
        method: 'POST',
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'eth_blockNumber',
          params: [],
          id: 1
        })
      });

      if (networkChanged) {
        return;
      }

      if (response.ok) {
        this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
      } else {
        const responseMessage = await response.json();

        if (networkChanged) {
          return;
        }

        if (responseMessage.error === _network.INFURA_BLOCKED_KEY) {
          this.emit(NETWORK_EVENTS.INFURA_IS_BLOCKED);
        }
      }
    } catch (err) {
      _loglevel.default.warn(`MonstaWallet- Infura availability check failed`, err);
    }
  }

  _switchNetwork(opts) {
    // Indicate to subscribers that network is about to change
    this.emit(NETWORK_EVENTS.NETWORK_WILL_CHANGE); // Set loading state

    this.setNetworkState('loading'); // Reset network details

    this.clearNetworkDetails(); // Configure the provider appropriately

    this._configureProvider(opts); // Notify subscribers that network has changed


    this.emit(NETWORK_EVENTS.NETWORK_DID_CHANGE, opts.type);
  }

  _configureProvider({
    type,
    rpcUrl,
    chainId
  }) {
    // infura type-based endpoints
    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._configureInfuraProvider(type, this._infuraProjectId); // url-based rpc endpoints

    } else if (type === _network.NETWORK_TYPE_RPC) {
      this._configureStandardProvider(rpcUrl, chainId);
    } else {
      throw new Error(`NetworkController - _configureProvider - unknown type "${type}"`);
    }
  }

  _configureInfuraProvider(type, projectId) {
    _loglevel.default.info('NetworkController - configureInfuraProvider', type);

    const networkClient = (0, _createInfuraClient.default)({
      network: type,
      projectId
    });

    this._setNetworkClient(networkClient);
  }

  _configureStandardProvider(rpcUrl, chainId) {
    _loglevel.default.info('NetworkController - configureStandardProvider', rpcUrl);

    const networkClient = (0, _createJsonRpcClient.default)({
      rpcUrl,
      chainId
    });

    this._setNetworkClient(networkClient);
  }

  _setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const metamaskMiddleware = (0, _createMetamaskMiddleware.default)(this._baseProviderParams);
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    engine.push(metamaskMiddleware);
    engine.push(networkMiddleware);
    const provider = (0, _providerFromEngine.default)(engine);

    this._setProviderAndBlockTracker({
      provider,
      blockTracker
    });
  }

  _setProviderAndBlockTracker({
    provider,
    blockTracker
  }) {
    // update or intialize proxies
    if (this._providerProxy) {
      this._providerProxy.setTarget(provider);
    } else {
      this._providerProxy = (0, _swappableObjProxy.createSwappableProxy)(provider);
    }

    if (this._blockTrackerProxy) {
      this._blockTrackerProxy.setTarget(blockTracker);
    } else {
      this._blockTrackerProxy = (0, _swappableObjProxy.createEventEmitterProxy)(blockTracker, {
        eventFilter: 'skipInternal'
      });
    } // set new provider and blockTracker


    this._provider = provider;
    this._blockTracker = blockTracker;
  }

}

exports.default = NetworkController;


}).call(this,require('_process'))

//# sourceMappingURL=app/scripts/controllers/network/network.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/network.js",}],
[65, {"./handlers":68,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMethodMiddleware;

var _handlers = _interopRequireDefault(require("./handlers"));

const handlerMap = _handlers.default.reduce((map, handler) => {
  for (const methodName of handler.methodNames) {
    map.set(methodName, handler.implementation);
  }

  return map;
}, new Map());
/**
 * Returns a middleware that implements the RPC methods defined in the handlers
 * directory.
 *
 * The purpose of this middleware is to create portable RPC method
 * implementations that are decoupled from the rest of our background
 * architecture.
 *
 * Handlers consume functions that hook into the background, and only depend
 * on their signatures, not e.g. controller internals.
 *
 * Eventually, we'll want to extract this middleware into its own package.
 *
 * @param {Object} opts - The middleware options
 * @param {Function} opts.sendMetrics - A function for sending a metrics event
 * @returns {(req: Object, res: Object, next: Function, end: Function) => void}
 */


function createMethodMiddleware(opts) {
  return function methodMiddleware(req, res, next, end) {
    if (handlerMap.has(req.method)) {
      return handlerMap.get(req.method)(req, res, next, end, opts);
    }

    return next();
  };
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js",}],
[1919, {"assert":1095,"coinstring":1452,"crypto":1478,"safe-buffer":3237,"secp256k1":3253}, function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

//# sourceMappingURL=node_modules/hdkey/lib/hdkey.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/hdkey/lib/hdkey.js",}],
[936, {"buffer":1428,"ethereumjs-abi":1781,"ethereumjs-util":937,"tweetnacl":3442,"tweetnacl-util":3441}, function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



//# sourceMappingURL=node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js",}],
[3408, {"./constants":3398,"./env/node":3404,"./types":3418,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {};
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});

var _node = require("./env/node");

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TrezorConnect = {
  manifest: _node.manifest,
  init: function init(settings) {
    return (0, _node.init)(settings);
  },
  getSettings: _node.getSettings,
  on: function on(type, fn) {
    _node.eventEmitter.on(type, fn);
  },
  off: function off(type, fn) {
    _node.eventEmitter.removeListener(type, fn);
  },
  removeAllListeners: function removeAllListeners() {
    _node.eventEmitter.removeAllListeners();
  },
  uiResponse: _node.uiResponse,
  // methods
  blockchainGetAccountBalanceHistory: function blockchainGetAccountBalanceHistory(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetAccountBalanceHistory'
    }, params));
  },
  blockchainGetCurrentFiatRates: function blockchainGetCurrentFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetCurrentFiatRates'
    }, params));
  },
  blockchainGetFiatRatesForTimestamps: function blockchainGetFiatRatesForTimestamps(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetFiatRatesForTimestamps'
    }, params));
  },
  blockchainDisconnect: function blockchainDisconnect(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainDisconnect'
    }, params));
  },
  blockchainEstimateFee: function blockchainEstimateFee(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainEstimateFee'
    }, params));
  },
  blockchainGetTransactions: function blockchainGetTransactions(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetTransactions'
    }, params));
  },
  blockchainSetCustomBackend: function blockchainSetCustomBackend(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSetCustomBackend'
    }, params));
  },
  blockchainSubscribe: function blockchainSubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribe'
    }, params));
  },
  blockchainSubscribeFiatRates: function blockchainSubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribeFiatRates'
    }, params));
  },
  blockchainUnsubscribe: function blockchainUnsubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribe'
    }, params));
  },
  blockchainUnsubscribeFiatRates: function blockchainUnsubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribeFiatRates'
    }, params));
  },
  customMessage: function customMessage(params) {
    return (0, _node.customMessage)(params);
  },
  requestLogin: function requestLogin(params) {
    return (0, _node.requestLogin)(params);
  },
  cardanoGetAddress: function cardanoGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'cardanoGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  cardanoGetPublicKey: function cardanoGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoGetPublicKey'
    }, params));
  },
  cardanoSignTransaction: function cardanoSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoSignTransaction'
    }, params));
  },
  cipherKeyValue: function cipherKeyValue(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cipherKeyValue'
    }, params));
  },
  composeTransaction: function composeTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'composeTransaction'
    }, params));
  },
  debugLinkDecision: function debugLinkDecision(params) {
    return (0, _node.call)(_objectSpread({
      method: 'debugLinkDecision'
    }, params));
  },
  debugLinkGetState: function debugLinkGetState(params) {
    return (0, _node.call)(_objectSpread({
      method: 'debugLinkGetState'
    }, params));
  },
  ethereumGetAddress: function ethereumGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'ethereumGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  ethereumGetPublicKey: function ethereumGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumGetPublicKey'
    }, params));
  },
  ethereumSignMessage: function ethereumSignMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignMessage'
    }, params));
  },
  ethereumSignTransaction: function ethereumSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignTransaction'
    }, params));
  },
  ethereumVerifyMessage: function ethereumVerifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumVerifyMessage'
    }, params));
  },
  getAccountInfo: function getAccountInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getAccountInfo'
    }, params));
  },
  getAddress: function getAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'getAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  getDeviceState: function getDeviceState(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getDeviceState'
    }, params));
  },
  getFeatures: function getFeatures(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getFeatures'
    }, params));
  },
  getPublicKey: function getPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getPublicKey'
    }, params));
  },
  liskGetAddress: function liskGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'liskGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  liskGetPublicKey: function liskGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'liskGetPublicKey'
    }, params));
  },
  liskSignMessage: function liskSignMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'liskSignMessage'
    }, params));
  },
  liskSignTransaction: function liskSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'liskSignTransaction'
    }, params));
  },
  liskVerifyMessage: function liskVerifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'liskVerifyMessage'
    }, params));
  },
  nemGetAddress: function nemGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'nemGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  nemSignTransaction: function nemSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'nemSignTransaction'
    }, params));
  },
  pushTransaction: function pushTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'pushTransaction'
    }, params));
  },
  rippleGetAddress: function rippleGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'rippleGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  rippleSignTransaction: function rippleSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'rippleSignTransaction'
    }, params));
  },
  signMessage: function signMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signMessage'
    }, params));
  },
  signTransaction: function signTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signTransaction'
    }, params));
  },
  stellarGetAddress: function stellarGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'stellarGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  stellarSignTransaction: function stellarSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'stellarSignTransaction'
    }, params));
  },
  tezosGetAddress: function tezosGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'tezosGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  tezosGetPublicKey: function tezosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosGetPublicKey'
    }, params));
  },
  tezosSignTransaction: function tezosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosSignTransaction'
    }, params));
  },
  eosGetPublicKey: function eosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosGetPublicKey'
    }, params));
  },
  eosSignTransaction: function eosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosSignTransaction'
    }, params));
  },
  binanceGetAddress: function binanceGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'binanceGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  binanceGetPublicKey: function binanceGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceGetPublicKey'
    }, params));
  },
  binanceSignTransaction: function binanceSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceSignTransaction'
    }, params));
  },
  verifyMessage: function verifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'verifyMessage'
    }, params));
  },
  resetDevice: function resetDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'resetDevice'
    }, params));
  },
  wipeDevice: function wipeDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'wipeDevice'
    }, params));
  },
  applyFlags: function applyFlags(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applyFlags'
    }, params));
  },
  applySettings: function applySettings(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applySettings'
    }, params));
  },
  backupDevice: function backupDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'backupDevice'
    }, params));
  },
  changePin: function changePin(params) {
    return (0, _node.call)(_objectSpread({
      method: 'changePin'
    }, params));
  },
  firmwareUpdate: function firmwareUpdate(params) {
    return (0, _node.call)(_objectSpread({
      method: 'firmwareUpdate'
    }, params));
  },
  recoveryDevice: function recoveryDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'recoveryDevice'
    }, params));
  },
  getCoinInfo: function getCoinInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getCoinInfo'
    }, params));
  },
  dispose: function dispose() {
    (0, _node.dispose)();
  },
  cancel: _node.cancel,
  renderWebUSBButton: function renderWebUSBButton(className) {
    (0, _node.renderWebUSBButton)(className);
  },
  disableWebUSB: function disableWebUSB() {
    (0, _node.disableWebUSB)();
  }
};
var _default = TrezorConnect;
exports["default"] = _default;
//# sourceMappingURL=node_modules/trezor-connect/lib/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/index.js",}],
[26, {"eth-rpc-errors":1748,"json-rpc-engine":2274}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPermissionsMethodMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _ethRpcErrors = require("eth-rpc-errors");

/**
 * Create middleware for handling certain methods and preprocessing permissions requests.
 */
function createPermissionsMethodMiddleware({
  addDomainMetadata,
  getAccounts,
  getUnlockPromise,
  hasPermission,
  notifyAccountsChanged,
  requestAccountsPermission
}) {
  let isProcessingRequestAccounts = false;
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    let responseHandler;

    switch (req.method) {
      // Intercepting eth_accounts requests for backwards compatibility:
      // The getAccounts call below wraps the rpc-cap middleware, and returns
      // an empty array in case of errors (such as 4100:unauthorized)
      case 'eth_accounts':
        {
          res.result = await getAccounts();
          return;
        }

      case 'eth_requestAccounts':
        {
          if (isProcessingRequestAccounts) {
            res.error = _ethRpcErrors.ethErrors.rpc.resourceUnavailable('Already processing eth_requestAccounts. Please wait.');
            return;
          }

          if (hasPermission('eth_accounts')) {
            isProcessingRequestAccounts = true;
            await getUnlockPromise();
            isProcessingRequestAccounts = false;
          } // first, just try to get accounts


          let accounts = await getAccounts();

          if (accounts.length > 0) {
            res.result = accounts;
            return;
          } // if no accounts, request the accounts permission


          try {
            await requestAccountsPermission();
          } catch (err) {
            res.error = err;
            return;
          } // get the accounts again


          accounts = await getAccounts();
          /* istanbul ignore else: too hard to induce, see below comment */

          if (accounts.length > 0) {
            res.result = accounts;
          } else {
            // this should never happen, because it should be caught in the
            // above catch clause
            res.error = _ethRpcErrors.ethErrors.rpc.internal('Accounts unexpectedly unavailable. Please report this bug.');
          }

          return;
        }
      // custom method for getting metadata from the requesting domain,
      // sent automatically by the inpage provider when it's initialized

      case 'metamask_sendDomainMetadata':
        {
          var _req$params;

          if (typeof ((_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.name) === 'string') {
            addDomainMetadata(req.origin, req.params);
          }

          res.result = true;
          return;
        }
      // register return handler to send accountsChanged notification

      case 'wallet_requestPermissions':
        {
          var _req$params2;

          if ('eth_accounts' in ((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2[0])) {
            responseHandler = async () => {
              if (Array.isArray(res.result)) {
                for (const permission of res.result) {
                  if (permission.parentCapability === 'eth_accounts') {
                    notifyAccountsChanged(await getAccounts());
                  }
                }
              }
            };
          }

          break;
        }

      default:
        break;
    } // when this promise resolves, the response is on its way back
    // eslint-disable-next-line node/callback-return


    await next();

    if (responseHandler) {
      responseHandler();
    }
  });
}

//# sourceMappingURL=app/scripts/controllers/permissions/permissionsMethodMiddleware.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/permissions/permissionsMethodMiddleware.js",}],
[25, {"../../../../shared/constants/permissions":3596,"./enums":23,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"fast-safe-stringify":1875}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fastSafeStringify = _interopRequireDefault(require("fast-safe-stringify"));

var _permissions = require("../../../../shared/constants/permissions");

var _enums = require("./enums");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Controller with middleware for logging requests and responses to restricted
 * and permissions-related methods.
 */
class PermissionsLogController {
  constructor({
    restrictedMethods,
    store
  }) {
    this.restrictedMethods = restrictedMethods;
    this.store = store;
  }
  /**
   * Get the activity log.
   *
   * @returns {Array<Object>} The activity log.
   */


  getActivityLog() {
    return this.store.getState()[_enums.LOG_STORE_KEY] || [];
  }
  /**
   * Update the activity log.
   *
   * @param {Array<Object>} logs - The new activity log array.
   */


  updateActivityLog(logs) {
    this.store.updateState({
      [_enums.LOG_STORE_KEY]: logs
    });
  }
  /**
   * Get the permissions history log.
   *
   * @returns {Object} The permissions history log.
   */


  getHistory() {
    return this.store.getState()[_enums.HISTORY_STORE_KEY] || {};
  }
  /**
   * Update the permissions history log.
   *
   * @param {Object} history - The new permissions history log object.
   */


  updateHistory(history) {
    this.store.updateState({
      [_enums.HISTORY_STORE_KEY]: history
    });
  }
  /**
   * Updates the exposed account history for the given origin.
   * Sets the 'last seen' time to Date.now() for the given accounts.
   * Returns if the accounts array is empty.
   *
   * @param {string} origin - The origin that the accounts are exposed to.
   * @param {Array<string>} accounts - The accounts.
   */


  updateAccountsHistory(origin, accounts) {
    if (accounts.length === 0) {
      return;
    }

    const accountToTimeMap = getAccountToTimeMap(accounts, Date.now());
    this.commitNewHistory(origin, {
      eth_accounts: {
        accounts: accountToTimeMap
      }
    });
  }
  /**
   * Create a permissions log middleware. Records permissions activity and history:
   *
   * Activity: requests and responses for restricted and most wallet_ methods.
   *
   * History: for each origin, the last time a permission was granted, including
   * which accounts were exposed, if any.
   *
   * @returns {JsonRpcEngineMiddleware} The permissions log middleware.
   */


  createMiddleware() {
    return (req, res, next, _end) => {
      let activityEntry, requestedMethods;
      const {
        origin,
        method
      } = req;
      const isInternal = method.startsWith(_enums.WALLET_PREFIX); // we only log certain methods

      if (!_enums.LOG_IGNORE_METHODS.includes(method) && (isInternal || this.restrictedMethods.includes(method))) {
        activityEntry = this.logRequest(req, isInternal);

        if (method === `${_enums.WALLET_PREFIX}requestPermissions`) {
          // get the corresponding methods from the requested permissions so
          // that we can record permissions history
          requestedMethods = this.getRequestedMethods(req);
        }
      } else if (method === 'eth_requestAccounts') {
        // eth_requestAccounts is a special case; we need to extract the accounts
        // from it
        activityEntry = this.logRequest(req, isInternal);
        requestedMethods = ['eth_accounts'];
      } else {
        // no-op
        next();
        return;
      } // call next with a return handler for capturing the response


      next(cb => {
        const time = Date.now();
        this.logResponse(activityEntry, res, time);

        if (requestedMethods && !res.error && res.result) {
          // any permissions or accounts changes will be recorded on the response,
          // so we only log permissions history here
          this.logPermissionsHistory(requestedMethods, origin, res.result, time, method === 'eth_requestAccounts');
        }

        cb();
      });
    };
  }
  /**
   * Creates and commits an activity log entry, without response data.
   *
   * @param {Object} request - The request object.
   * @param {boolean} isInternal - Whether the request is internal.
   */


  logRequest(request, isInternal) {
    const activityEntry = {
      id: request.id,
      method: request.method,
      methodType: isInternal ? _enums.LOG_METHOD_TYPES.internal : _enums.LOG_METHOD_TYPES.restricted,
      origin: request.origin,
      request: (0, _fastSafeStringify.default)(request, null, 2),
      requestTime: Date.now(),
      response: null,
      responseTime: null,
      success: null
    };
    this.commitNewActivity(activityEntry);
    return activityEntry;
  }
  /**
   * Adds response data to an existing activity log entry.
   * Entry assumed already committed (i.e., in the log).
   *
   * @param {Object} entry - The entry to add a response to.
   * @param {Object} response - The response object.
   * @param {number} time - Output from Date.now()
   */


  logResponse(entry, response, time) {
    if (!entry || !response) {
      return;
    }

    entry.response = (0, _fastSafeStringify.default)(response, null, 2);
    entry.responseTime = time;
    entry.success = !response.error;
  }
  /**
   * Commit a new entry to the activity log.
   * Removes the oldest entry from the log if it exceeds the log limit.
   *
   * @param {Object} entry - The activity log entry.
   */


  commitNewActivity(entry) {
    const logs = this.getActivityLog(); // add new entry to end of log

    logs.push(entry); // remove oldest log if exceeding size limit

    if (logs.length > _enums.LOG_LIMIT) {
      logs.shift();
    }

    this.updateActivityLog(logs);
  }
  /**
   * Create new permissions history log entries, if any, and commit them.
   *
   * @param {Array<string>} requestedMethods - The method names corresponding to the requested permissions.
   * @param {string} origin - The origin of the permissions request.
   * @param {Array<IOcapLdCapability} result - The permissions request response.result.
   * @param {string} time - The time of the request, i.e. Date.now().
   * @param {boolean} isEthRequestAccounts - Whether the permissions request was 'eth_requestAccounts'.
   */


  logPermissionsHistory(requestedMethods, origin, result, time, isEthRequestAccounts) {
    let accounts, newEntries;

    if (isEthRequestAccounts) {
      accounts = result;
      const accountToTimeMap = getAccountToTimeMap(accounts, time);
      newEntries = {
        eth_accounts: {
          accounts: accountToTimeMap,
          lastApproved: time
        }
      };
    } else {
      // Records new "lastApproved" times for the granted permissions, if any.
      // Special handling for eth_accounts, in order to record the time the
      // accounts were last seen or approved by the origin.
      newEntries = result.map(perm => {
        if (perm.parentCapability === 'eth_accounts') {
          accounts = this.getAccountsFromPermission(perm);
        }

        return perm.parentCapability;
      }).reduce((acc, method) => {
        // all approved permissions will be included in the response,
        // not just the newly requested ones
        if (requestedMethods.includes(method)) {
          if (method === 'eth_accounts') {
            const accountToTimeMap = getAccountToTimeMap(accounts, time);
            acc[method] = {
              lastApproved: time,
              accounts: accountToTimeMap
            };
          } else {
            acc[method] = {
              lastApproved: time
            };
          }
        }

        return acc;
      }, {});
    }

    if (Object.keys(newEntries).length > 0) {
      this.commitNewHistory(origin, newEntries);
    }
  }
  /**
   * Commit new entries to the permissions history log.
   * Merges the history for the given origin, overwriting existing entries
   * with the same key (permission name).
   *
   * @param {string} origin - The requesting origin.
   * @param {Object} newEntries - The new entries to commit.
   */


  commitNewHistory(origin, newEntries) {
    // a simple merge updates most permissions
    const history = this.getHistory();

    const newOriginHistory = _objectSpread(_objectSpread({}, history[origin]), newEntries); // eth_accounts requires special handling, because of information
    // we store about the accounts


    const existingEthAccountsEntry = history[origin] && history[origin].eth_accounts;
    const newEthAccountsEntry = newEntries.eth_accounts;

    if (existingEthAccountsEntry && newEthAccountsEntry) {
      // we may intend to update just the accounts, not the permission
      // itself
      const lastApproved = newEthAccountsEntry.lastApproved || existingEthAccountsEntry.lastApproved; // merge old and new eth_accounts history entries

      newOriginHistory.eth_accounts = {
        lastApproved,
        accounts: _objectSpread(_objectSpread({}, existingEthAccountsEntry.accounts), newEthAccountsEntry.accounts)
      };
    }

    history[origin] = newOriginHistory;
    this.updateHistory(history);
  }
  /**
   * Get all requested methods from a permissions request.
   *
   * @param {Object} request - The request object.
   * @returns {Array<string>} The names of the requested permissions.
   */


  getRequestedMethods(request) {
    if (!request.params || !request.params[0] || typeof request.params[0] !== 'object' || Array.isArray(request.params[0])) {
      return null;
    }

    return Object.keys(request.params[0]);
  }
  /**
   * Get the permitted accounts from an eth_accounts permissions object.
   * Returns an empty array if the permission is not eth_accounts.
   *
   * @param {Object} perm - The permissions object.
   * @returns {Array<string>} The permitted accounts.
   */


  getAccountsFromPermission(perm) {
    if (perm.parentCapability !== 'eth_accounts' || !perm.caveats) {
      return [];
    }

    const accounts = new Set();

    for (const caveat of perm.caveats) {
      if (caveat.name === _permissions.CAVEAT_NAMES.exposedAccounts && Array.isArray(caveat.value)) {
        for (const value of caveat.value) {
          accounts.add(value);
        }
      }
    }

    return [...accounts];
  }

} // helper functions

/**
 * Get a map from account addresses to the given time.
 *
 * @param {Array<string>} accounts - An array of addresses.
 * @param {number} time - A time, e.g. Date.now().
 * @returns {Object} A string:number map of addresses to time.
 */


exports.default = PermissionsLogController;

function getAccountToTimeMap(accounts, time) {
  return accounts.reduce((acc, account) => _objectSpread(_objectSpread({}, acc), {}, {
    [account]: time
  }), {});
}

//# sourceMappingURL=app/scripts/controllers/permissions/permissionsLog.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/permissions/permissionsLog.js",}],
[3168, {"./src/caveats":3169,"./src/errors":3170,"@metamask/controllers":3181,"json-rpc-engine":3234,"json-rpc-engine/src/asMiddleware":3233,"uuid/v4":3464}, function (require, module, exports) {
"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CapabilitiesController = void 0;
const v4_1 = __importDefault(require("uuid/v4"));
const controllers_1 = require("@metamask/controllers");
const caveats_1 = require("./src/caveats");
const errors_1 = require("./src/errors");
const JsonRpcEngine = require('json-rpc-engine');
const asMiddleware = require('json-rpc-engine/src/asMiddleware');
class Capability {
    constructor({ method, caveats, invoker }) {
        this['@context'] = ['https://github.com/MetaMask/rpc-cap'];
        this.parentCapability = method;
        this.id = v4_1.default();
        this.date = Date.now();
        this.invoker = invoker;
        if (caveats) {
            this.caveats = caveats;
        }
    }
    toJSON() {
        return {
            '@context': this['@context'],
            invoker: this.invoker,
            parentCapability: this.parentCapability,
            id: this.id,
            date: this.date,
            caveats: this.caveats,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
class CapabilitiesController extends controllers_1.BaseController {
    constructor(config, state) {
        super(config, state || {});
        this.caveats = { requireParams: caveats_1.requireParams, filterResponse: caveats_1.filterResponse, limitResponseLength: caveats_1.limitResponseLength, forceParams: caveats_1.forceParams };
        this.safeMethods = config.safeMethods || [];
        this.restrictedMethods = config.restrictedMethods || {};
        this.methodPrefix = config.methodPrefix || '';
        this.engine = config.engine || undefined;
        if (!config.requestUserApproval) {
            throw new Error('User approval prompt required.');
        }
        this.requestUserApproval = config.requestUserApproval;
        this.defaultState = {
            permissionsRequests: [],
            permissionsDescriptions: Object.keys(this.restrictedMethods).reduce((acc, methodName) => {
                acc[methodName] = this.restrictedMethods[methodName].description;
                return acc;
            }, {}),
        };
        this.internalMethods = {};
        this.internalMethods[`${this.methodPrefix}getPermissions`] = this.getPermissionsMiddleware.bind(this);
        this.internalMethods[`${this.methodPrefix}requestPermissions`] = this.requestPermissionsMiddleware.bind(this);
        this.initialize();
    }
    serialize() {
        return this.state;
    }
    /**
     * Returns a capabilities middleware function bound to its parent
     * CapabilitiesController object with the given domain as its
     * first argument.
     * @param  {string} domain the domain to bind the middleware to
     */
    createBoundMiddleware(domain) {
        return this.providerMiddlewareFunction.bind(this, { origin: domain });
    }
    /**
     * Returns a JsonRpcEngine with a single, bound capabilities middleware with
     * the given domain as its first argument.
     * See createBoundMiddleware for more information.
     * @param  {string} domain the domain to bind the middleware to
     */
    createPermissionedEngine(domain) {
        const engine = new JsonRpcEngine();
        engine.push(this.createBoundMiddleware(domain));
        return engine;
    }
    /**
     * Returns a nearly json-rpc-engine compatible method.
     * The one difference being the first argument should be
     * a unique string identifying the requesting agent/entity,
     * referred to as `domain` in the code. This allows the function
     * to be curried and converted into a normal json-rpc-middleware function.
     */
    providerMiddlewareFunction(domain, req, res, next, end) {
        const methodName = req.method;
        // skip registered safe/passthrough methods.
        if (this.safeMethods.includes(methodName)) {
            return next();
        }
        // handle internal methods before any restricted methods.
        if (this.internalMethods[methodName]) {
            return this.internalMethods[methodName](domain, req, res, next, end);
        }
        // if the method also is not a restricted method, the method does not exist
        if (!this.getMethodKeyFor(methodName)) {
            res.error = errors_1.methodNotFound({ methodName, data: req });
            return end(res.error);
        }
        let permission;
        try {
            permission = this.getPermission(domain.origin, methodName);
        }
        catch (err) {
            // unexpected internal error
            res.error = errors_1.internalError({ data: err });
            return end(res.error);
        }
        if (!permission) {
            res.error = errors_1.unauthorized({ data: req });
            return end(res.error);
        }
        this.executeMethod(domain, req, res, next, end);
    }
    /**
     * Used for retrieving the key that manages the restricted method
     * associated with the current RPC `method` key.
     *
     * Used to support our namespaced method feature, which allows blocks
     * of methods to be hidden behind a restricted method with a trailing `_` character.
     *
     * @param method string - The requested rpc method.
     * @returns methodKey string
     */
    getMethodKeyFor(method) {
        const managedMethods = Object.keys(this.restrictedMethods);
        // Return exact matches:
        if (managedMethods.includes(method)) {
            return method;
        }
        const wildCardMethodsWithoutWildCard = managedMethods.reduce((acc, methodName) => {
            const wildCardMatch = methodName.match(/(.+)\*$/);
            return wildCardMatch ? Object.assign(Object.assign({}, acc), { [wildCardMatch[1]]: true }) : acc;
        }, {});
        // Check for potentially nested namespaces:
        // Ex: wildzone_
        // Ex: eth_plugin_
        const segments = method.split('_');
        let managed = '';
        while (segments.length > 0 && !managedMethods.includes(managed) && !wildCardMethodsWithoutWildCard[managed]) {
            managed += segments.shift() + '_';
        }
        if (managedMethods.includes(managed)) {
            return managed;
        }
        else if (wildCardMethodsWithoutWildCard[managed]) {
            return managed + '*';
        }
        else {
            return '';
        }
    }
    executeMethod(domain, req, res, next, end) {
        const methodKey = this.getMethodKeyFor(req.method);
        const permission = this.getPermission(domain.origin, req.method);
        if (methodKey && typeof this.restrictedMethods[methodKey].method === 'function') {
            const virtualEngine = this.createVirtualEngineFor(domain);
            // Check for Caveats:
            if ((permission === null || permission === void 0 ? void 0 : permission.caveats) && permission.caveats.length > 0) {
                const engine = new JsonRpcEngine();
                permission.caveats.forEach((serializedCaveat) => {
                    const caveatFnGens = this.caveats;
                    const caveatFnGen = caveatFnGens[serializedCaveat.type];
                    const caveatFn = caveatFnGen(serializedCaveat);
                    engine.push(caveatFn);
                });
                engine.push((req, res, next, end) => {
                    return this.restrictedMethods[methodKey].method(req, res, next, end, virtualEngine);
                });
                const middleware = asMiddleware(engine);
                return middleware(req, res, next, end);
            }
            else {
                return this.restrictedMethods[methodKey].method(req, res, next, end, virtualEngine);
            }
        }
        res.error = errors_1.methodNotFound({ methodName: req.method, data: req });
        return end(res.error);
    }
    createVirtualEngineFor(domain) {
        const engine = new JsonRpcEngine();
        engine.push(this.providerMiddlewareFunction.bind(this, domain));
        /**
         * If an engine was provided, it is used as the final step
         * for the middleware provider.
         */
        if (this.engine) {
            engine.push(asMiddleware(this.engine));
        }
        engine.domain = domain.origin;
        return engine;
    }
    getPermissionsForDomain(domain) {
        const { domains = {} } = this.state;
        if (domains[domain]) {
            const { permissions } = domains[domain];
            return permissions;
        }
        return [];
    }
    /**
     * Get the parent-most permission granting the requested domain's method permission.
     * Follows the delegation chain of the first matching permission found.
     *
     * @param {string} domain - The domain whose permission to retrieve.
     * @param {string} method - The method
     */
    getPermission(domain, method) {
        const permissions = this.getPermissionsForDomain(domain).filter(p => {
            return p.parentCapability === method;
        });
        if (permissions.length > 0) {
            return permissions.shift();
        }
        return undefined;
    }
    /**
     * Gets current permissions request objects.
     * Useful for displaying information for user consent.
     */
    getPermissionsRequests() {
        const reqs = this.state.permissionsRequests;
        return reqs || [];
    }
    /**
     * Used for removing a permissions request from the permissions request array.
     *
     * @param requestId The id of the pending permissions request that no longer
     * requires user attention.
     */
    removePermissionsRequest(requestId) {
        const reqs = this.getPermissionsRequests().filter((oldReq) => {
            return oldReq.metadata.id !== requestId;
        });
        this.setPermissionsRequests(reqs);
    }
    setPermissionsRequests(permissionsRequests) {
        this.update({ permissionsRequests });
    }
    /**
     * Used for granting a new set of permissions,
     * after the user has approved it.
     *
     * @param {string} domain - The domain receiving new permissions.
     * @param {IRequestedPermissions} approvedPermissions - An object of objects describing the granted permissions.
     * @param {JsonRpcResponse} res - The response.
     * @param {JsonRpcEngineEndCallback} end - The end function.
     */
    grantNewPermissions(domain, approved, res, end) {
        if (!domain || typeof domain !== 'string') {
            res.error = errors_1.invalidReq(`Invalid domain: '${domain}'.`);
            return end(res.error);
        }
        // Enforce actual approving known methods:
        for (const methodName in approved) {
            if (!this.getMethodKeyFor(methodName)) {
                res.error = errors_1.methodNotFound({ methodName });
                return end(res.error);
            }
        }
        const permissions = {};
        for (const method in approved) {
            const newPerm = new Capability({
                method,
                invoker: domain,
                caveats: approved[method].caveats,
            });
            if (newPerm.caveats && !this.validateCaveats(newPerm.caveats)) {
                res.error = errors_1.internalError({
                    message: 'Invalid caveats.',
                    data: newPerm,
                });
                return end(res.error);
            }
            permissions[method] = newPerm;
        }
        this.addPermissionsFor(domain, permissions);
        res.result = this.getPermissionsForDomain(domain);
        end();
    }
    getDomains() {
        const { domains } = this.state;
        return domains || {};
    }
    setDomains(domains) {
        this.update({ domains });
    }
    /**
     * Gets the domain settings for the given IOriginString.
     * Returns a template RpcCapDomainEntry if no entry exists, but does NOT
     * store the settings. That is left to the consumer.
     *
     * @param {IOriginString} domain - The origin string of the domain.
     * @returns {RpcCapDomainEntry} - The settings for the domain.
     */
    getOrCreateDomainSettings(domain) {
        const entry = this.getDomainSettings(domain);
        if (entry === undefined) {
            return { permissions: [] };
        }
        else {
            return entry;
        }
    }
    /**
     * Gets the domain settings for the given IOriginString, or undefined if
     * none exist.
     *
     * @param {IOriginString} domain - The origin string of the domain.
     * @returns {RpcCapDomainEntry | undefined} - The settings for the domain,
     * or undefined if none exist.
     */
    getDomainSettings(domain) {
        return this.getDomains()[domain];
    }
    /**
     * Sets the domain identified by the given IOriginString.
     * If the domain has no permissions, its key will be deleted from the
     * controller's domains.
     *
     * @param {IOriginString} domain - The origin string of the domain.
     * @param {RpcCapDomainEntry} domainSettings - The associated domain settings.
     */
    setDomain(domain, domainSettings) {
        const domains = this.getDomains();
        if (domainSettings.permissions.length > 0) {
            domains[domain] = domainSettings;
        }
        else {
            delete domains[domain];
        }
        this.setDomains(domains);
    }
    /**
     * Adds permissions to the given domain. Overwrites existing identical
     * permissions (same domain, and method). Other existing permissions
     * remain unaffected.
     *
     * @param {string} domainName - The grantee domain.
     * @param {Array} newPermissions - The unique, new permissions for the grantee domain.
     */
    addPermissionsFor(domainName, newPermissions) {
        const domain = this.getOrCreateDomainSettings(domainName);
        const newKeys = Object.keys(newPermissions);
        // remove old permissions so that they will be overwritten
        domain.permissions = domain.permissions.filter((oldPerm) => {
            return !newKeys.includes(oldPerm.parentCapability);
        });
        for (const methodName in newPermissions) {
            domain.permissions.push(newPermissions[methodName]);
        }
        this.setDomain(domainName, domain);
    }
    /**
     * Validates the given caveats (of a single permission).
     * If the caveats have names, they must be unique.
     * Returns true if valid, false otherwise.
     *
     * @param {IOcapLdCaveat[]} - The caveats to validate.
     */
    validateCaveats(caveats) {
        const seenNames = {};
        for (const c of caveats) {
            if (!this.validateCaveat(c) ||
                c.name && seenNames[c.name] // names must be unique
            ) {
                return false;
            }
            // record name if it exists
            if (c.name) {
                seenNames[c.name] = true;
            }
        }
        return true;
    }
    /**
     * Validates the given caveat. Returns true if valid, false otherwise.
     *
     * @param {IOcapLdCaveat} - The caveat to validate.
     */
    validateCaveat(caveat) {
        if (!caveat || typeof caveat !== 'object' || Array.isArray(caveat) ||
            !caveat.type || typeof caveat.type !== 'string' ||
            caveat.name === '' || // name may be omitted, but not empty
            caveat.name && typeof caveat.name !== 'string') {
            return false;
        }
        return true;
    }
    /**
     * Gets all caveats for the permission corresponding to the given domain and
     * method, or undefined if the permission or its caveats does not exist.
     *
     * @param {string} domainName - The grantee domain.
     * @param {string} methodName - The name of the method identifying the permission.
     */
    getCaveats(domainName, methodName) {
        const perm = this.getPermission(domainName, methodName);
        return perm === null || perm === void 0 ? void 0 : perm.caveats;
    }
    /**
     * Gets the caveat with the given name for the permission corresponding to the
     * given domain and method, or undefined if the permission or the target
     * caveat does not exist.
     *
     * @param {string} domainName - The grantee domain.
     * @param {string} methodName - The name of the method identifying the permission.
     * @param {string} caveatName - The name of the caveat to retrieve.
     */
    getCaveat(domainName, methodName, caveatName) {
        const perm = this.getPermission(domainName, methodName);
        return perm
            ? perm.caveats && perm.caveats.find(c => c.name === caveatName)
            : undefined;
    }
    /**
     * Adds the given caveat to the permission corresponding to the given domain
     * and method. Throws if the domain or method are unrecognized, or in case of
     * a caveat name collision.
     *
     * @param {string} domainName - The grantee domain.
     * @param {string} methodName - The name of the method identifying the permission.
     * @param {IOcapLdCaveat} caveat - The caveat to add.
     */
    addCaveatFor(domainName, methodName, caveat) {
        // assert caveat is valid
        if (!this.validateCaveat(caveat)) {
            throw errors_1.internalError({
                message: 'Invalid caveat param. Must be a valid caveat object.',
                data: caveat,
            });
        }
        const perm = this._getPermissionForCaveat(domainName, methodName);
        const newCaveats = perm.caveats
            ? [...perm.caveats, caveat]
            : [caveat];
        this._validateAndUpdateCaveats(domainName, methodName, newCaveats, perm);
    }
    /**
     * Updates the value of the caveat with the given name for the permission
     * corresponding to the given domain and method. Throws if the domain
     * or method are unrecognized, or if a caveat with the given name doesn't
     * exist.
     *
     * @param {string} domainName - The grantee domain.
     * @param {string} methodName - The name of the method identifying the permission.
     * @param {string} caveatName - The name of the caveat.
     * @param {any} caveatValue - The new value for the caveat.
     */
    updateCaveatFor(domainName, methodName, caveatName, caveatValue) {
        if (!caveatName || typeof caveatName !== 'string') {
            throw errors_1.internalError({
                message: 'Invalid caveat param. Must specify a string name.',
                data: caveatName,
            });
        }
        const perm = this._getPermissionForCaveat(domainName, methodName);
        // get target caveat
        const caveat = perm.caveats && perm.caveats.find(c => c.name === caveatName);
        // copy over all caveats except the target
        const newCaveats = [];
        perm.caveats && perm.caveats.forEach(c => {
            if (c.name !== caveatName) {
                newCaveats.push(c);
            }
        });
        // assert that the target caveat exists
        if (!caveat || !perm.caveats) {
            throw errors_1.internalError({
                message: 'No such caveat exists for the relevant permission.',
                data: caveatName,
            });
        }
        if (typeof caveat.value !== typeof caveatValue) {
            throw errors_1.internalError({
                message: 'New caveat value is of different type than original.',
                data: { caveat, newValue: caveatValue },
            });
        }
        caveat.value = caveatValue;
        newCaveats.push(caveat);
        this._validateAndUpdateCaveats(domainName, methodName, newCaveats, perm);
    }
    /**
     * Internal function used in addCaveatFor and updateCaveatFor.
     */
    _getPermissionForCaveat(domainName, methodName) {
        // assert domain already has permission
        const perm = this.getPermission(domainName, methodName);
        if (!perm) {
            throw errors_1.internalError({
                message: 'No such permission exists for the given domain.',
                data: { domain: domainName, method: methodName },
            });
        }
        return perm;
    }
    /**
     * Internal function used in addCaveatFor and updateCaveatFor.
     */
    _validateAndUpdateCaveats(domainName, methodName, newCaveats, perm) {
        // assert that new caveats are valid
        if (!this.validateCaveats(newCaveats)) {
            throw errors_1.internalError({
                message: 'The new caveats are jointly invalid.',
                data: newCaveats,
            });
        }
        // construct new permission with new caveat
        const newPermissions = {};
        perm.caveats = newCaveats;
        newPermissions[methodName] = perm;
        // overwrite the existing permission, completing the update
        this.addPermissionsFor(domainName, newPermissions);
    }
    /**
     * Removes the specified permissions from the given domain.
     *
     * @param {string} domainName - The domain name whose permissions to remove.
     * @param {Array} permissionsToRemove - Objects identifying the permissions to remove.
     */
    removePermissionsFor(domainName, permissionsToRemove) {
        // returns { permissions: [] } for new domains
        const domain = this.getDomainSettings(domainName);
        if (!domain) {
            return;
        }
        domain.permissions = domain.permissions.filter((perm) => {
            for (const r of permissionsToRemove) {
                if (r.parentCapability === perm.parentCapability) {
                    return false;
                }
            }
            return true;
        });
        this.setDomain(domainName, domain);
    }
    /**
     * Clear all domains (and thereby remove all permissions).
     */
    clearDomains() {
        this.setDomains({});
    }
    /**
     * Check if a request to requestPermissionsMiddleware is valid.
     */
    validatePermissionsRequest(req) {
        if (!req ||
            !Array.isArray(req.params) ||
            typeof req.params[0] !== 'object' ||
            Array.isArray(req.params[0])) {
            throw errors_1.invalidReq({ data: req });
        }
        const perms = req.params[0];
        for (const methodName in perms) {
            if (perms[methodName].parentCapability !== undefined &&
                methodName !== perms[methodName].parentCapability) {
                throw errors_1.invalidReq({ data: req });
            }
            if (!this.getMethodKeyFor(methodName)) {
                throw errors_1.methodNotFound({ methodName, data: req });
            }
        }
    }
    /**
     * The capabilities middleware function used for getting permissions for a
     * specific domain.
     */
    getPermissionsMiddleware(domain, _req, res, _next, end) {
        const permissions = this.getPermissionsForDomain(domain.origin);
        res.result = permissions;
        end();
    }
    /**
     * The capabilities middleware function used for requesting additional permissions from the user.
     */
    requestPermissionsMiddleware(domain, req, res, _next, end) {
        try {
            this.validatePermissionsRequest(req);
        }
        catch (err) {
            res.error = err;
            return end(res.error);
        }
        const id = typeof req.id === 'number' || req.id
            ? req.id.toString()
            : v4_1.default();
        const permissions = req.params[0];
        const requests = this.getPermissionsRequests();
        const permissionsRequest = {
            metadata: {
                origin: domain.origin,
                id,
            },
            permissions: permissions,
        };
        requests.push(permissionsRequest);
        this.setPermissionsRequests(requests);
        this.requestUserApproval(permissionsRequest)
            .then((approved) => {
            if (Object.keys(approved).length === 0) {
                res.error = errors_1.userRejectedRequest(req);
                return end(res.error);
            }
            this.grantNewPermissions(domain.origin, approved, res, end);
        })
            .catch((reason) => {
            res.error = reason;
            return end(reason);
        })
            .finally(() => {
            // Delete the request object
            this.removePermissionsRequest(permissionsRequest.metadata.id);
        });
    }
}
exports.CapabilitiesController = CapabilitiesController;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/rpc-cap/dist/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/dist/index.js",}],
[148, {}, function (require, module, exports) {
"use strict";

function delay(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

async function loadFromMock3Box(key) {
  const res = await window.fetch(`http://localhost:8889?key=${key}`);
  const text = await res.text();
  return text.length ? JSON.parse(text) : null;
}

async function saveToMock3Box(key, newDataAtKey) {
  const res = await window.fetch('http://localhost:8889', {
    method: 'POST',
    body: JSON.stringify({
      key,
      data: newDataAtKey
    })
  });
  return res.text();
}

class Mock3Box {
  static openBox(address) {
    this.address = address;
    return Promise.resolve({
      onSyncDone: cb => {
        setTimeout(cb, 200);
      },
      openSpace: async (spaceName, config) => {
        const {
          onSyncDone
        } = config;
        this.spaceName = spaceName;
        setTimeout(onSyncDone, 150);
        await delay(50);
        return {
          private: {
            get: async key => {
              await delay(50);
              const res = await loadFromMock3Box(`${this.address}-${this.spaceName}-${key}`);
              return res;
            },
            set: async (key, data) => {
              await saveToMock3Box(`${this.address}-${this.spaceName}-${key}`, data);
              await delay(50);
              return null;
            }
          }
        };
      },
      logout: () => undefined
    });
  }

  static async getConfig(address) {
    const backup = await loadFromMock3Box(`${address}-metamask-metamaskBackup`);
    return backup ? {
      spaces: {
        metamask: {}
      }
    } : {};
  }

}

module.exports = Mock3Box;

//# sourceMappingURL=development/mock-3box.js
}, {file:"/Users/jack/projects/monsta-wallet/development/mock-3box.js",}],
[17, {"./middleware/pending":19,"@babel/runtime/helpers/interopRequireDefault":186,"eth-json-rpc-middleware/wallet":1737,"json-rpc-engine":2274}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMetamaskMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _wallet = _interopRequireDefault(require("eth-json-rpc-middleware/wallet"));

var _pending = require("./middleware/pending");

function createMetamaskMiddleware({
  version,
  getAccounts,
  processTransaction,
  processEthSignMessage,
  processTypedMessage,
  processTypedMessageV3,
  processTypedMessageV4,
  processPersonalMessage,
  processDecryptMessage,
  processEncryptionPublicKey,
  getPendingNonce,
  getPendingTransactionByHash
}) {
  const metamaskMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([(0, _jsonRpcEngine.createScaffoldMiddleware)({
    // staticSubprovider
    eth_syncing: false,
    web3_clientVersion: `MonstaWallet/v${version}`
  }), (0, _wallet.default)({
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processDecryptMessage,
    processEncryptionPublicKey
  }), (0, _pending.createPendingNonceMiddleware)({
    getPendingNonce
  }), (0, _pending.createPendingTxMiddleware)({
    getPendingTransactionByHash
  })]);
  return metamaskMiddleware;
}

//# sourceMappingURL=app/scripts/controllers/network/createMetamaskMiddleware.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/createMetamaskMiddleware.js",}],
[154, {"./3id":155,"./api":157,"./config.js":158,"./privateStore":160,"./publicStore":161,"./space":162,"./utils/id":164,"./utils/index":165,"./verified":167,"3box-orbitdb-plugins":149,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/slicedToArray":199,"@babel/runtime/regenerator":206,"ipfs":2186,"orbit-db":2835,"orbit-db-access-controllers":2768,"orbit-db-pubsub":2828,"store":3341}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var AccessControllers = require('orbit-db-access-controllers');

var _require = require('3box-orbitdb-plugins'),
    LegacyIPFS3BoxAccessController = _require.LegacyIPFS3BoxAccessController,
    ThreadAccessController = _require.ThreadAccessController,
    ModeratorAccessController = _require.ModeratorAccessController;

AccessControllers.addAccessController({
  AccessController: LegacyIPFS3BoxAccessController
});
AccessControllers.addAccessController({
  AccessController: ThreadAccessController
});
AccessControllers.addAccessController({
  AccessController: ModeratorAccessController
});

var ThreeId = require('./3id');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var idUtils = require('./utils/id');

var config = require('./config.js');

var API = require('./api');

var ACCOUNT_TYPES = {
  ethereum: 'ethereum',
  ethereumEOA: 'ethereum-eoa'
};
var ADDRESS_SERVER_URL = config.address_server_url;
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = config.ipfs_options;
var ORBITDB_OPTS = config.orbitdb_options;
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(threeId, ethereumProvider, ipfs) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Box);
    this._3id = threeId;
    this._web3provider = ethereumProvider;
    this._ipfs = ipfs;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};

    this._boxSynced = false;
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this["private"] = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    this.verified = new Verified(this);
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    this.spaces = {}; // local store of all pinning server pubsub messages seen related to spaces

    this.spacesPubSubMessages = {};
  }

  (0, _createClass2["default"])(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var _this = this;

        var opts,
            rootStoreName,
            key,
            rootStoreAddress,
            onNewPeer,
            _ref2,
            _ref3,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            spaceMessageFilterActive,
            filterTimeSet,
            onMessageRes,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                rootStoreName = this._3id.muportFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;

                this._ipfs.swarm.connect(this.pinningNode, function () {});

                _context3.t0 = OrbitDB;
                _context3.t1 = this._ipfs;
                _context3.t2 = opts.orbitPath;
                _context3.next = 9;
                return this._3id.getOdbId();

              case 9:
                _context3.t3 = _context3.sent;
                _context3.t4 = {
                  directory: _context3.t2,
                  identity: _context3.t3
                };
                _context3.next = 13;
                return _context3.t0.createInstance.call(_context3.t0, _context3.t1, _context3.t4);

              case 13:
                this._orbitdb = _context3.sent;
                // , { cache })
                globalOrbitDB = this._orbitdb;
                key = this._3id.getKeyringBySpaceName(rootStoreName).getPublicKeys(true).signingKey;
                _context3.next = 18;
                return this._orbitdb.feed(rootStoreName, _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                }));

              case 18:
                this._rootStore = _context3.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context3.t5 = Pubsub;
                _context3.t6 = this._ipfs;
                _context3.next = 24;
                return this._ipfs.id();

              case 24:
                _context3.t7 = _context3.sent.id;
                this._pubsub = new _context3.t5(_context3.t6, _context3.t7);

                onNewPeer =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee(topic, peer) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (peer === _this.pinningNode.split('/').pop()) {
                              _this._pubsub.publish(PINNING_ROOM, {
                                type: 'PIN_DB',
                                odbAddress: rootStoreAddress,
                                did: _this.DID
                              });
                            }

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function onNewPeer(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                this["public"] = new PublicStore(this._orbitdb, this._3id.muportFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this), this._3id);
                this["private"] = new PrivateStore(this._orbitdb, this._3id.muportFingerprint + '.private', this._ensurePinningNodeConnected.bind(this), this._3id);
                _context3.next = 31;
                return Promise.all([this["public"]._load(), this["private"]._load()]);

              case 31:
                _ref2 = _context3.sent;
                _ref3 = (0, _slicedToArray2["default"])(_ref2, 2);
                pubStoreAddress = _ref3[0];
                privStoreAddress = _ref3[1];
                syncPromises = [];
                hasResponse = {}; // Filters and store space related messages for 3secs, the best effort
                // simple approach, until refactor

                spaceMessageFilterActive = true;
                filterTimeSet = false;

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee2(topic, data) {
                    var promises;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!filterTimeSet) {
                              filterTimeSet = true;
                              setTimeout(function () {
                                spaceMessageFilterActive = false;
                              }, 3000);
                            }

                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context2.next = 12;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this["private"]._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this["public"]._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (spaceMessageFilterActive && data.odbAddress.includes('space') === true) {
                              _this.spacesPubSubMessages[data.odbAddress] = data;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context2.next = 12;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context2.next = 10;
                            return Promise.all(promises);

                          case 10:
                            _this._boxSynced = true;

                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function onMessageRes(_x4, _x5) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                _context3.next = 43;
                return this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 43:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _load() {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var _this2 = this;

        var entries, pinAddressLinks;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._rootStore.load();

              case 2:
                _context5.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context5.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

                pinAddressLinks =
                /*#__PURE__*/
                function () {
                  var _ref5 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4() {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            // Filter for address-links, get CID, and get to pin it
                            entries.filter(function (entry) {
                              return entry.payload.value.type === 'address-link';
                            }).map(function (entry) {
                              _this2._ipfs.dag.get(entry.payload.value.data);
                            });

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function pinAddressLinks() {
                    return _ref5.apply(this, arguments);
                  };
                }();

                pinAddressLinks();

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _createRootStore(_x6, _x7, _x8) {
        return _createRootStore2.apply(this, arguments);
      }

      return _createRootStore;
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(name) {
        var opts,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (this.spaces[name]) {
                  _context6.next = 23;
                  break;
                }

                this.spaces[name] = new Space(name, this._3id, this._orbitdb, this._rootStore, this._ensurePinningNodeConnected.bind(this));
                _context6.prev = 3;
                opts = Object.assign({
                  numEntriesMessages: this.spacesPubSubMessages
                }, opts);
                _context6.next = 7;
                return this.spaces[name].open(opts);

              case 7:
                _context6.next = 9;
                return this.isAddressLinked();

              case 9:
                if (_context6.sent) {
                  _context6.next = 11;
                  break;
                }

                this.linkAddress();

              case 11:
                _context6.next = 21;
                break;

              case 13:
                _context6.prev = 13;
                _context6.t0 = _context6["catch"](3);
                delete this.spaces[name];

                if (!_context6.t0.message.includes('User denied message signature.')) {
                  _context6.next = 20;
                  break;
                }

                throw new Error('User denied space consent.');

              case 20:
                throw new Error('An error occured while opening space: ', _context6.t0.message);

              case 21:
                _context6.next = 24;
                break;

              case 23:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 24:
                return _context6.abrupt("return", this.spaces[name]);

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 13]]);
      }));

      function openSpace(_x9) {
        return _openSpace.apply(this, arguments);
      }

      return openSpace;
    }()
    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */

  }, {
    key: "onSyncDone",
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;

      if (this._boxSynced) {
        this._onSyncDoneCB();
      }
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(rootStoreAddress) {
        var addressToken;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context7.sent;
                _context7.prev = 3;
                _context7.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context7.next = 12;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);

                if (_context7.t0.statusCode) {
                  _context7.next = 12;
                  break;
                }

                throw new Error(_context7.t0);

              case 12:
                return _context7.abrupt("return", true);

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function _publishRootStore(_x10) {
        return _publishRootStore2.apply(this, arguments);
      }

      return _publishRootStore;
    }()
    /**
     * @property {String} DID        the DID of the user
     */

  }, {
    key: "linkAddress",

    /**
     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.
     *
     * @param     {Object}    [link]                         Optional link object with type or proof
     * @param     {String}    [link.type='ethereum-eoa']     The type of link (default 'ethereum')
     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)
     */
    value: function () {
      var _linkAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var link,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                link = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                if (!link.proof) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 4;
                return this._writeAddressLink(link.proof);

              case 4:
                return _context8.abrupt("return");

              case 5:
                if (!(!link.type || link.type === ACCOUNT_TYPES.ethereumEOA)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 8;
                return this._linkProfile();

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function linkAddress() {
        return _linkAddress.apply(this, arguments);
      }

      return linkAddress;
    }()
  }, {
    key: "linkAccount",
    value: function () {
      var _linkAccount = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9() {
        var type,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                type = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('linkAccount: deprecated, please use linkAddress going forward');
                _context9.next = 4;
                return this.linkAddress(type);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function linkAccount() {
        return _linkAccount.apply(this, arguments);
      }

      return linkAccount;
    }()
    /**
     * Remove given address link, returns true if successful
     *
     * @param     {String}   address      address that is linked
     */

  }, {
    key: "removeAddressLink",
    value: function () {
      var _removeAddressLink = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(address) {
        var linkExist, payload, oneHour, deleteToken;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                address = address.toLowerCase();
                _context10.next = 3;
                return this.isAddressLinked({
                  address: address
                });

              case 3:
                linkExist = _context10.sent;

                if (linkExist) {
                  _context10.next = 6;
                  break;
                }

                throw new Error('removeAddressLink: link for given address does not exist');

              case 6:
                payload = {
                  address: address,
                  type: "delete-address-link"
                };
                oneHour = 60 * 60;
                _context10.next = 10;
                return this._3id.signJWT(payload, {
                  expiresIn: oneHour
                });

              case 10:
                deleteToken = _context10.sent;
                _context10.prev = 11;
                _context10.next = 14;
                return utils.fetchJson(this._serverUrl + '/linkdelete', {
                  delete_token: deleteToken
                });

              case 14:
                _context10.next = 20;
                break;

              case 16:
                _context10.prev = 16;
                _context10.t0 = _context10["catch"](11);

                if (_context10.t0.statusCode) {
                  _context10.next = 20;
                  break;
                }

                throw new Error(_context10.t0);

              case 20:
                _context10.next = 22;
                return this._deleteAddressLink(address);

              case 22:
                return _context10.abrupt("return", true);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 16]]);
      }));

      function removeAddressLink(_x11) {
        return _removeAddressLink.apply(this, arguments);
      }

      return removeAddressLink;
    }()
    /**
     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true
     *
     * @param     {Object}    [query]            Optional object with address and/or type.
     * @param     {String}    [query.type]       Does the given type of link exist
     * @param     {String}    [query.address]    Is the given adressed linked
     */

  }, {
    key: "isAddressLinked",
    value: function () {
      var _isAddressLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var query,
            links,
            linksQuery,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                query = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};
                if (query.address) query.address = query.address.toLowerCase();
                _context11.next = 4;
                return this._readAddressLinks();

              case 4:
                links = _context11.sent;
                linksQuery = links.find(function (link) {
                  var res = query.address ? link.address === query.address : true;
                  return query.type ? res && link.type === query.type : res;
                });
                return _context11.abrupt("return", Boolean(linksQuery));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function isAddressLinked() {
        return _isAddressLinked.apply(this, arguments);
      }

      return isAddressLinked;
    }()
  }, {
    key: "isAccountLinked",
    value: function () {
      var _isAccountLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        var type,
            _args12 = arguments;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                type = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('isAccountLinked: deprecated, please use isAddressLinked going forward');
                return _context12.abrupt("return", this.isAddressLinked(type));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function isAccountLinked() {
        return _isAccountLinked.apply(this, arguments);
      }

      return isAccountLinked;
    }()
    /**
     * Lists address links associated with this 3Box
     *
     * @return    {Array}                        An array of link objects
     */

  }, {
    key: "listAddressLinks",
    value: function () {
      var _listAddressLinks = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._readAddressLinks();

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", entries.reduce(function (list, entry) {
                  var item = Object.assign({}, entry);
                  item.linkId = item.entry.hash;
                  delete item.entry;
                  return item;
                }, []));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function listAddressLinks() {
        return _listAddressLinks.apply(this, arguments);
      }

      return listAddressLinks;
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var address, linkData, did, consent;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                address = this._3id.managementAddress;
                _context14.next = 3;
                return this._readAddressLink(address);

              case 3:
                linkData = _context14.sent;

                if (linkData) {
                  _context14.next = 19;
                  break;
                }

                did = this.DID;
                _context14.prev = 6;
                _context14.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context14.sent;
                _context14.next = 16;
                break;

              case 12:
                _context14.prev = 12;
                _context14.t0 = _context14["catch"](6);
                console.log(_context14.t0);
                throw new Error('Link consent message must be signed before adding data, to link address to store');

              case 16:
                linkData = {
                  version: 1,
                  type: ACCOUNT_TYPES.ethereumEOA,
                  message: consent.msg,
                  signature: consent.sig,
                  timestamp: consent.timestamp
                };
                _context14.next = 19;
                return this._writeAddressLink(linkData);

              case 19:
                _context14.next = 21;
                return this["public"].get('proof_did');

              case 21:
                if (_context14.sent) {
                  _context14.next = 29;
                  break;
                }

                _context14.t1 = this["public"];
                _context14.next = 25;
                return this._3id.signJWT();

              case 25:
                _context14.t2 = _context14.sent;
                _context14.t3 = {
                  noLink: true
                };
                _context14.next = 29;
                return _context14.t1.set.call(_context14.t1, 'proof_did', _context14.t2, _context14.t3);

              case 29:
                // Send consentSignature to 3box-address-server to link profile with ethereum address
                utils.fetchJson(this._serverUrl + '/link', linkData)["catch"](console.error);

              case 30:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[6, 12]]);
      }));

      function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      }

      return _linkProfile;
    }()
  }, {
    key: "_writeAddressLink",
    value: function () {
      var _writeAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(proof) {
        var data, linkExist, link;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._ipfs.dag.put(proof);

              case 2:
                data = _context15.sent.toBaseEncodedString();
                _context15.next = 5;
                return this._linkCIDExists(data);

              case 5:
                linkExist = _context15.sent;

                if (!linkExist) {
                  _context15.next = 8;
                  break;
                }

                return _context15.abrupt("return");

              case 8:
                link = {
                  type: 'address-link',
                  data: data
                };
                _context15.next = 11;
                return this._rootStore.add(link);

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _writeAddressLink(_x12) {
        return _writeAddressLink2.apply(this, arguments);
      }

      return _writeAddressLink;
    }()
  }, {
    key: "_linkCIDExists",
    value: function () {
      var _linkCIDExists2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(cid) {
        var entries, linkEntries;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context16.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                return _context16.abrupt("return", linkEntries.find(function (entry) {
                  return entry.data === cid;
                }));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _linkCIDExists(_x13) {
        return _linkCIDExists2.apply(this, arguments);
      }

      return _linkCIDExists;
    }()
  }, {
    key: "_deleteAddressLink",
    value: function () {
      var _deleteAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(address) {
        var link;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                address = address.toLowerCase();
                _context17.next = 3;
                return this._readAddressLink(address);

              case 3:
                link = _context17.sent;

                if (link) {
                  _context17.next = 6;
                  break;
                }

                throw new Error('_deleteAddressLink: link for given address does not exist');

              case 6:
                return _context17.abrupt("return", this._rootStore.remove(link.entry.hash));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _deleteAddressLink(_x14) {
        return _deleteAddressLink2.apply(this, arguments);
      }

      return _deleteAddressLink;
    }()
  }, {
    key: "_readAddressLinks",
    value: function () {
      var _readAddressLinks2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var _this3 = this;

        var entries, linkEntries, resolveLinks;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context19.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                resolveLinks = linkEntries.map(
                /*#__PURE__*/
                function () {
                  var _ref6 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee18(entry) {
                    var obj;
                    return _regenerator["default"].wrap(function _callee18$(_context18) {
                      while (1) {
                        switch (_context18.prev = _context18.next) {
                          case 0:
                            _context18.next = 2;
                            return _this3._ipfs.dag.get(entry.payload.value.data);

                          case 2:
                            obj = _context18.sent.value;

                            if (obj.address) {
                              _context18.next = 7;
                              break;
                            }

                            _context18.next = 6;
                            return utils.recoverPersonalSign(obj.message, obj.signature);

                          case 6:
                            obj.address = _context18.sent;

                          case 7:
                            obj.entry = entry;
                            return _context18.abrupt("return", obj);

                          case 9:
                          case "end":
                            return _context18.stop();
                        }
                      }
                    }, _callee18);
                  }));

                  return function (_x15) {
                    return _ref6.apply(this, arguments);
                  };
                }());
                return _context19.abrupt("return", Promise.all(resolveLinks));

              case 6:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _readAddressLinks() {
        return _readAddressLinks2.apply(this, arguments);
      }

      return _readAddressLinks;
    }()
  }, {
    key: "_readAddressLink",
    value: function () {
      var _readAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee20(address) {
        var links;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                address = address.toLowerCase();
                _context20.next = 3;
                return this._readAddressLinks();

              case 3:
                links = _context20.sent;
                return _context20.abrupt("return", links.find(function (link) {
                  return link.address.toLowerCase() === address;
                }));

              case 5:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _readAddressLink(_x16) {
        return _readAddressLink2.apply(this, arguments);
      }

      return _readAddressLink;
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee21(odbAddress, isThread) {
        var _this4 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context21.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this4.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  if (isThread) {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'SYNC_DB',
                      odbAddress: odbAddress,
                      thread: true
                    });
                  } else {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'PIN_DB',
                      odbAddress: rootStoreAddress
                    });
                  }
                }

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _ensurePinningNodeConnected(_x17, _x18) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      }

      return _ensurePinningNodeConnected;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee22() {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context22.next = 4;
                return this._pubsub.disconnect();

              case 4:
                globalOrbitDB = null;

              case 5:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee23() {
        var address;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.close();

              case 2:
                this._3id.logout();

                address = this._3id.managementAddress;
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }, {
    key: "DID",
    get: function get() {
      return this._3id.muportDID;
    }
  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee24(address) {
        var opts,
            metadata,
            profile,
            normalizedAddress,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};
                metadata = opts.metadata;
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context24.next = 9;
                  break;
                }

                _context24.next = 6;
                return API.getProfile(address, opts.profileServer, {
                  metadata: metadata
                });

              case 6:
                profile = _context24.sent;
                _context24.next = 15;
                break;

              case 9:
                if (!metadata) {
                  _context24.next = 11;
                  break;
                }

                throw new Error('getting metadata is not yet supported outside of the API');

              case 11:
                normalizedAddress = address.toLowerCase();
                _context24.next = 14;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 14:
                profile = _context24.sent;

              case 15:
                return _context24.abrupt("return", profile);

              case 16:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getProfile(_x19) {
        return _getProfile.apply(this, arguments);
      }

      return getProfile;
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee25(addressArray) {
        var opts,
            _args25 = arguments;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                opts = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : {};
                return _context25.abrupt("return", API.getProfiles(addressArray, opts));

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function getProfiles(_x20) {
        return _getProfiles.apply(this, arguments);
      }

      return getProfiles;
    }()
    /**
     * Get the public data in a space of a given address with the given name
     *
     * @param     {String}    address                 An ethereum address
     * @param     {String}    name                    A space name
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the public space data
     */

  }, {
    key: "getSpace",
    value: function () {
      var _getSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee26(address, name) {
        var opts,
            _args26 = arguments;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                opts = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : {};
                return _context26.abrupt("return", API.getSpace(address, name, opts.profileServer, opts));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      }));

      function getSpace(_x21, _x22) {
        return _getSpace.apply(this, arguments);
      }

      return getSpace;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    space                   The name of the space the thread is in
     * @param     {String}    name                    The name of the thread
     * @param     {String}    firstModerator          The DID (or ethereum address) of the first moderator
     * @param     {Boolean}   members                 True if only members are allowed to post
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThread",
    value: function () {
      var _getThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee27(space, name, firstModerator, members) {
        var opts,
            _args27 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                opts = _args27.length > 4 && _args27[4] !== undefined ? _args27[4] : {};
                return _context27.abrupt("return", API.getThread(space, name, firstModerator, members, opts));

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function getThread(_x23, _x24, _x25, _x26) {
        return _getThread.apply(this, arguments);
      }

      return getThread;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    address                 The orbitdb-address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThreadByAddress",
    value: function () {
      var _getThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee28(address) {
        var opts,
            _args28 = arguments;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                opts = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : {};
                return _context28.abrupt("return", API.getThreadByAddress(address, opts));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function getThreadByAddress(_x27) {
        return _getThreadByAddress.apply(this, arguments);
      }

      return getThreadByAddress;
    }()
    /**
     * Get the configuration of a users 3Box
     *
     * @param     {String}    address                 The ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee29(address) {
        var opts,
            _args29 = arguments;
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                opts = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : {};
                return _context29.abrupt("return", API.getConfig(address, opts));

              case 2:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function getConfig(_x28) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Get the names of all spaces a user has
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            an array with all spaces as strings
     */

  }, {
    key: "listSpaces",
    value: function () {
      var _listSpaces = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee30(address) {
        var opts,
            _args30 = arguments;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : {};
                return _context30.abrupt("return", API.listSpaces(address, opts.profileServer));

              case 2:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function listSpaces(_x29) {
        return _listSpaces.apply(this, arguments);
      }

      return listSpaces;
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee32(address) {
        var opts,
            rootStoreAddress,
            usingGlobalIPFS,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args32 = arguments;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                opts = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : {};

                if (!idUtils.isMuportDID(address)) {
                  _context32.next = 3;
                  break;
                }

                throw new Error('DID are supported in the cached version only');

              case 3:
                _context32.next = 5;
                return API.getRootStoreAddress(address.toLowerCase(), opts.addressServer);

              case 5:
                rootStoreAddress = _context32.sent;
                usingGlobalIPFS = false; // let usingGlobalOrbitDB = false

                if (!globalIPFS) {
                  _context32.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context32.next = 15;
                break;

              case 12:
                _context32.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context32.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context32.next = 41;
                  break;
                }

                _context32.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context32.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context32.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context32.next = 30;
                  break;
                }

                _context32.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context32.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context32.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee31() {
                    return _regenerator["default"].wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return rootStore.close();

                          case 2:
                            _context31.next = 4;
                            return publicStore.close();

                          case 4:
                            // if (!usingGlobalOrbitDB) await orbitdb.stop()
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 5:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31);
                  }));

                  return function closeAll() {
                    return _ref7.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context32.abrupt("return", profile);

              case 41:
                return _context32.abrupt("return", null);

              case 42:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32);
      }));

      function _getProfileOrbit(_x30) {
        return _getProfileOrbit2.apply(this, arguments);
      }

      return _getProfileOrbit;
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee33(query) {
        var opts,
            _args33 = arguments;
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                opts = _args33.length > 1 && _args33[1] !== undefined ? _args33[1] : {};
                return _context33.abrupt("return", API.profileGraphQL(query, opts.graphqlServer));

              case 2:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33);
      }));

      function profileGraphQL(_x31) {
        return _profileGraphQL.apply(this, arguments);
      }

      return profileGraphQL;
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee34(profile) {
        return _regenerator["default"].wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                return _context34.abrupt("return", API.getVerifiedAccounts(profile));

              case 1:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34);
      }));

      function getVerifiedAccounts(_x32) {
        return _getVerifiedAccounts.apply(this, arguments);
      }

      return getVerifiedAccounts;
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee35(address, ethereumProvider) {
        var opts,
            ipfs,
            _3id,
            box,
            _args35 = arguments;

        return _regenerator["default"].wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                opts = _args35.length > 2 && _args35[2] !== undefined ? _args35[2] : {};
                _context35.t0 = globalIPFS;

                if (_context35.t0) {
                  _context35.next = 6;
                  break;
                }

                _context35.next = 5;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 5:
                _context35.t0 = _context35.sent;

              case 6:
                ipfs = _context35.t0;
                globalIPFS = ipfs;
                _context35.next = 10;
                return ThreeId.getIdFromEthAddress(address, ethereumProvider, ipfs, opts);

              case 10:
                _3id = _context35.sent;
                box = new Box(_3id, ethereumProvider, ipfs, opts);
                _context35.next = 14;
                return box._load(opts);

              case 14:
                return _context35.abrupt("return", box);

              case 15:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35);
      }));

      function openBox(_x33, _x34) {
        return _openBox.apply(this, arguments);
      }

      return openBox;
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return ThreeId.isLoggedIn(address);
    }
  }]);
  return Box;
}();

function initIPFS(_x35, _x36, _x37) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee36(ipfs, iframeStore, ipfsOptions) {
    return _regenerator["default"].wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context36.next = 5;
              break;
            }

            return _context36.abrupt("return", ipfs);

          case 5:
            return _context36.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));
  return _initIPFS.apply(this, arguments);
}

Box.idUtils = idUtils;
module.exports = Box;
//# sourceMappingURL=node_modules/3box/lib/3box.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/3box.js",}],
[1871, {"./core":1870,"./helpers":1872}, function (require, module, exports) {
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var helpers_1 = require("./helpers");
var core_1 = require("./core");
/* export all core functions and types */
var core_2 = require("./core");
exports.applyOperation = core_2.applyOperation;
exports.applyPatch = core_2.applyPatch;
exports.applyReducer = core_2.applyReducer;
exports.getValueByPointer = core_2.getValueByPointer;
exports.validate = core_2.validate;
exports.validator = core_2.validator;
/* export some helpers */
var helpers_2 = require("./helpers");
exports.JsonPatchError = helpers_2.PatchError;
exports.deepClone = helpers_2._deepClone;
exports.escapePathComponent = helpers_2.escapePathComponent;
exports.unescapePathComponent = helpers_2.unescapePathComponent;
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_1._objectKeys(obj);
    var oldKeys = helpers_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;
/**
 * Default export for backwards compat
 */
// import just to re-export as default
var core = require("./core");
var helpers_3 = require("./helpers");
exports.default = __assign({}, core, { 
    // duplex
    unobserve: unobserve,
    observe: observe,
    generate: generate,
    compare: compare,
    // helpers
    JsonPatchError: helpers_3.PatchError, deepClone: helpers_1._deepClone, escapePathComponent: helpers_1.escapePathComponent,
    unescapePathComponent: helpers_3.unescapePathComponent });

//# sourceMappingURL=node_modules/fast-json-patch/lib/duplex.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/fast-json-patch/lib/duplex.js",}],
[258, {"cids":232}, function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

//# sourceMappingURL=node_modules/@ensdomains/content-hash/src/helpers.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/src/helpers.js",}],
[250, {"./constants":249,"buffer":1428,"multibase":235,"varint":3472,"web-encoding":3476}, function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js",}],
[260, {"buffer":1428,"cids":232,"js-base64":2261,"multihashes":250}, function (require, module, exports) {
(function (Buffer){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/@ensdomains/content-hash/src/profiles.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/src/profiles.js",}],
[244, {"./constants":243,"./int-table":245,"./print":246,"./util":247,"./varint-table":248,"uint8arrays/concat":251,"varint":240}, function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {import('./generated-types').CodecName} CodecName */
/** @typedef {import('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js",}],
[1076, {}, function (require, module, exports) {
module.exports={
  "name": "analytics-node",
  "version": "3.4.0-beta.3",
  "description": "The hassle-free way to integrate analytics into any Node.js application",
  "license": "MIT",
  "repository": "segmentio/analytics-node",
  "author": {
    "name": "Segment",
    "email": "tools+npm@segment.com",
    "url": "https://segment.com"
  },
  "engines": {
    "node": ">=4"
  },
  "size-limit": [
    {
      "limit": "25 KB",
      "path": "index.js"
    }
  ],
  "scripts": {
    "circle-lint": ".buildscript/circle.sh",
    "dependencies": "yarn",
    "size": "size-limit",
    "test": "standard && nyc ava --timeout=20s&& .buildscript/e2e.sh",
    "report-coverage": "nyc report --reporter=lcov > coverage.lcov && codecov",
    "np": "np --no-publish",
    "release": "yarn run np"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "analytics",
    "stats",
    "segment.io",
    "segmentio",
    "segment",
    "client",
    "driver"
  ],
  "dependencies": {
    "@segment/loosely-validate-event": "^2.0.0",
    "axios": "^0.19.2",
    "axios-retry": "^3.0.2",
    "lodash.isstring": "^4.0.1",
    "md5": "^2.2.1",
    "ms": "^2.0.0",
    "remove-trailing-slash": "^0.1.0",
    "uuid": "^3.2.1"
  },
  "devDependencies": {
    "ava": "^0.25.0",
    "basic-auth": "^2.0.1",
    "body-parser": "^1.17.1",
    "codecov": "^3.0.0",
    "commander": "^2.9.0",
    "delay": "^4.2.0",
    "express": "^4.15.2",
    "husky": "^3.0.4",
    "nyc": "^14.1.1",
    "pify": "^4.0.1",
    "sinon": "^7.3.2",
    "size-limit": "^1.3.5",
    "snyk": "^1.171.1",
    "standard": "^12.0.1"
  }
}

//# sourceMappingURL=node_modules/analytics-node/package.json
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/analytics-node/package.json",}],
[3158, {}, function (require, module, exports) {

/**
 * Remove trailing slashes from the given `str`
 *
 * @api public
 * @param {String} str
 * @return {String}
 */
exports = module.exports = function (str) {
  return String(str).replace(exports.expr, '');
};

/**
 * Expose the regex
 *
 * @api private
 * @type {RegExp}
 */
exports.expr = /\/+$/;

//# sourceMappingURL=node_modules/remove-trailing-slash/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/remove-trailing-slash/index.js",}],
[2677, {}, function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

//# sourceMappingURL=node_modules/ms/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ms/index.js",}],
[2504, {}, function (require, module, exports) {
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

//# sourceMappingURL=node_modules/lodash.isstring/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/lodash.isstring/index.js",}],
[2665, {"charenc":1444,"crypt":1477,"is-buffer":2235}, function (require, module, exports) {
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      isBuffer = require('is-buffer'),
      bin = require('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

//# sourceMappingURL=node_modules/md5/md5.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/md5/md5.js",}],
[991, {"assert":1095,"buffer":1428,"component-type":1465,"join-component":2260}, function (require, module, exports) {
(function (Buffer){
var type = require('component-type')
var join = require('join-component')
var assert = require('assert')

// Segment messages can be a maximum of 32kb.
var MAX_SIZE = 32 << 10

module.exports = looselyValidateEvent

/**
 * Validate an event.
 */

function looselyValidateEvent (event, type) {
  validateGenericEvent(event)
  type = type || event.type
  assert(type, 'You must pass an event type.')
  switch (type) {
    case 'track':
      return validateTrackEvent(event)
    case 'group':
      return validateGroupEvent(event)
    case 'identify':
      return validateIdentifyEvent(event)
    case 'page':
      return validatePageEvent(event)
    case 'screen':
      return validateScreenEvent(event)
    case 'alias':
      return validateAliasEvent(event)
    default:
      assert(0, 'Invalid event type: "' + type + '"')
  }
}

/**
 * Validate a "track" event.
 */

function validateTrackEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.event, 'You must pass an "event".')
}

/**
 * Validate a "group" event.
 */

function validateGroupEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.groupId, 'You must pass a "groupId".')
}

/**
 * Validate a "identify" event.
 */

function validateIdentifyEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "page" event.
 */

function validatePageEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "screen" event.
 */

function validateScreenEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate an "alias" event.
 */

function validateAliasEvent (event) {
  assert(event.userId, 'You must pass a "userId".')
  assert(event.previousId, 'You must pass a "previousId".')
}

/**
 * Validation rules.
 */

var genericValidationRules = {
  anonymousId: [ 'string', 'number' ],
  category: 'string',
  context: 'object',
  event: 'string',
  groupId: [ 'string', 'number' ],
  integrations: 'object',
  name: 'string',
  previousId: [ 'string', 'number' ],
  timestamp: 'date',
  userId: [ 'string', 'number' ],
  type: 'string'
}

/**
 * Validate an event object.
 */

function validateGenericEvent (event) {
  assert(type(event) === 'object', 'You must pass a message object.')
  var json = JSON.stringify(event)
  // Strings are variable byte encoded, so json.length is not sufficient.
  assert(Buffer.byteLength(json, 'utf8') < MAX_SIZE, 'Your message must be < 32kb.')

  for (var key in genericValidationRules) {
    var val = event[key]
    if (!val) continue
    var rule = genericValidationRules[key]
    if (type(rule) !== 'array') {
      rule = [ rule ]
    }
    var a = rule[0] === 'object' ? 'an' : 'a'
    assert(
      rule.some(function (e) { return type(val) === e }),
      '"' + key + '" must be ' + a + ' ' + join(rule, 'or') + '.'
    )
  }
}

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/@segment/loosely-validate-event/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@segment/loosely-validate-event/index.js",}],
[1176, {"./lib/index":1177}, function (require, module, exports) {
module.exports = require('./lib/index').default;
//# sourceMappingURL=node_modules/axios-retry/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/axios-retry/index.js",}],
[1178, {"./lib/axios":1180}, function (require, module, exports) {
module.exports = require('./lib/axios');
//# sourceMappingURL=node_modules/axios/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/axios/index.js",}],
[1822, {"./account":1818,"./bytes":1819,"./constants":1820,"./hash":1821,"./object":1823,"./secp256k1v3-adapter":1824,"./signature":1827,"bn.js":1385,"ethjs-util":1828,"rlp":3166}, function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js",}],
[1817, {}, function (require, module, exports) {
/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
(function(root) {
    "use strict";

    function checkInt(value) {
        return (parseInt(value) === value);
    }

    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) { return false; }

        for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }

        return true;
    }

    function coerceArray(arg, copy) {

        // ArrayBuffer view
        if (arg.buffer && arg.name === 'Uint8Array') {

            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }

            return arg;
        }

        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
        }

        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }

        throw new Error('unsupported array-like object');
    }

    function createArray(length) {
        return new Uint8Array(length);
    }

    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }



    var convertUtf8 = (function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while (i < text.length) {
                var c = text.charCodeAt(i++);

                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16))
                    i += 2;

                // otherwise, just the actual byte
                } else {
                    result.push(c)
                }
            }

            return coerceArray(result);
        }

        function fromBytes(bytes) {
            var result = [], i = 0;

            while (i < bytes.length) {
                var c = bytes[i];

                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                    i += 2;
                } else {
                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                    i += 3;
                }
            }

            return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();

    var convertHex = (function() {
        function toBytes(text) {
            var result = [];
            for (var i = 0; i < text.length; i += 2) {
                result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
        }

        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';

        function fromBytes(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i++) {
                    var v = bytes[i];
                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                }
                return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();


    // Number of rounds by keysize
    var numberOfRounds = {16: 10, 24: 12, 32: 14}

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

    function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
            result.push(
                (bytes[i    ] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] <<  8) |
                 bytes[i + 3]
            );
        }
        return result;
    }

    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }

        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });

        this._prepare();
    }


    AES.prototype._prepare = function() {

        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }

        // encryption round keys
        this._Ke = [];

        // decryption round keys
        this._Kd = [];

        for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
        }

        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;

        // convert the key into ints
        var tk = convertToInt32(this.key);

        // copy values into round key arrays
        var index;
        for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }

        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                      (S[(tt >>  8) & 0xFF] << 16) ^
                      (S[ tt        & 0xFF] <<  8) ^
                       S[(tt >> 24) & 0xFF]        ^
                      (rcon[rconpointer] << 24));
            rconpointer += 1;

            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (var i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }

            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for (var i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];

                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                              (S[(tt >>  8) & 0xFF] <<  8) ^
                              (S[(tt >> 16) & 0xFF] << 16) ^
                              (S[(tt >> 24) & 0xFF] << 24));

                for (var i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }

            // copy values into round key arrays
            var i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }

        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
                tt = this._Kd[r][c];
                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                                  U2[(tt >> 16) & 0xFF] ^
                                  U3[(tt >>  8) & 0xFF] ^
                                  U4[ tt        & 0xFF]);
            }
        }
    }

    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }

        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T4[ t[(i + 3) % 4]        & 0xff] ^
                        this._Ke[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }

    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }

        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T8[ t[(i + 1) % 4]        & 0xff] ^
                        this._Kd[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }


    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Electronic Code Block";
        this.name = "ecb";

        this._aes = new AES(key);
    }

    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Block Chaining";
        this.name = "cbc";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastCipherblock = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
                block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Feedback";
        this.name = "cfb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }

        if (!segmentSize) { segmentSize = 1; }

        this.segmentSize = segmentSize;

        this._shiftRegister = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if ((plaintext.length % this.segmentSize) != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }

        var encrypted = coerceArray(plaintext, true);

        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j = 0; j < this.segmentSize; j++) {
                encrypted[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return encrypted;
    }

    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if ((ciphertext.length % this.segmentSize) != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }

        var plaintext = coerceArray(ciphertext, true);

        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return plaintext;
    }

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Output Feedback";
        this.name = "ofb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }

        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

        if (typeof(initialValue) === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);

        } else {
            this.setBytes(initialValue);
        }
    }

    Counter.prototype.setValue = function(value) {
        if (typeof(value) !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }

        // We cannot safely handle numbers beyond the safe range for integers
        if (value > Number.MAX_SAFE_INTEGER) {
            throw new Error('integer value out of safe range');
        }

        for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = parseInt(value / 256);
        }
    }

    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);

        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }

        this._counter = bytes;
    };

    Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    }


    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Counter";
        this.name = "ctr";

        if (!(counter instanceof Counter)) {
            counter = new Counter(counter)
        }

        this._counter = counter;

        this._remainingCounter = null;
        this._remainingCounterIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - (data.length % 16);
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
        }
        return result;
    }

    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

        var padder = data[data.length - 1];
        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }

        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }

    ///////////////////////
    // Exporting


    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,

        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },

        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },

        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },

        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray,
        }
    };


    // node.js
    if (typeof exports !== 'undefined') {
        module.exports = aesjs

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else if (typeof(define) === 'function' && define.amd) {
        define([], function() { return aesjs; });

    // Web Browsers
    } else {

        // If there was an existing library at "aesjs" make sure it's still available
        if (root.aesjs) {
            aesjs._aesjs = root.aesjs;
        }

        root.aesjs = aesjs;
    }


})(this);

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/aes-js/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/aes-js/index.js",}],
[3252, {"buffer":1428,"pbkdf2":2876}, function (require, module, exports) {
(function (Buffer){
var pbkdf2Sync = require('pbkdf2').pbkdf2Sync

var MAX_VALUE = 0x7fffffff

// N = Cpu cost, r = Memory cost, p = parallelization cost
function scrypt (key, salt, N, r, p, dkLen, progressCallback) {
  if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

  if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
  if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

  var XY = new Buffer(256 * r)
  var V = new Buffer(128 * r * N)

  // pseudo global
  var B32 = new Int32Array(16) // salsa20_8
  var x = new Int32Array(16) // salsa20_8
  var _X = new Buffer(64) // blockmix_salsa8

  // pseudo global
  var B = pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')

  var tickCallback
  if (progressCallback) {
    var totalOps = p * N * 2
    var currentOp = 0

    tickCallback = function () {
      ++currentOp

      // send progress notifications once every 1,000 ops
      if (currentOp % 1000 === 0) {
        progressCallback({
          current: currentOp,
          total: totalOps,
          percent: (currentOp / totalOps) * 100.0
        })
      }
    }
  }

  for (var i = 0; i < p; i++) {
    smix(B, i * 128 * r, r, N, V, XY)
  }

  return pbkdf2Sync(key, B, 1, dkLen, 'sha256')

  // all of these functions are actually moved to the top
  // due to function hoisting

  function smix (B, Bi, r, N, V, XY) {
    var Xi = 0
    var Yi = 128 * r
    var i

    B.copy(XY, Xi, Bi, Bi + Yi)

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    for (i = 0; i < N; i++) {
      var offset = Xi + (2 * r - 1) * 64
      var j = XY.readUInt32LE(offset) & (N - 1)
      blockxor(V, j * Yi, XY, Xi, Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    XY.copy(B, Bi, Xi, Xi + Yi)
  }

  function blockmix_salsa8 (BY, Bi, Yi, r) {
    var i

    arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64)
      salsa20_8(_X)
      arraycopy(_X, 0, BY, Yi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)
    }
  }

  function R (a, b) {
    return (a << b) | (a >>> (32 - b))
  }

  function salsa20_8 (B) {
    var i

    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 0xff) << 0
      B32[i] |= (B[i * 4 + 1] & 0xff) << 8
      B32[i] |= (B[i * 4 + 2] & 0xff) << 16
      B32[i] |= (B[i * 4 + 3] & 0xff) << 24
      // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
    }

    arraycopy(B32, 0, x, 0, 16)

    for (i = 8; i > 0; i -= 2) {
      x[ 4] ^= R(x[ 0] + x[12], 7)
      x[ 8] ^= R(x[ 4] + x[ 0], 9)
      x[12] ^= R(x[ 8] + x[ 4], 13)
      x[ 0] ^= R(x[12] + x[ 8], 18)
      x[ 9] ^= R(x[ 5] + x[ 1], 7)
      x[13] ^= R(x[ 9] + x[ 5], 9)
      x[ 1] ^= R(x[13] + x[ 9], 13)
      x[ 5] ^= R(x[ 1] + x[13], 18)
      x[14] ^= R(x[10] + x[ 6], 7)
      x[ 2] ^= R(x[14] + x[10], 9)
      x[ 6] ^= R(x[ 2] + x[14], 13)
      x[10] ^= R(x[ 6] + x[ 2], 18)
      x[ 3] ^= R(x[15] + x[11], 7)
      x[ 7] ^= R(x[ 3] + x[15], 9)
      x[11] ^= R(x[ 7] + x[ 3], 13)
      x[15] ^= R(x[11] + x[ 7], 18)
      x[ 1] ^= R(x[ 0] + x[ 3], 7)
      x[ 2] ^= R(x[ 1] + x[ 0], 9)
      x[ 3] ^= R(x[ 2] + x[ 1], 13)
      x[ 0] ^= R(x[ 3] + x[ 2], 18)
      x[ 6] ^= R(x[ 5] + x[ 4], 7)
      x[ 7] ^= R(x[ 6] + x[ 5], 9)
      x[ 4] ^= R(x[ 7] + x[ 6], 13)
      x[ 5] ^= R(x[ 4] + x[ 7], 18)
      x[11] ^= R(x[10] + x[ 9], 7)
      x[ 8] ^= R(x[11] + x[10], 9)
      x[ 9] ^= R(x[ 8] + x[11], 13)
      x[10] ^= R(x[ 9] + x[ 8], 18)
      x[12] ^= R(x[15] + x[14], 7)
      x[13] ^= R(x[12] + x[15], 9)
      x[14] ^= R(x[13] + x[12], 13)
      x[15] ^= R(x[14] + x[13], 18)
    }

    for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]

    for (i = 0; i < 16; i++) {
      var bi = i * 4
      B[bi + 0] = (B32[i] >> 0 & 0xff)
      B[bi + 1] = (B32[i] >> 8 & 0xff)
      B[bi + 2] = (B32[i] >> 16 & 0xff)
      B[bi + 3] = (B32[i] >> 24 & 0xff)
      // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor (S, Si, D, Di, len) {
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i]
    }
  }
}

function arraycopy (src, srcPos, dest, destPos, length) {
  if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
    src.copy(dest, destPos, srcPos, srcPos + length)
  } else {
    while (length--) {
      dest[destPos++] = src[srcPos++]
    }
  }
}

module.exports = scrypt

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/scryptsy/lib/scrypt.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/scryptsy/lib/scrypt.js",}],
[3380, {"./createEventEmitterProxy":3378,"./createSwappableProxy":3379}, function (require, module, exports) {
const createSwappableProxy = require('./createSwappableProxy')
const createEventEmitterProxy = require('./createEventEmitterProxy')

module.exports = {
  createSwappableProxy,
  createEventEmitterProxy,
}

//# sourceMappingURL=node_modules/swappable-obj-proxy/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/swappable-obj-proxy/src/index.js",}],
[16, {"../../../../shared/constants/time":3598,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"eth-block-tracker":1665,"eth-json-rpc-middleware/block-cache":1694,"eth-json-rpc-middleware/block-ref-rewrite":1695,"eth-json-rpc-middleware/block-tracker-inspector":1697,"eth-json-rpc-middleware/fetch":1699,"eth-json-rpc-middleware/inflight-cache":1700,"eth-json-rpc-middleware/providerFromMiddleware":1734,"json-rpc-engine":2274}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createJsonRpcClient;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _jsonRpcEngine = require("json-rpc-engine");

var _fetch = _interopRequireDefault(require("eth-json-rpc-middleware/fetch"));

var _blockRefRewrite = _interopRequireDefault(require("eth-json-rpc-middleware/block-ref-rewrite"));

var _blockCache = _interopRequireDefault(require("eth-json-rpc-middleware/block-cache"));

var _inflightCache = _interopRequireDefault(require("eth-json-rpc-middleware/inflight-cache"));

var _blockTrackerInspector = _interopRequireDefault(require("eth-json-rpc-middleware/block-tracker-inspector"));

var _providerFromMiddleware = _interopRequireDefault(require("eth-json-rpc-middleware/providerFromMiddleware"));

var _ethBlockTracker = require("eth-block-tracker");

var _time = require("../../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const inTest = false === 'true';
const blockTrackerOpts = inTest ? {
  pollingInterval: _time.SECOND
} : {};

const getTestMiddlewares = () => {
  return inTest ? [createEstimateGasDelayTestMiddleware()] : [];
};

function createJsonRpcClient({
  rpcUrl,
  chainId
}) {
  const fetchMiddleware = (0, _fetch.default)({
    rpcUrl
  });
  const blockProvider = (0, _providerFromMiddleware.default)(fetchMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker(_objectSpread(_objectSpread({}, blockTrackerOpts), {}, {
    provider: blockProvider
  }));
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([...getTestMiddlewares(), createChainIdMiddleware(chainId), (0, _blockRefRewrite.default)({
    blockTracker
  }), (0, _blockCache.default)({
    blockTracker
  }), (0, _inflightCache.default)(), (0, _blockTrackerInspector.default)({
    blockTracker
  }), fetchMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === 'eth_chainId') {
      res.result = chainId;
      return end();
    }

    return next();
  };
}
/**
 * For use in tests only.
 * Adds a delay to `eth_estimateGas` calls.
 */


function createEstimateGasDelayTestMiddleware() {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, _, next) => {
    if (req.method === 'eth_estimateGas') {
      await new Promise(resolve => setTimeout(resolve, _time.SECOND * 2));
    }

    return next();
  });
}

//# sourceMappingURL=app/scripts/controllers/network/createJsonRpcClient.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/createJsonRpcClient.js",}],
[15, {"../../../../shared/constants/network":3595,"@babel/runtime/helpers/interopRequireDefault":186,"eth-block-tracker":1665,"eth-json-rpc-infura":1693,"eth-json-rpc-middleware/block-cache":1694,"eth-json-rpc-middleware/block-ref":1696,"eth-json-rpc-middleware/block-tracker-inspector":1697,"eth-json-rpc-middleware/inflight-cache":1700,"eth-json-rpc-middleware/providerFromMiddleware":1734,"eth-json-rpc-middleware/retryOnEmpty":1735,"json-rpc-engine":2274}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createInfuraClient;

var _jsonRpcEngine = require("json-rpc-engine");

var _blockRef = _interopRequireDefault(require("eth-json-rpc-middleware/block-ref"));

var _retryOnEmpty = _interopRequireDefault(require("eth-json-rpc-middleware/retryOnEmpty"));

var _blockCache = _interopRequireDefault(require("eth-json-rpc-middleware/block-cache"));

var _inflightCache = _interopRequireDefault(require("eth-json-rpc-middleware/inflight-cache"));

var _blockTrackerInspector = _interopRequireDefault(require("eth-json-rpc-middleware/block-tracker-inspector"));

var _providerFromMiddleware = _interopRequireDefault(require("eth-json-rpc-middleware/providerFromMiddleware"));

var _ethJsonRpcInfura = _interopRequireDefault(require("eth-json-rpc-infura"));

var _ethBlockTracker = require("eth-block-tracker");

var _network = require("../../../../shared/constants/network");

function createInfuraClient({
  network,
  projectId
}) {
  const infuraMiddleware = (0, _ethJsonRpcInfura.default)({
    network,
    projectId,
    maxAttempts: 5,
    source: 'metamask'
  });
  const infuraProvider = (0, _providerFromMiddleware.default)(infuraMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker({
    provider: infuraProvider
  });
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([createNetworkAndChainIdMiddleware({
    network
  }), (0, _blockCache.default)({
    blockTracker
  }), (0, _inflightCache.default)(), (0, _blockRef.default)({
    blockTracker,
    provider: infuraProvider
  }), (0, _retryOnEmpty.default)({
    blockTracker,
    provider: infuraProvider
  }), (0, _blockTrackerInspector.default)({
    blockTracker
  }), infuraMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createNetworkAndChainIdMiddleware({
  network
}) {
  if (!_network.NETWORK_TYPE_TO_ID_MAP[network]) {
    throw new Error(`createInfuraClient - unknown network "${network}"`);
  }

  const {
    chainId,
    networkId
  } = _network.NETWORK_TYPE_TO_ID_MAP[network];
  return (0, _jsonRpcEngine.createScaffoldMiddleware)({
    eth_chainId: chainId,
    net_version: networkId
  });
}

//# sourceMappingURL=app/scripts/controllers/network/createInfuraClient.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/createInfuraClient.js",}],
[68, {"./add-ethereum-chain":66,"./get-provider-state":67,"./log-web3-shim-usage":69,"./switch-ethereum-chain":70,"./watch-asset":71,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _addEthereumChain = _interopRequireDefault(require("./add-ethereum-chain"));

var _switchEthereumChain = _interopRequireDefault(require("./switch-ethereum-chain"));

var _getProviderState = _interopRequireDefault(require("./get-provider-state"));

var _logWeb3ShimUsage = _interopRequireDefault(require("./log-web3-shim-usage"));

var _watchAsset = _interopRequireDefault(require("./watch-asset"));

const handlers = [_addEthereumChain.default, _switchEthereumChain.default, _getProviderState.default, _logWeb3ShimUsage.default, _watchAsset.default];
var _default = handlers;
exports.default = _default;

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/index.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/index.js",}],
[1452, {"bs58":1453,"buffer":1428,"create-hash":1473}, function (require, module, exports) {
(function (Buffer){
var base58 = require('bs58')
var createHash = require('create-hash')

function encode (payload, version) {
  if (Array.isArray(payload) || payload instanceof Uint8Array) {
    payload = new Buffer(payload)
  }

  var buf
  if (version != null) {
    if (typeof version === 'number') {
      version = new Buffer([version])
    }
    buf = Buffer.concat([version, payload])
  } else {
    buf = payload
  }

  var checksum = sha256x2(buf).slice(0, 4)
  var result = Buffer.concat([buf, checksum])
  return base58.encode(result)
}

function decode (base58str, version) {
  var arr = base58.decode(base58str)
  var buf = new Buffer(arr)
  var versionLength

  if (version == null) {
    versionLength = 0
  } else {
    if (typeof version === 'number') version = new Buffer([version])

    versionLength = version.length
    var versionCompare = buf.slice(0, versionLength)
    if (versionCompare.toString('hex') !== version.toString('hex')) {
      throw new Error('Invalid version')
    }
  }

  var checksum = buf.slice(-4)
  var endPos = buf.length - 4
  var bytes = buf.slice(0, endPos)

  var newChecksum = sha256x2(bytes).slice(0, 4)
  if (checksum.toString('hex') !== newChecksum.toString('hex')) {
    throw new Error('Invalid checksum')
  }

  return bytes.slice(versionLength)
}

function isValid (base58str, version) {
  try {
    decode(base58str, version)
  } catch (e) {
    return false
  }

  return true
}

function createEncoder (version) {
  return function (payload) {
    return encode(payload, version)
  }
}

function createDecoder (version) {
  return function (base58str) {
    return decode(base58str, version)
  }
}

function createValidator (version) {
  return function (base58str) {
    return isValid(base58str, version)
  }
}

function sha256x2 (buffer) {
  var sha = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(sha).digest()
}

module.exports = {
  encode: encode,
  decode: decode,
  isValid: isValid,
  createEncoder: createEncoder,
  createDecoder: createDecoder,
  createValidator: createValidator
}

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/coinstring/lib/coinstring.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/coinstring/lib/coinstring.js",}],
[937, {"assert":1095,"bn.js":1385,"create-hash":1473,"ethjs-util":938,"keccak":939,"rlp":3166,"safe-buffer":3237,"secp256k1":3253}, function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
//# sourceMappingURL=node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js",}],
[3418, {"./account":3413,"./api":3414,"./backend/blockchain":3415,"./backend/transactions":3416,"./events":3417,"./misc":3419,"./networks/binance":3420,"./networks/bitcoin":3421,"./networks/cardano":3422,"./networks/coinInfo":3423,"./networks/eos":3424,"./networks/ethereum":3425,"./networks/lisk":3426,"./networks/nem":3427,"./networks/ripple":3428,"./networks/stellar":3429,"./networks/tezos":3430,"./params":3431,"./trezor/device":3432,"./trezor/management":3433}, function (require, module, exports) {
"use strict";

exports.__esModule = true;

var _api = require("./api");

Object.keys(_api).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _api[key]) return;
  exports[key] = _api[key];
});

var _events = require("./events");

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _events[key]) return;
  exports[key] = _events[key];
});

var _misc = require("./misc");

Object.keys(_misc).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _misc[key]) return;
  exports[key] = _misc[key];
});

var _params = require("./params");

Object.keys(_params).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _params[key]) return;
  exports[key] = _params[key];
});

var _account = require("./account");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _account[key]) return;
  exports[key] = _account[key];
});

var _device = require("./trezor/device");

Object.keys(_device).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _device[key]) return;
  exports[key] = _device[key];
});

var _management = require("./trezor/management");

Object.keys(_management).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _management[key]) return;
  exports[key] = _management[key];
});

var _bitcoin = require("./networks/bitcoin");

Object.keys(_bitcoin).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bitcoin[key]) return;
  exports[key] = _bitcoin[key];
});

var _binance = require("./networks/binance");

Object.keys(_binance).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _binance[key]) return;
  exports[key] = _binance[key];
});

var _cardano = require("./networks/cardano");

Object.keys(_cardano).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cardano[key]) return;
  exports[key] = _cardano[key];
});

var _coinInfo = require("./networks/coinInfo");

Object.keys(_coinInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _coinInfo[key]) return;
  exports[key] = _coinInfo[key];
});

var _eos = require("./networks/eos");

Object.keys(_eos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eos[key]) return;
  exports[key] = _eos[key];
});

var _ethereum = require("./networks/ethereum");

Object.keys(_ethereum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ethereum[key]) return;
  exports[key] = _ethereum[key];
});

var _lisk = require("./networks/lisk");

Object.keys(_lisk).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _lisk[key]) return;
  exports[key] = _lisk[key];
});

var _nem = require("./networks/nem");

Object.keys(_nem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nem[key]) return;
  exports[key] = _nem[key];
});

var _ripple = require("./networks/ripple");

Object.keys(_ripple).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ripple[key]) return;
  exports[key] = _ripple[key];
});

var _stellar = require("./networks/stellar");

Object.keys(_stellar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stellar[key]) return;
  exports[key] = _stellar[key];
});

var _tezos = require("./networks/tezos");

Object.keys(_tezos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _tezos[key]) return;
  exports[key] = _tezos[key];
});

var _blockchain = require("./backend/blockchain");

Object.keys(_blockchain).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _blockchain[key]) return;
  exports[key] = _blockchain[key];
});

var _transactions = require("./backend/transactions");

Object.keys(_transactions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactions[key]) return;
  exports[key] = _transactions[key];
});
//# sourceMappingURL=node_modules/trezor-connect/lib/types/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/index.js",}],
[3398, {"./blockchain":3393,"./cardano":3394,"./device":3395,"./errors":3396,"./iframe":3397,"./network":3399,"./popup":3400,"./transport":3401,"./ui":3402,"@babel/runtime/helpers/interopRequireWildcard":187}, function (require, module, exports) {
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.__esModule = true;
exports.CARDANO = exports.UI = exports.TRANSPORT = exports.POPUP = exports.NETWORK = exports.IFRAME = exports.ERRORS = exports.DEVICE = exports.BLOCKCHAIN = exports.BLOCKCHAIN_EVENT = exports.RESPONSE_EVENT = exports.TRANSPORT_EVENT = exports.DEVICE_EVENT = exports.UI_EVENT = exports.CORE_EVENT = void 0;

var BLOCKCHAIN = _interopRequireWildcard(require("./blockchain"));

exports.BLOCKCHAIN = BLOCKCHAIN;

var DEVICE = _interopRequireWildcard(require("./device"));

exports.DEVICE = DEVICE;

var ERRORS = _interopRequireWildcard(require("./errors"));

exports.ERRORS = ERRORS;

var IFRAME = _interopRequireWildcard(require("./iframe"));

exports.IFRAME = IFRAME;

var NETWORK = _interopRequireWildcard(require("./network"));

exports.NETWORK = NETWORK;

var POPUP = _interopRequireWildcard(require("./popup"));

exports.POPUP = POPUP;

var TRANSPORT = _interopRequireWildcard(require("./transport"));

exports.TRANSPORT = TRANSPORT;

var UI = _interopRequireWildcard(require("./ui"));

exports.UI = UI;

var CARDANO = _interopRequireWildcard(require("./cardano"));

exports.CARDANO = CARDANO;
var CORE_EVENT = 'CORE_EVENT';
exports.CORE_EVENT = CORE_EVENT;
var UI_EVENT = 'UI_EVENT';
exports.UI_EVENT = UI_EVENT;
var DEVICE_EVENT = 'DEVICE_EVENT';
exports.DEVICE_EVENT = DEVICE_EVENT;
var TRANSPORT_EVENT = 'TRANSPORT_EVENT';
exports.TRANSPORT_EVENT = TRANSPORT_EVENT;
var RESPONSE_EVENT = 'RESPONSE_EVENT';
exports.RESPONSE_EVENT = RESPONSE_EVENT;
var BLOCKCHAIN_EVENT = 'BLOCKCHAIN_EVENT';
exports.BLOCKCHAIN_EVENT = BLOCKCHAIN_EVENT;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/index.js",}],
[3404, {"../../constants":3398,"../../data/ConnectSettings":3403,"../../iframe/builder":3406,"../../message":3410,"../../message/builder":3409,"../../popup/PopupManager":3411,"../../types":3418,"../../utils/debug":3435,"../../webusb/button":3437,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/interopRequireWildcard":187,"@babel/runtime/regenerator":206,"events":1429}, function (require, module, exports) {
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.disableWebUSB = exports.requestLogin = exports.customMessage = exports.getSettings = exports.renderWebUSBButton = exports.uiResponse = exports.call = exports.init = exports.cancel = exports.dispose = exports.manifest = exports.eventEmitter = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _events = _interopRequireDefault(require("events"));

var _PopupManager = _interopRequireDefault(require("../../popup/PopupManager"));

var iframe = _interopRequireWildcard(require("../../iframe/builder"));

var _button = _interopRequireDefault(require("../../webusb/button"));

var _message = require("../../message");

var _builder2 = require("../../message/builder");

var _ConnectSettings = require("../../data/ConnectSettings");

var _debug = _interopRequireWildcard(require("../../utils/debug"));

var _constants = require("../../constants");

var $T = _interopRequireWildcard(require("../../types"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var eventEmitter = new _events["default"]();
exports.eventEmitter = eventEmitter;

var _log = (0, _debug.init)('[trezor-connect.js]');

var _settings;

var _popupManager;

var initPopupManager = function initPopupManager() {
  var pm = new _PopupManager["default"](_settings);
  pm.on(_constants.POPUP.CLOSED, function (error) {
    iframe.postMessage({
      type: _constants.POPUP.CLOSED,
      payload: error ? {
        error: error
      } : null
    }, false);
  });
  return pm;
};

var manifest = function manifest(data) {
  _settings = (0, _ConnectSettings.parse)({
    manifest: data
  });
};

exports.manifest = manifest;

var dispose = function dispose() {
  iframe.dispose();

  if (_popupManager) {
    _popupManager.close();
  }
};

exports.dispose = dispose;

var cancel = function cancel(error) {
  if (_popupManager) {
    _popupManager.emit(_constants.POPUP.CLOSED, error);
  }
}; // handle message received from iframe


exports.cancel = cancel;

var handleMessage = function handleMessage(messageEvent) {
  // ignore messages from domain other then iframe origin
  if (messageEvent.origin !== iframe.origin) return;
  var message = (0, _message.parseMessage)(messageEvent.data);
  var event = message.event,
      type = message.type,
      payload = message.payload;
  var id = message.id || 0;

  _log.log('handleMessage', message);

  switch (event) {
    case _constants.RESPONSE_EVENT:
      if (iframe.messagePromises[id]) {
        // resolve message promise (send result of call method)
        iframe.messagePromises[id].resolve({
          id: id,
          success: message.success,
          payload: payload
        });
        delete iframe.messagePromises[id];
      } else {
        _log.warn("Unknown message id " + id);
      }

      break;

    case _constants.DEVICE_EVENT:
      // pass DEVICE event up to html
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload); // DEVICE_EVENT also emit single events (connect/disconnect...)

      break;

    case _constants.TRANSPORT_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.BLOCKCHAIN_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.UI_EVENT:
      if (type === _constants.IFRAME.BOOTSTRAP) {
        iframe.clearTimeout();
        break;
      }

      if (type === _constants.IFRAME.LOADED) {
        iframe.initPromise.resolve();
      }

      if (type === _constants.IFRAME.ERROR) {
        iframe.initPromise.reject(payload.error);
      } // pass UI event up


      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    default:
      _log.log('Undefined message', event, messageEvent);

  }
};

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (settings === void 0) {
              settings = {};
            }

            if (!iframe.instance) {
              _context.next = 3;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_AlreadyInitialized');

          case 3:
            if (!_settings) {
              _settings = (0, _ConnectSettings.parse)(settings);
            }

            if (_settings.manifest) {
              _context.next = 6;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_ManifestMissing');

          case 6:
            if (!_settings.lazyLoad) {
              _context.next = 9;
              break;
            }

            // reset "lazyLoad" after first use
            _settings.lazyLoad = false;
            return _context.abrupt("return");

          case 9:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _log.enabled = !!_settings.debug;
            window.addEventListener('message', handleMessage);
            window.addEventListener('unload', dispose);
            _context.next = 15;
            return iframe.init(_settings);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var call = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
    var response;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!iframe.instance && !iframe.timeout)) {
              _context2.next = 15;
              break;
            }

            // init popup with lazy loading before iframe initialization
            _settings = (0, _ConnectSettings.parse)(_settings);

            if (_settings.manifest) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 4:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _popupManager.request(true); // auto init with default settings


            _context2.prev = 6;
            _context2.next = 9;
            return init(_settings);

          case 9:
            _context2.next = 15;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](6);

            if (_popupManager) {
              // Catch fatal iframe errors (not loading)
              if (['Init_IframeBlocked', 'Init_IframeTimeout'].includes(_context2.t0.code)) {
                _popupManager.postMessage((0, _builder2.UiMessage)(_constants.UI.IFRAME_FAILURE));
              } else {
                _popupManager.close();
              }
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t0));

          case 15:
            if (!iframe.timeout) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 19:
            if (!iframe.error) {
              _context2.next = 21;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(iframe.error));

          case 21:
            // request popup window it might be used in the future
            if (_settings.popup && _popupManager) {
              _popupManager.request();
            } // post message to iframe


            _context2.prev = 22;
            _context2.next = 25;
            return iframe.postMessage({
              type: _constants.IFRAME.CALL,
              payload: params
            });

          case 25:
            response = _context2.sent;

            if (!response) {
              _context2.next = 31;
              break;
            }

            if (!response.success && response.payload.error.code !== 'Device_CallInProgress' && _popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", response);

          case 31:
            if (_popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_NoResponse')));

          case 33:
            _context2.next = 40;
            break;

          case 35:
            _context2.prev = 35;
            _context2.t1 = _context2["catch"](22);

            _log.error('__call error', _context2.t1);

            if (_popupManager) {
              _popupManager.close();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t1));

          case 40:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[6, 11], [22, 35]]);
  }));

  return function call(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports.call = call;

var customMessageResponse = function customMessageResponse(payload) {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.UI.CUSTOM_MESSAGE_RESPONSE,
    payload: payload
  });
};

var uiResponse = function uiResponse(response) {
  var type = response.type,
      payload = response.payload;
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  });
};

exports.uiResponse = uiResponse;

var renderWebUSBButton = function renderWebUSBButton(className) {
  (0, _button["default"])(className, _settings.webusbSrc, iframe.origin);
};

exports.renderWebUSBButton = renderWebUSBButton;

var getSettings = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (iframe.instance) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_NotInitialized')));

          case 2:
            _context3.next = 4;
            return call({
              method: 'getSettings'
            });

          case 4:
            return _context3.abrupt("return", _context3.sent);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function getSettings() {
    return _ref3.apply(this, arguments);
  };
}();

exports.getSettings = getSettings;

var customMessage = /*#__PURE__*/function () {
  var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(params) {
    var callback, customMessageListener, response;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(typeof params.callback !== 'function')) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_CustomMessage_Callback')));

          case 2:
            // TODO: set message listener only if iframe is loaded correctly
            callback = params.callback;

            customMessageListener = /*#__PURE__*/function () {
              var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.CUSTOM_MESSAGE_REQUEST)) {
                          _context4.next = 6;
                          break;
                        }

                        _context4.next = 4;
                        return callback(data.payload);

                      case 4:
                        payload = _context4.sent;

                        if (payload) {
                          customMessageResponse(payload);
                        } else {
                          customMessageResponse({
                            message: 'release'
                          });
                        }

                      case 6:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function customMessageListener(_x4) {
                return _ref5.apply(this, arguments);
              };
            }();

            window.addEventListener('message', customMessageListener, false);
            _context5.next = 7;
            return call(_objectSpread(_objectSpread({
              method: 'customMessage'
            }, params), {}, {
              callback: null
            }));

          case 7:
            response = _context5.sent;
            window.removeEventListener('message', customMessageListener);
            return _context5.abrupt("return", response);

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function customMessage(_x3) {
    return _ref4.apply(this, arguments);
  };
}();

exports.customMessage = customMessage;

var requestLogin = /*#__PURE__*/function () {
  var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(params) {
    var callback, loginChallengeListener, response;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (!(typeof params.callback === 'function')) {
              _context7.next = 11;
              break;
            }

            callback = params.callback; // TODO: set message listener only if iframe is loaded correctly

            loginChallengeListener = /*#__PURE__*/function () {
              var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.LOGIN_CHALLENGE_REQUEST)) {
                          _context6.next = 12;
                          break;
                        }

                        _context6.prev = 2;
                        _context6.next = 5;
                        return callback();

                      case 5:
                        payload = _context6.sent;
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: payload
                        });
                        _context6.next = 12;
                        break;

                      case 9:
                        _context6.prev = 9;
                        _context6.t0 = _context6["catch"](2);
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: _context6.t0.message
                        });

                      case 12:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6, null, [[2, 9]]);
              }));

              return function loginChallengeListener(_x6) {
                return _ref7.apply(this, arguments);
              };
            }();

            window.addEventListener('message', loginChallengeListener, false);
            _context7.next = 6;
            return call(_objectSpread(_objectSpread({
              method: 'requestLogin'
            }, params), {}, {
              asyncChallenge: true,
              callback: null
            }));

          case 6:
            response = _context7.sent;
            window.removeEventListener('message', loginChallengeListener);
            return _context7.abrupt("return", response);

          case 11:
            _context7.next = 13;
            return call(_objectSpread({
              method: 'requestLogin'
            }, params));

          case 13:
            return _context7.abrupt("return", _context7.sent);

          case 14:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function requestLogin(_x5) {
    return _ref6.apply(this, arguments);
  };
}();

exports.requestLogin = requestLogin;

var disableWebUSB = function disableWebUSB() {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.TRANSPORT.DISABLE_WEBUSB
  });
};

exports.disableWebUSB = disableWebUSB;
//# sourceMappingURL=node_modules/trezor-connect/lib/env/browser/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/env/browser/index.js",}],
[3233, {}, function (require, module, exports) {
'use strict'

module.exports = function asMiddleware (engine) {
  return function engineAsMiddleware (req, res, next, end) {
    engine._runAllMiddleware(req, res)
      .then(async ({ isComplete, returnHandlers }) => {

        if (isComplete) {
          await engine._runReturnHandlers(returnHandlers)
          return end()
        }

        return next(async (handlerCallback) => {
          try {
            await engine._runReturnHandlers(returnHandlers)
          } catch (err) {
            return handlerCallback(err)
          }
          return handlerCallback()
        })
      })
      .catch((error) => {
        end(error)
      })
  }
}

//# sourceMappingURL=node_modules/rpc-cap/node_modules/json-rpc-engine/src/asMiddleware.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/json-rpc-engine/src/asMiddleware.js",}],
[3169, {"./errors":3170,"is-subset":2251}, function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forceParams = exports.limitResponseLength = exports.filterResponse = exports.requireParams = void 0;
const errors_1 = require("./errors");
const is_subset_1 = __importDefault(require("is-subset"));
/*
 * Require that the request params match those specified by the caveat value.
 */
exports.requireParams = function requireParams(serialized) {
    const { value } = serialized;
    return (req, res, next, end) => {
        const permitted = is_subset_1.default(req.params, value);
        if (!permitted) {
            res.error = errors_1.unauthorized({ data: req });
            return end(res.error);
        }
        next();
    };
};
/*
 * Filters array results shallowly.
 */
exports.filterResponse = function filterResponse(serialized) {
    const { value } = serialized;
    return (_req, res, next, _end) => {
        next((done) => {
            if (Array.isArray(res.result)) {
                res.result = res.result.filter((item) => {
                    return value.includes(item);
                });
            }
            done();
        });
    };
};
/*
 * Limits array results to a specific integer length.
 */
exports.limitResponseLength = function limitResponseLength(serialized) {
    const { value } = serialized;
    return (_req, res, next, _end) => {
        next((done) => {
            if (Array.isArray(res.result)) {
                res.result = res.result.slice(0, value);
            }
            done();
        });
    };
};
/*
 * Forces the method to be called with given params.
 */
exports.forceParams = function forceParams(serialized) {
    const { value } = serialized;
    return (req, _, next) => {
        req.params = [...value];
        next();
    };
};
//# sourceMappingURL=caveats.js.map
//# sourceMappingURL=node_modules/rpc-cap/dist/src/caveats.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/dist/src/caveats.js",}],
[3234, {"eth-rpc-errors":3201,"safe-event-emitter":3238}, function (require, module, exports) {
'use strict'

const SafeEventEmitter = require('safe-event-emitter')
const {
  serializeError,
  EthereumRpcError,
  ERROR_CODES,
} = require('eth-rpc-errors')

module.exports = class RpcEngine extends SafeEventEmitter {
  constructor () {
    super()
    this._middleware = []
  }

  //
  // Public
  //

  push (middleware) {
    this._middleware.push(middleware)
  }

  handle (req, cb) {

    if (Array.isArray(req)) {
      if (cb) {
        this._handleBatch(req)
          .then((res) => cb(null, res))
          .catch((err) => cb(err)) // fatal error
        return undefined
      }
      return this._handleBatch(req)
    }

    if (!cb) {
      return this._promiseHandle(req)
    }
    return this._handle(req, cb)
  }

  //
  // Private
  //

  async _handleBatch (reqs) {
    // The order here is important
    // 3. Return batch response, or reject on some kind of fatal error
    return await Promise.all( // 2. Wait for all requests to finish
      // 1. Begin executing each request in the order received
      reqs.map(this._promiseHandle.bind(this)),
    )
  }

  _promiseHandle (req) {
    return new Promise((resolve) => {
      this._handle(req, (_err, res) => {
        // there will always be a response, and it will always have any error
        // that is caught and propagated
        resolve(res)
      })
    })
  }

  _handle (callerReq, cb) {

    const req = Object.assign({}, callerReq)
    const res = {
      id: req.id,
      jsonrpc: req.jsonrpc,
    }

    let processingError

    this._processRequest(req, res)
      .catch((error) => {
        // either from return handlers or something unexpected
        processingError = error
      })
      .finally(() => {

        // preserve unserialized error, if any, for use in callback
        const responseError = res._originalError
        delete res._originalError

        const error = responseError || processingError || null

        if (error) {
          // ensure no result is present on an errored response
          delete res.result
          if (!res.error) {
            res.error = serializeError(error)
          }
        }

        cb(error, res)
      })
  }

  async _processRequest (req, res) {
    const { isComplete, returnHandlers } = await this._runAllMiddleware(req, res)
    this._checkForCompletion(req, res, isComplete)
    await this._runReturnHandlers(returnHandlers)
  }

  async _runReturnHandlers (handlers) {
    for (const handler of handlers) {
      await new Promise((resolve, reject) => {
        handler((err) => (err ? reject(err) : resolve()))
      })
    }
  }

  _checkForCompletion (req, res, isComplete) {
    if (!('result' in res) && !('error' in res)) {
      const requestBody = JSON.stringify(req, null, 2)
      const message = `JsonRpcEngine: Response has no error or result for request:\n${requestBody}`
      throw new EthereumRpcError(ERROR_CODES.rpc.internal, message, req)
    }
    if (!isComplete) {
      const requestBody = JSON.stringify(req, null, 2)
      const message = `JsonRpcEngine: Nothing ended request:\n${requestBody}`
      throw new EthereumRpcError(ERROR_CODES.rpc.internal, message, req)
    }
  }

  // walks down stack of middleware
  async _runAllMiddleware (req, res) {

    const returnHandlers = []
    // flag for early return
    let isComplete = false

    // go down stack of middleware, call and collect optional returnHandlers
    for (const middleware of this._middleware) {
      isComplete = await RpcEngine._runMiddleware(
        req, res, middleware, returnHandlers,
      )
      if (isComplete) {
        break
      }
    }
    return { isComplete, returnHandlers: returnHandlers.reverse() }
  }

  // runs an individual middleware
  static _runMiddleware (req, res, middleware, returnHandlers) {
    return new Promise((resolve) => {

      const end = (err) => {
        const error = err || (res && res.error)
        if (error) {
          res.error = serializeError(error)
          res._originalError = error
        }
        resolve(true) // true indicates the request should end
      }

      const next = (returnHandler) => {
        if (res.error) {
          end(res.error)
        } else {
          if (returnHandler) {
            returnHandlers.push(returnHandler)
          }
          resolve(false) // false indicates the request should not end
        }
      }

      try {
        middleware(req, res, next, end)
      } catch (error) {
        end(error)
      }
    })
  }
}

//# sourceMappingURL=node_modules/rpc-cap/node_modules/json-rpc-engine/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/json-rpc-engine/src/index.js",}],
[3170, {"eth-rpc-errors":3201}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userRejectedRequest = exports.internalError = exports.invalidReq = exports.methodNotFound = exports.unauthorized = void 0;
const ethErrors = require('eth-rpc-errors').ethErrors;
function unauthorized(arg) {
    return ethErrors.provider.unauthorized({
        message: (arg === null || arg === void 0 ? void 0 : arg.message) || 'Unauthorized to perform action. Try requesting permission first using the `requestPermissions` method. More info available at https://github.com/MetaMask/rpc-cap',
        data: (arg === null || arg === void 0 ? void 0 : arg.data) || undefined,
    });
}
exports.unauthorized = unauthorized;
const invalidReq = ethErrors.rpc.invalidRequest;
exports.invalidReq = invalidReq;
const internalError = ethErrors.rpc.internal;
exports.internalError = internalError;
function methodNotFound(opts) {
    const message = opts.methodName
        ? `The method '${opts.methodName}' does not exist / is not available.`
        : null;
    return ethErrors.rpc.methodNotFound({ data: opts.data, message });
}
exports.methodNotFound = methodNotFound;
function userRejectedRequest(request) {
    return ethErrors.provider.userRejectedRequest({ data: request });
}
exports.userRejectedRequest = userRejectedRequest;
//# sourceMappingURL=errors.js.map
//# sourceMappingURL=node_modules/rpc-cap/dist/src/errors.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/dist/src/errors.js",}],
[3181, {"./BaseController":3171,"./ComposableController":3172,"./approval/ApprovalController":3173,"./assets/AccountTrackerController":3174,"./assets/AssetsContractController":3175,"./assets/AssetsController":3176,"./assets/AssetsDetectionController":3177,"./assets/CurrencyRateController":3178,"./assets/TokenBalancesController":3179,"./assets/TokenRatesController":3180,"./keyring/KeyringController":3182,"./message-manager/MessageManager":3184,"./message-manager/PersonalMessageManager":3185,"./message-manager/TypedMessageManager":3186,"./network/NetworkController":3187,"./third-party/PhishingController":3188,"./transaction/TransactionController":3189,"./user/AddressBookController":3190,"./user/PreferencesController":3191,"./util":3192,"isomorphic-fetch":2259}, function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.util = void 0;
require("isomorphic-fetch");
const util = require("./util");
exports.util = util;
__exportStar(require("./assets/AccountTrackerController"), exports);
__exportStar(require("./user/AddressBookController"), exports);
__exportStar(require("./approval/ApprovalController"), exports);
__exportStar(require("./assets/AssetsContractController"), exports);
__exportStar(require("./assets/AssetsController"), exports);
__exportStar(require("./assets/AssetsDetectionController"), exports);
__exportStar(require("./BaseController"), exports);
__exportStar(require("./ComposableController"), exports);
__exportStar(require("./assets/CurrencyRateController"), exports);
__exportStar(require("./keyring/KeyringController"), exports);
__exportStar(require("./message-manager/MessageManager"), exports);
__exportStar(require("./network/NetworkController"), exports);
__exportStar(require("./third-party/PhishingController"), exports);
__exportStar(require("./user/PreferencesController"), exports);
__exportStar(require("./assets/TokenBalancesController"), exports);
__exportStar(require("./assets/TokenRatesController"), exports);
__exportStar(require("./transaction/TransactionController"), exports);
__exportStar(require("./message-manager/PersonalMessageManager"), exports);
__exportStar(require("./message-manager/TypedMessageManager"), exports);
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/index.js",}],
[19, {"../util":21,"json-rpc-engine":2274}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPendingNonceMiddleware = createPendingNonceMiddleware;
exports.createPendingTxMiddleware = createPendingTxMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _util = require("../util");

function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionCount') {
      next();
      return;
    }

    const [param, blockRef] = params;

    if (blockRef !== 'pending') {
      next();
      return;
    }

    res.result = await getPendingNonce(param);
  });
}

function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionByHash') {
      next();
      return;
    }

    const [hash] = params;
    const txMeta = getPendingTransactionByHash(hash);

    if (!txMeta) {
      next();
      return;
    }

    res.result = (0, _util.formatTxMetaForRpcResult)(txMeta);
  });
}

//# sourceMappingURL=app/scripts/controllers/network/middleware/pending.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/middleware/pending.js",}],
[1737, {"eth-rpc-errors":1701,"eth-sig-util":1707,"json-rpc-engine/src/createAsyncMiddleware":1722,"json-rpc-engine/src/createScaffoldMiddleware":1723}, function (require, module, exports) {
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const createScaffoldMiddleware = require('json-rpc-engine/src/createScaffoldMiddleware')
const sigUtil = require('eth-sig-util')
const { ethErrors } = require('eth-rpc-errors')

module.exports = function createWalletMiddleware(opts = {}) {
  // parse + validate options
  const getAccounts = opts.getAccounts
  const processTypedMessage = opts.processTypedMessage
  const processTypedMessageV3 = opts.processTypedMessageV3
  const processTypedMessageV4 = opts.processTypedMessageV4
  const processPersonalMessage = opts.processPersonalMessage
  const processEthSignMessage = opts.processEthSignMessage
  const processTransaction = opts.processTransaction
  const processDecryptMessage = opts.processDecryptMessage
  const processEncryptionPublicKey = opts.processEncryptionPublicKey

  if (!getAccounts) {
    throw new Error('opts.getAccounts is required')
  }

  return createScaffoldMiddleware({
    // account lookups
    'eth_accounts': createAsyncMiddleware(lookupAccounts),
    'eth_coinbase': createAsyncMiddleware(lookupDefaultAccount),
    // tx signatures
    'eth_sendTransaction': createAsyncMiddleware(sendTransaction),
    // message signatures
    'eth_sign': createAsyncMiddleware(ethSign),
    'eth_signTypedData': createAsyncMiddleware(signTypedData),
    'eth_signTypedData_v3': createAsyncMiddleware(signTypedDataV3),
    'eth_signTypedData_v4': createAsyncMiddleware(signTypedDataV4),
    'personal_sign': createAsyncMiddleware(personalSign),
    'eth_getEncryptionPublicKey': createAsyncMiddleware(encryptionPublicKey),
    'eth_decrypt': createAsyncMiddleware(decryptMessage),
    'personal_ecRecover': createAsyncMiddleware(personalRecover),
  })

  //
  // account lookups
  //

  async function lookupAccounts(req, res) {
    res.result = await getAccounts(req)
  }

  async function lookupDefaultAccount(req, res) {
    const accounts = await getAccounts(req)
    res.result = accounts[0] || null
  }

  //
  // transaction signatures
  //

  async function sendTransaction(req, res) {

    if (!processTransaction) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const txParams = req.params[0] || {}
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req)
    res.result = await processTransaction(txParams, req)
  }

  //
  // message signatures
  //

  async function ethSign(req, res) {

    if (!processEthSignMessage) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req)
    const message = req.params[1]
    const extraParams = req.params[2] || {}
    const msgParams = Object.assign({}, extraParams, {
      from: address,
      data: message,
    })

    res.result = await processEthSignMessage(msgParams, req)
  }

  async function signTypedData (req, res) {

    if (!processTypedMessage) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const message = req.params[0]
    const address = await validateAndNormalizeKeyholder(req.params[1], req)
    const version = 'V1'
    const extraParams = req.params[2] || {}
    const msgParams = Object.assign({}, extraParams, {
      from: address,
      data: message,
    })

    res.result = await processTypedMessage(msgParams, req, version)
  }

  async function signTypedDataV3 (req, res) {

    if (!processTypedMessageV3) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req)
    const message = req.params[1]
    const version = 'V3'
    const msgParams = {
      data: message,
      from: address,
      version
    }

    res.result = await processTypedMessageV3(msgParams, req, version)
  }

  async function signTypedDataV4 (req, res) {

    if (!processTypedMessageV4) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req)
    const message = req.params[1]
    const version = 'V4'
    const msgParams = {
      data: message,
      from: address,
      version
    }

    res.result = await processTypedMessageV4(msgParams, req, version)
  }

  async function personalSign (req, res) {

    if (!processPersonalMessage) {
      throw ethErrors.rpc.methodNotSupported()
    }

    // process normally
    const firstParam = req.params[0]
    const secondParam = req.params[1]
    // non-standard "extraParams" to be appended to our "msgParams" obj
    const extraParams = req.params[2] || {}

    // We initially incorrectly ordered these parameters.
    // To gracefully respect users who adopted this API early,
    // we are currently gracefully recovering from the wrong param order
    // when it is clearly identifiable.
    //
    // That means when the first param is definitely an address,
    // and the second param is definitely not, but is hex.
    let address, message
    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
      let warning = `The eth_personalSign method requires params ordered `
      warning += `[message, address]. This was previously handled incorrectly, `
      warning += `and has been corrected automatically. `
      warning += `Please switch this param order for smooth behavior in the future.`
      res.warning = warning

      address = firstParam
      message = secondParam
    } else {
      message = firstParam
      address = secondParam
    }
    address = await validateAndNormalizeKeyholder(address, req)

    const msgParams = Object.assign({}, extraParams, {
      from: address,
      data: message,
    })
    
    res.result = await processPersonalMessage(msgParams, req)
  }

  async function personalRecover(req, res) {

    const message = req.params[0]
    const signature = req.params[1]
    const extraParams = req.params[2] || {}
    const msgParams = Object.assign({}, extraParams, {
      sig: signature,
      data: message,
    })
    const signerAddress = sigUtil.recoverPersonalSignature(msgParams)

    res.result = signerAddress
  }

  async function encryptionPublicKey (req, res) {

    if (!processEncryptionPublicKey) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const address = await validateAndNormalizeKeyholder(req.params[0], req)

    res.result = await processEncryptionPublicKey(address, req)
  }
	
  async function decryptMessage (req, res) {

    if (!processDecryptMessage) {
      throw ethErrors.rpc.methodNotSupported()
    }

    const ciphertext = req.params[0]
    const address = await validateAndNormalizeKeyholder(req.params[1], req)
    const extraParams = req.params[2] || {}
    const msgParams = Object.assign({}, extraParams, {
      from: address,
      data: ciphertext,
    })

    res.result = await processDecryptMessage(msgParams, req)
  }

  //
  // utility
  //

  /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   * 
   * @param {string} address - The address to validate and normalize.
   * @param {Object} req - The request object.
   * @returns {string} - The normalized address, if valid. Otherwise, throws
   * an error
   */
  async function validateAndNormalizeKeyholder(address, req) {

    if (typeof address === 'string' && address.length > 0) {

      // ensure address is included in provided accounts
      const accounts = await getAccounts(req)
      const normalizedAccounts = accounts.map(_address => _address.toLowerCase())
      const normalizedAddress =  address.toLowerCase()

      if (normalizedAccounts.includes(normalizedAddress)) {
        return normalizedAddress
      }
    }
    throw ethErrors.rpc.invalidParams({
      message: `Invalid parameters: must provide an Ethereum address.`
    })
  }
}

function resemblesAddress (string) {
  // hex prefix 2 + 20 bytes
  return string.length === (2 + (20 * 2))
}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/wallet.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/wallet.js",}],
[3341, {"../plugins/json2":3342,"../src/store-engine":3344,"../storages/all":3346}, function (require, module, exports) {
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

//# sourceMappingURL=node_modules/store/dist/store.legacy.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/store/dist/store.legacy.js",}],
[160, {"./keyValueStore":159,"./utils/index":165,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/get":182,"@babel/runtime/helpers/getPrototypeOf":183,"@babel/runtime/helpers/inherits":184,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/possibleConstructorReturn":197,"@babel/runtime/regenerator":206}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get3 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var utils = require('./utils/index');

var ENC_BLOCK_SIZE = 24;

var PrivateStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(PrivateStore, _KeyValueStore);

  function PrivateStore(orbitdb, name, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, PrivateStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PrivateStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this.keyring = _3id.getKeyringBySpaceName(name);
    _this._salt = _this.keyring.getDBSalt();
    return _this;
  }

  (0, _createClass2["default"])(PrivateStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            entry,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "get", this).call(this, this._genDbKey(key), opts);

              case 3:
                entry = _context.sent;

                if (entry) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", _objectSpread({}, entry, {
                  value: this._decryptEntry(entry.value)
                }));

              case 8:
                return _context.abrupt("return", this._decryptEntry(entry));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "getMetadata", this).call(this, this._genDbKey(key)));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                value = this._encryptEntry(value);
                key = this._genDbKey(key);
                return _context3.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "set", this).call(this, key, value));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(keys, values) {
        var dbKeys, encryptedValues;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                utils.throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(this._genDbKey, this);
                encryptedValues = values.map(this._encryptEntry, this);
                return _context4.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "setMultiple", this).call(this, dbKeys, encryptedValues));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(key) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                key = this._genDbKey(key);
                return _context5.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "remove", this).call(this, key));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function remove(_x7) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store. Key is hashed, so key is
     * not available from the private store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: ...., value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "_genDbKey",
    value: function _genDbKey(key) {
      utils.throwIfUndefined(key, 'key');
      return utils.sha256Multihash(this._salt + key);
    }
  }, {
    key: "_encryptEntry",
    value: function _encryptEntry(entry) {
      if (typeof entry === 'undefined') throw new Error('Entry to encrypt cannot be undefined');
      return this.keyring.symEncrypt(this._pad(JSON.stringify(entry)));
    }
  }, {
    key: "_decryptEntry",
    value: function _decryptEntry(_ref) {
      var ciphertext = _ref.ciphertext,
          nonce = _ref.nonce;
      return JSON.parse(this._unpad(this.keyring.symDecrypt(ciphertext, nonce)));
    }
  }, {
    key: "_pad",
    value: function _pad(val) {
      var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
      var blockDiff = (blockSize - val.length % blockSize) % blockSize;
      return "".concat(val).concat('\0'.repeat(blockDiff));
    }
  }, {
    key: "_unpad",
    value: function _unpad(padded) {
      return padded.replace(/\0+$/, '');
    }
  }, {
    key: "log",
    get: function get() {
      var _this2 = this;

      return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "log", this).map(function (obj) {
        return Object.assign(obj, {
          value: obj.value ? _this2._decryptEntry(obj.value) : null
        });
      });
    }
  }]);
  return PrivateStore;
}(KeyValueStore);

module.exports = PrivateStore;
//# sourceMappingURL=node_modules/3box/lib/privateStore.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/privateStore.js",}],
[162, {"./keyValueStore":159,"./thread":163,"./utils":165,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"orbit-db/src/orbit-db-address":2838}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var Thread = require('./thread');

var _require = require('./utils'),
    sha256Multihash = _require.sha256Multihash,
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var OrbitDBAddress = require('orbit-db/src/orbit-db-address');

var ENC_BLOCK_SIZE = 24;

var nameToSpaceName = function nameToSpaceName(name) {
  return "3box.space.".concat(name, ".keyvalue");
};

var namesTothreadName = function namesTothreadName(spaceName, threadName) {
  return "3box.thread.".concat(spaceName, ".").concat(threadName);
};

var Space =
/*#__PURE__*/
function () {
  /**
   * Please use **box.openSpace** to get the instance of this class
   */
  function Space(name, threeId, orbitdb, rootStore, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Space);
    this._name = name;
    this._3id = threeId;
    this._ensureConnected = ensureConnected;
    this._store = new KeyValueStore(orbitdb, nameToSpaceName(this._name), this._ensureConnected, this._3id);
    this._orbitdb = orbitdb;
    this._activeThreads = {};
    this._rootStore = rootStore;
    /**
     * @property {KeyValueStore} public         access the profile store of the space
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the space
     */

    this["private"] = null;
  }
  /**
   * @property {String} DID        the did of the user in this space
   */


  (0, _createClass2["default"])(Space, [{
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var _this = this;

        var opts,
            consentNeeded,
            spaceAddress,
            entries,
            entry,
            hasNumEntries,
            numEntries,
            syncSpace,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                if (this._store._db) {
                  _context2.next = 29;
                  break;
                }

                _context2.next = 4;
                return this._3id.initKeyringByName(this._name);

              case 4:
                consentNeeded = _context2.sent;
                if (opts.consentCallback) opts.consentCallback(consentNeeded, this._name);
                _context2.next = 8;
                return this._store._load();

              case 8:
                spaceAddress = _context2.sent;
                _context2.next = 11;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 11:
                entries = _context2.sent;
                entry = entries.find(function (entry) {
                  return entry.payload.value.odbAddress && entry.payload.value.odbAddress.indexOf(nameToSpaceName(_this._name)) !== -1;
                });

                if (entry) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 16;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 16:
                _context2.next = 23;
                break;

              case 18:
                if (entry.payload.value.type) {
                  _context2.next = 23;
                  break;
                }

                _context2.next = 21;
                return this._rootStore.del(entry.hash);

              case 21:
                _context2.next = 23;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 23:
                hasNumEntries = opts.numEntriesMessages && opts.numEntriesMessages[spaceAddress];
                numEntries = hasNumEntries ? opts.numEntriesMessages[spaceAddress].numEntries : undefined;

                syncSpace =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee() {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return _this._store._sync(numEntries);

                          case 2:
                            if (opts.onSyncDone) opts.onSyncDone();

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function syncSpace() {
                    return _ref.apply(this, arguments);
                  };
                }();

                this._syncSpacePromise = syncSpace();
                this["public"] = publicStoreReducer(this._store);
                this["private"] = privateStoreReducer(this._store, this._3id.getKeyringBySpaceName(nameToSpaceName(this._name)));

              case 29:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function open() {
        return _open.apply(this, arguments);
      }

      return open;
    }()
    /**
     * Join a thread. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    name                    The name of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator
     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThread",
    value: function () {
      var _joinThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(name) {
        var opts,
            subscribeFn,
            thread,
            address,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                if (!opts.firstModerator) opts.firstModerator = this._3id.getSubDID(this._name);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, name), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context3.next = 6;
                return thread._getThreadAddress();

              case 6:
                address = _context3.sent;

                if (!this._activeThreads[address]) {
                  _context3.next = 9;
                  break;
                }

                return _context3.abrupt("return", this._activeThreads[address]);

              case 9:
                _context3.next = 11;
                return thread._load();

              case 11:
                this._activeThreads[address] = thread;
                return _context3.abrupt("return", thread);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function joinThread(_x) {
        return _joinThread.apply(this, arguments);
      }

      return joinThread;
    }()
    /**
     * Join a thread by full thread address. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    address                 The full address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThreadByAddress",
    value: function () {
      var _joinThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(address) {
        var opts,
            threadSpace,
            threadName,
            subscribeFn,
            thread,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error('joinThreadByAddress: valid orbitdb address required');

              case 3:
                threadSpace = address.split('.')[2];
                threadName = address.split('.')[3];

                if (!(threadSpace !== this._name)) {
                  _context4.next = 7;
                  break;
                }

                throw new Error('joinThreadByAddress: attempting to open thread from different space, must open within same space');

              case 7:
                if (!this._activeThreads[address]) {
                  _context4.next = 9;
                  break;
                }

                return _context4.abrupt("return", this._activeThreads[address]);

              case 9:
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, threadName), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context4.next = 13;
                return thread._load(address);

              case 13:
                this._activeThreads[address] = thread;
                return _context4.abrupt("return", thread);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function joinThreadByAddress(_x2) {
        return _joinThreadByAddress.apply(this, arguments);
      }

      return joinThreadByAddress;
    }()
    /**
     * Subscribe to the given thread, if not already subscribed
     *
     * @param     {String}    address                The address of the thread
     * @param     {Object}    config                configuration and thread meta data
     * @param     {String}    opts.name             Name of thread
     * @param     {String}    opts.firstModerator   DID of the first moderator
     * @param     {String}    opts.members          Boolean string, true if a members only thread
     */

  }, {
    key: "subscribeThread",
    value: function () {
      var _subscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(address) {
        var config,
            threadKey,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                config = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('subscribeThread: must subscribe to valid thread/orbitdb address');

              case 3:
                threadKey = "thread-".concat(address);
                _context5.next = 6;
                return this._syncSpacePromise;

              case 6:
                _context5.next = 8;
                return this["public"].get(threadKey);

              case 8:
                if (_context5.sent) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this["public"].set(threadKey, Object.assign({}, config, {
                  address: address
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function subscribeThread(_x3) {
        return _subscribeThread.apply(this, arguments);
      }

      return subscribeThread;
    }()
    /**
     * Unsubscribe from the given thread, if subscribed
     *
     * @param     {String}    address     The address of the thread
     */

  }, {
    key: "unsubscribeThread",
    value: function () {
      var _unsubscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(address) {
        var threadKey;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                threadKey = "thread-".concat(address);
                _context6.next = 3;
                return this["public"].get(threadKey);

              case 3:
                if (!_context6.sent) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 6;
                return this["public"].remove(threadKey);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function unsubscribeThread(_x4) {
        return _unsubscribeThread.apply(this, arguments);
      }

      return unsubscribeThread;
    }()
    /**
     * Get a list of all the threads subscribed to in this space
     *
     * @return    {Array<Objects>}    A list of thread objects as { address, firstModerator, members, name}
     */

  }, {
    key: "subscribedThreads",
    value: function () {
      var _subscribedThreads = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7() {
        var allEntries;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this["public"].all();

              case 2:
                allEntries = _context7.sent;
                return _context7.abrupt("return", Object.keys(allEntries).reduce(function (threads, key) {
                  if (key.startsWith('thread')) {
                    // ignores experimental threads (v1)
                    var address = key.split('thread-')[1];

                    if (OrbitDBAddress.isValid(address)) {
                      threads.push(allEntries[key]);
                    }
                  }

                  return threads;
                }, []));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function subscribedThreads() {
        return _subscribedThreads.apply(this, arguments);
      }

      return subscribedThreads;
    }()
  }, {
    key: "DID",
    get: function get() {
      return this._3id.getSubDID(this._name);
    }
  }]);
  return Space;
}();

module.exports = Space;

var publicStoreReducer = function publicStoreReducer(store) {
  var PREFIX = 'pub_';
  return {
    get: function () {
      var _get = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(key) {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                return _context8.abrupt("return", store.get(PREFIX + key, opts));

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function get(_x5) {
        return _get.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(key) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", store.getMetadata(PREFIX + key));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function getMetadata(_x6) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(key, value) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context10.abrupt("return", store.set(PREFIX + key, value));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      function set(_x7, _x8) {
        return _set.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(keys, values) {
        var prefixedKeys;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                prefixedKeys = keys.map(function (key) {
                  return PREFIX + key;
                });
                return _context11.abrupt("return", store.setMultiple(prefixedKeys, values));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      function setMultiple(_x9, _x10) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(key) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context12.abrupt("return", store.remove(PREFIX + key));

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }));

      function remove(_x11) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          entry.key = entry.key.slice(4);
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(opts) {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return store.all(opts);

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    newAll[key.slice(4)] = entries[key];
                  }

                  return newAll;
                }, {}));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));

      function all(_x12) {
        return _all.apply(this, arguments);
      }

      return all;
    }()
  };
};

var privateStoreReducer = function privateStoreReducer(store, keyring) {
  var PREFIX = 'priv_';
  var SALT = keyring.getDBSalt();

  var dbKey = function dbKey(key) {
    throwIfUndefined(key, 'key');
    return PREFIX + sha256Multihash(SALT + key);
  };

  var pad = function pad(val) {
    var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
    var blockDiff = (blockSize - val.length % blockSize) % blockSize;
    return "".concat(val).concat('\0'.repeat(blockDiff));
  };

  var unpad = function unpad(padded) {
    return padded.replace(/\0+$/, '');
  };

  var encryptEntry = function encryptEntry(entry) {
    return keyring.symEncrypt(pad(JSON.stringify(entry)));
  };

  var decryptEntry = function decryptEntry(_ref2) {
    var ciphertext = _ref2.ciphertext,
        nonce = _ref2.nonce;
    return JSON.parse(unpad(keyring.symDecrypt(ciphertext, nonce)));
  };

  return {
    get: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14(key) {
        var opts,
            entry,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                _context14.next = 3;
                return store.get(dbKey(key), opts);

              case 3:
                entry = _context14.sent;

                if (entry) {
                  _context14.next = 6;
                  break;
                }

                return _context14.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context14.next = 8;
                  break;
                }

                return _context14.abrupt("return", _objectSpread({}, entry, {
                  value: decryptEntry(entry.value).value
                }));

              case 8:
                return _context14.abrupt("return", decryptEntry(entry).value);

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14);
      }));

      function get(_x13) {
        return _get2.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(key) {
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", store.getMetadata(dbKey(key)));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      function getMetadata(_x14) {
        return _getMetadata2.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(key, value) {
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", store.set(dbKey(key), encryptEntry({
                  key: key,
                  value: value
                })));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function set(_x15, _x16) {
        return _set2.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(keys, values) {
        var dbKeys, encryptedEntries;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(dbKey);
                encryptedEntries = values.map(function (value, index) {
                  return encryptEntry({
                    key: keys[index],
                    value: value
                  });
                });
                return _context17.abrupt("return", store.setMultiple(dbKeys, encryptedEntries));

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function setMultiple(_x17, _x18) {
        return _setMultiple2.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(key) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", store.remove(dbKey(key)));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function remove(_x19) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          var decEntry = decryptEntry(entry.value);
          entry.key = decEntry.key;
          entry.value = decEntry.value;
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var opts,
            entries,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                opts = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : {};
                _context19.next = 3;
                return store.all(opts);

              case 3:
                entries = _context19.sent;
                return _context19.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    var entry = entries[key];

                    if (opts.metadata) {
                      var decEntry = decryptEntry(entry.value);
                      newAll[decEntry.key] = _objectSpread({}, entry, {
                        value: decEntry.value
                      });
                    } else {
                      var _decEntry = decryptEntry(entry);

                      newAll[_decEntry.key] = _decEntry.value;
                    }
                  }

                  return newAll;
                }, {}));

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      function all() {
        return _all2.apply(this, arguments);
      }

      return all;
    }()
  };
};
//# sourceMappingURL=node_modules/3box/lib/space.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/space.js",}],
[157, {"./config.js":158,"./utils/id":164,"./utils/index":165,"./utils/verifier":166,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"graphql-request":1892}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var graphQLRequest = require('graphql-request').request;

var utils = require('./utils/index');

var verifier = require('./utils/verifier');

var _require = require('./utils/id'),
    isMuportDID = _require.isMuportDID;

var config = require('./config.js');

var GRAPHQL_SERVER_URL = config.graphql_server_url;
var PROFILE_SERVER_URL = config.profile_server_url;
var ADDRESS_SERVER_URL = config.address_server_url;

function getRootStoreAddress(_x) {
  return _getRootStoreAddress.apply(this, arguments);
}

function _getRootStoreAddress() {
  _getRootStoreAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(identifier) {
    var serverUrl,
        res,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            serverUrl = _args.length > 1 && _args[1] !== undefined ? _args[1] : ADDRESS_SERVER_URL;
            _context.next = 3;
            return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);

          case 3:
            res = _context.sent;
            return _context.abrupt("return", res.data.rootStoreAddress);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getRootStoreAddress.apply(this, arguments);
}

function listSpaces(_x2) {
  return _listSpaces.apply(this, arguments);
}

function _listSpaces() {
  _listSpaces = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(address) {
    var serverUrl,
        _args2 = arguments;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            serverUrl = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : PROFILE_SERVER_URL;
            _context2.prev = 1;

            if (!isMuportDID(address)) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return utils.fetchJson(serverUrl + '/list-spaces?did=' + encodeURIComponent(address));

          case 5:
            return _context2.abrupt("return", _context2.sent);

          case 8:
            _context2.next = 10;
            return utils.fetchJson(serverUrl + '/list-spaces?address=' + encodeURIComponent(address));

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](1);
            return _context2.abrupt("return", []);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 13]]);
  }));
  return _listSpaces.apply(this, arguments);
}

function getSpace(_x3, _x4) {
  return _getSpace.apply(this, arguments);
} // TODO consumes address now, could also give root DID to get space DID


function _getSpace() {
  _getSpace = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(address, name) {
    var serverUrl,
        _ref,
        metadata,
        blocklist,
        url,
        _args3 = arguments;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            serverUrl = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : PROFILE_SERVER_URL;
            _ref = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {}, metadata = _ref.metadata, blocklist = _ref.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context3.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/space");
            _context3.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add name:


            url = "".concat(url, "&name=").concat(encodeURIComponent(name)); // Add metadata:

            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context3.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context3.abrupt("return", _context3.sent);

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](5);
            return _context3.abrupt("return", {});

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 14]]);
  }));
  return _getSpace.apply(this, arguments);
}

function getSpaceDID(_x5, _x6) {
  return _getSpaceDID.apply(this, arguments);
}

function _getSpaceDID() {
  _getSpaceDID = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee4(address, space) {
    var opts,
        conf,
        _args4 = arguments;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
            _context4.next = 3;
            return getConfig(address, opts);

          case 3:
            conf = _context4.sent;

            if (!(!conf.spaces[space] || !conf.spaces[space].DID)) {
              _context4.next = 6;
              break;
            }

            throw new Error("Could not find appropriate DID for address ".concat(address));

          case 6:
            return _context4.abrupt("return", conf.spaces[space].DID);

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getSpaceDID.apply(this, arguments);
}

function getThread(_x7, _x8, _x9, _x10) {
  return _getThread.apply(this, arguments);
}

function _getThread() {
  _getThread = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee5(space, name, firstModerator, members) {
    var opts,
        serverUrl,
        url,
        _args5 = arguments;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            opts = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;

            if (!firstModerator.startsWith('0x')) {
              _context5.next = 6;
              break;
            }

            _context5.next = 5;
            return getSpaceDID(firstModerator, space, opts);

          case 5:
            firstModerator = _context5.sent;

          case 6:
            _context5.prev = 6;
            url = "".concat(serverUrl, "/thread?space=").concat(encodeURIComponent(space), "&name=").concat(encodeURIComponent(name));
            url += "&mod=".concat(encodeURIComponent(firstModerator), "&members=").concat(encodeURIComponent(members));
            _context5.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context5.abrupt("return", _context5.sent);

          case 14:
            _context5.prev = 14;
            _context5.t0 = _context5["catch"](6);
            throw new Error(_context5.t0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[6, 14]]);
  }));
  return _getThread.apply(this, arguments);
}

function getThreadByAddress(_x11) {
  return _getThreadByAddress.apply(this, arguments);
}

function _getThreadByAddress() {
  _getThreadByAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(address) {
    var opts,
        serverUrl,
        _args6 = arguments;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context6.prev = 2;
            _context6.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/thread?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](2);
            throw new Error(_context6.t0);

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[2, 8]]);
  }));
  return _getThreadByAddress.apply(this, arguments);
}

function getConfig(_x12) {
  return _getConfig.apply(this, arguments);
}

function _getConfig() {
  _getConfig = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee7(address) {
    var opts,
        serverUrl,
        _args7 = arguments;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context7.prev = 2;
            _context7.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/config?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context7.abrupt("return", _context7.sent);

          case 8:
            _context7.prev = 8;
            _context7.t0 = _context7["catch"](2);
            throw new Error(_context7.t0);

          case 11:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[2, 8]]);
  }));
  return _getConfig.apply(this, arguments);
}

function getProfile(_x13) {
  return _getProfile.apply(this, arguments);
}

function _getProfile() {
  _getProfile = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee8(address) {
    var serverUrl,
        _ref2,
        metadata,
        blocklist,
        url,
        _args8 = arguments;

    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            serverUrl = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : PROFILE_SERVER_URL;
            _ref2 = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {}, metadata = _ref2.metadata, blocklist = _ref2.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context8.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/profile");
            _context8.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add metadata:


            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context8.next = 10;
            return utils.fetchJson(url);

          case 10:
            return _context8.abrupt("return", _context8.sent);

          case 13:
            _context8.prev = 13;
            _context8.t0 = _context8["catch"](5);
            return _context8.abrupt("return", {});

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[5, 13]]);
  }));
  return _getProfile.apply(this, arguments);
}

function getProfiles(_x14) {
  return _getProfiles.apply(this, arguments);
}

function _getProfiles() {
  _getProfiles = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee9(addressArray) {
    var opts,
        req,
        url,
        _args9 = arguments;
    return _regenerator["default"].wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            opts = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
            opts = Object.assign({
              profileServer: PROFILE_SERVER_URL
            }, opts);
            req = {
              addressList: [],
              didList: [] // Split addresses on ethereum / dids

            };
            addressArray.forEach(function (address) {
              if (isMuportDID(address)) {
                req.didList.push(address);
              } else {
                req.addressList.push(address);
              }
            });
            url = "".concat(opts.profileServer, "/profileList");
            return _context9.abrupt("return", utils.fetchJson(url, req));

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _getProfiles.apply(this, arguments);
}

function profileGraphQL(_x15) {
  return _profileGraphQL.apply(this, arguments);
}

function _profileGraphQL() {
  _profileGraphQL = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee10(query) {
    var opts,
        _args10 = arguments;
    return _regenerator["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
            opts = Object.assign({
              graphqlServer: GRAPHQL_SERVER_URL
            }, opts);
            return _context10.abrupt("return", graphQLRequest(opts.graphqlServer, query));

          case 3:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _profileGraphQL.apply(this, arguments);
}

function getVerifiedAccounts(_x16) {
  return _getVerifiedAccounts.apply(this, arguments);
}

function _getVerifiedAccounts() {
  _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee11(profile) {
    var verifs, did;
    return _regenerator["default"].wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            verifs = {};
            _context11.prev = 1;
            _context11.next = 4;
            return verifier.verifyDID(profile.proof_did);

          case 4:
            did = _context11.sent;
            verifs.did = did;

            if (!profile.proof_github) {
              _context11.next = 15;
              break;
            }

            _context11.prev = 7;
            _context11.next = 10;
            return verifier.verifyGithub(did, profile.proof_github);

          case 10:
            verifs.github = _context11.sent;
            _context11.next = 15;
            break;

          case 13:
            _context11.prev = 13;
            _context11.t0 = _context11["catch"](7);

          case 15:
            if (!profile.proof_twitter) {
              _context11.next = 24;
              break;
            }

            _context11.prev = 16;
            _context11.next = 19;
            return verifier.verifyTwitter(did, profile.proof_twitter);

          case 19:
            verifs.twitter = _context11.sent;
            _context11.next = 24;
            break;

          case 22:
            _context11.prev = 22;
            _context11.t1 = _context11["catch"](16);

          case 24:
            if (!profile.ethereum_proof) {
              _context11.next = 33;
              break;
            }

            _context11.prev = 25;
            _context11.next = 28;
            return verifier.verifyEthereum(profile.ethereum_proof, did);

          case 28:
            verifs.ethereum = _context11.sent;
            _context11.next = 33;
            break;

          case 31:
            _context11.prev = 31;
            _context11.t2 = _context11["catch"](25);

          case 33:
            _context11.next = 37;
            break;

          case 35:
            _context11.prev = 35;
            _context11.t3 = _context11["catch"](1);

          case 37:
            return _context11.abrupt("return", verifs);

          case 38:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, null, [[1, 35], [7, 13], [16, 22], [25, 31]]);
  }));
  return _getVerifiedAccounts.apply(this, arguments);
}

module.exports = {
  profileGraphQL: profileGraphQL,
  getProfile: getProfile,
  getSpace: getSpace,
  listSpaces: listSpaces,
  getThread: getThread,
  getThreadByAddress: getThreadByAddress,
  getConfig: getConfig,
  getRootStoreAddress: getRootStoreAddress,
  getProfiles: getProfiles,
  getVerifiedAccounts: getVerifiedAccounts,
  getSpaceDID: getSpaceDID
};
//# sourceMappingURL=node_modules/3box/lib/api.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/api.js",}],
[165, {"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"buffer":1428,"ethers":170,"js-sha256":2262,"multihashes":2698,"node-fetch":2724}, function (require, module, exports) {
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fetch = typeof window !== 'undefined' ? window.fetch : require('node-fetch');

var Multihash = require('multihashes');

var sha256 = require('js-sha256').sha256;

var ethers = require('ethers');

var HTTPError = function HTTPError(status, message) {
  var e = new Error(message);
  e.statusCode = status;
  return e;
};

var getMessageConsent = function getMessageConsent(did, timestamp) {
  var msg = 'Create a new 3Box profile' + '\n\n' + '- \n' + 'Your unique profile ID is ' + did;
  if (timestamp) msg += ' \n' + 'Timestamp: ' + timestamp;
  return msg;
};

var safeEthSend = function safeEthSend(ethereum, data, callback) {
  var send = (Boolean(ethereum.sendAsync) ? ethereum.sendAsync : ethereum.send).bind(ethereum);
  return new Promise(function (resolve, reject) {
    send(data, function (err, result) {
      if (err) reject(err);
      if (result.error) reject(result.error);
      resolve(result.result);
    });
  });
};

module.exports = {
  getMessageConsent: getMessageConsent,
  recoverPersonalSign: function () {
    var _recoverPersonalSign = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(msg, personalSig) {
      var msgParams;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!msg || !personalSig)) {
                _context.next = 2;
                break;
              }

              throw new Error('recoverPersonalSign: missing arguments, msg and/or personalSig');

            case 2:
              msgParams = {
                data: msg,
                sig: personalSig
              };
              return _context.abrupt("return", ethers.utils.verifyMessage(msg, personalSig));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function recoverPersonalSign(_x, _x2) {
      return _recoverPersonalSign.apply(this, arguments);
    }

    return recoverPersonalSign;
  }(),
  openBoxConsent: function openBoxConsent(fromAddress, ethereum) {
    var text = 'This app wants to view and update your 3Box profile.';
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  openSpaceConsent: function openSpaceConsent(fromAddress, ethereum, name) {
    var text = "Allow this app to open your ".concat(name, " space.");
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  getLinkConsent: function () {
    var _getLinkConsent = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(fromAddress, toDID, ethereum) {
      var timestamp, text, msg, params, method, sig;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              timestamp = Math.floor(new Date().getTime() / 1000);
              text = getMessageConsent(toDID, timestamp);
              msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
              params = [msg, fromAddress];
              method = 'personal_sign';
              _context2.next = 7;
              return safeEthSend(ethereum, {
                jsonrpc: '2.0',
                id: 0,
                method: method,
                params: params,
                fromAddress: fromAddress
              });

            case 7:
              sig = _context2.sent;
              return _context2.abrupt("return", {
                msg: text,
                sig: sig,
                timestamp: timestamp
              });

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function getLinkConsent(_x3, _x4, _x5) {
      return _getLinkConsent.apply(this, arguments);
    }

    return getLinkConsent;
  }(),
  fetchJson: function () {
    var _fetchJson = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(url, body) {
      var opts, r;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (body) {
                opts = {
                  body: JSON.stringify(body),
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                };
              }

              _context3.next = 3;
              return fetch(url, opts);

            case 3:
              r = _context3.sent;

              if (!r.ok) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", r.json());

            case 8:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function fetchJson(_x6, _x7) {
      return _fetchJson.apply(this, arguments);
    }

    return fetchJson;
  }(),
  fetchText: function () {
    var _fetchText = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(url, opts) {
      var r;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return fetch(url, opts);

            case 2:
              r = _context4.sent;

              if (!r.ok) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", r.text());

            case 7:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function fetchText(_x8, _x9) {
      return _fetchText.apply(this, arguments);
    }

    return fetchText;
  }(),
  throwIfUndefined: function throwIfUndefined(arg, name) {
    if (arg === undefined || arg === null) {
      throw new Error("".concat(name, " is a required argument"));
    }
  },
  throwIfNotEqualLenArrays: function throwIfNotEqualLenArrays(arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
      throw new Error('One or more arguments are not an array');
    }

    if (arr1.length !== arr2.length) {
      throw new Error('Arrays must be of the same length');
    }
  },
  sha256Multihash: function sha256Multihash(str) {
    var digest = Buffer.from(sha256.digest(str));
    return Multihash.encode(digest, 'sha2-256').toString('hex');
  },
  sha256: sha256
};
}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/3box/lib/utils/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/utils/index.js",}],
[158, {"_process":2892,"ipfs-log":1994}, function (require, module, exports) {
(function (process){
"use strict";

var Log = require('ipfs-log');

var IFRAME_STORE_VERSION = '0.0.3';
module.exports = {
  address_server_url: process.env.ADDRESS_SERVER_URL || 'https://beta.3box.io/address-server',
  pinning_node: process.env.PINNING_NODE || '/dnsaddr/ipfs.3box.io/tcp/443/wss/ipfs/QmZvxEpiVNjmNbEKyQGvFzAY1BwmGuuvdUTmcTstQPhyVC',
  pinning_room: process.env.PINNING_ROOM || '3box-pinning',
  iframe_store_version: process.env.IFRAME_STORE_VERSION || IFRAME_STORE_VERSION,
  iframe_store_url: process.env.IFRAME_STORE_URL || "https://iframe.3box.io/".concat(IFRAME_STORE_VERSION, "/iframe.html"),
  ipfs_options: {
    EXPERIMENTAL: {
      pubsub: true
    },
    preload: {
      enabled: false
    },
    config: {
      Bootstrap: []
    }
  },
  orbitdb_options: {
    syncLocal: true,
    sortFn: Log.Sorting.SortByEntryHash // this option is required now but will likely not be in the future.

  },
  graphql_server_url: process.env.GRAPHQL_SERVER_URL || 'https://api.3box.io/graph/',
  profile_server_url: process.env.PROFILE_SERVER_URL || 'https://ipfs.3box.io',
  muport_ipfs_host: process.env.MUPORT_IPFS_HOST || 'ipfs.infura.io',
  muport_ipfs_port: process.env.MUPORT_IPFS_PORT || 5001,
  muport_ipfs_protocol: process.env.MUPORT_IPFS_PROTOCOL || 'https'
};
}).call(this,require('_process'))

//# sourceMappingURL=node_modules/3box/lib/config.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/config.js",}],
[2828, {"./src/ipfs-pubsub":2829}, function (require, module, exports) {
module.exports = require('./src/ipfs-pubsub')

//# sourceMappingURL=node_modules/orbit-db-pubsub/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/orbit-db-pubsub/index.js",}],
[155, {"../config.js":158,"../utils/index":165,"./keyring":156,"3box-orbitdb-plugins":149,"3id-resolver":171,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"buffer":1428,"did-jwt":168,"ethers":170,"ipfs-did-document":1983,"ipfs-mini":2026,"orbit-db-identity-provider":2790,"store":3341}, function (require, module, exports) {
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var didJWT = require('did-jwt');

var DidDocument = require('ipfs-did-document');

var IpfsMini = require('ipfs-mini');

var localstorage = require('store');

var Identities = require('orbit-db-identity-provider');

var _require = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require.OdbIdentityProvider;

Identities.addIdentityProvider(OdbIdentityProvider);

var registerResolver = require('3id-resolver');

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var DID_METHOD_NAME = '3';
var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};

var ThreeId =
/*#__PURE__*/
function () {
  function ThreeId(serializeState, ethereum, ipfs, opts) {
    (0, _classCallCheck2["default"])(this, ThreeId);
    this._ethereum = ethereum;
    this._ipfs = ipfs;
    this._keyrings = {};

    this._initKeys(serializeState, opts);

    registerResolver(ipfs);
    localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
  }

  (0, _createClass2["default"])(ThreeId, [{
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(payload) {
        var _ref,
            use3ID,
            space,
            expiresIn,
            keyring,
            issuer,
            settings,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, use3ID = _ref.use3ID, space = _ref.space, expiresIn = _ref.expiresIn;
                keyring = space ? this._keyrings[space] : this._mainKeyring;
                issuer = this.muportDID;

                if (use3ID) {
                  issuer = this.DID;
                } else if (space) {
                  issuer = this._subDIDs[space];
                }

                settings = {
                  signer: keyring.getJWTSigner(),
                  issuer: issuer,
                  expiresIn: expiresIn
                };
                return _context.abrupt("return", didJWT.createJWT(payload, settings));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signJWT(_x) {
        return _signJWT.apply(this, arguments);
      }

      return signJWT;
    }()
  }, {
    key: "getSubDID",
    value: function getSubDID(space) {
      return this._subDIDs[space];
    }
  }, {
    key: "getOdbId",
    value: function () {
      var _getOdbId = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(space) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Identities.createIdentity({
                  type: '3ID',
                  threeId: this,
                  space: space
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getOdbId(_x2) {
        return _getOdbId.apply(this, arguments);
      }

      return getOdbId;
    }()
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this = this;

      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_initKeys",
    value: function _initKeys(serializeState) {
      var _this2 = this;

      var state = JSON.parse(serializeState); // TODO remove toLowerCase() in future, should be sanitized elsewhere
      //      this forces existing state to correct state so that address <->
      //      rootstore relation holds

      this.managementAddress = state.managementAddress.toLowerCase();
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this2._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
    }
  }, {
    key: "_initDID",
    value: function () {
      var _initDID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(muportIpfs) {
        var _this3 = this;

        var muportPromise, spaces, subDIDs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                muportPromise = this._initMuport(muportIpfs);
                _context3.next = 3;
                return this._init3ID();

              case 3:
                this._rootDID = _context3.sent;
                spaces = Object.keys(this._keyrings);
                _context3.next = 7;
                return Promise.all(spaces.map(function (space) {
                  return _this3._init3ID(space);
                }));

              case 7:
                subDIDs = _context3.sent;
                this._subDIDs = {};
                spaces.map(function (space, i) {
                  _this3._subDIDs[space] = subDIDs[i];
                });
                _context3.next = 12;
                return muportPromise;

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _initDID(_x3) {
        return _initDID2.apply(this, arguments);
      }

      return _initDID;
    }()
  }, {
    key: "_init3ID",
    value: function () {
      var _init3ID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(spaceName) {
        var doc, pubkeys, _pubkeys, payload, signature;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);

                if (spaceName) {
                  _context4.next = 9;
                  break;
                }

                pubkeys = this._mainKeyring.getPublicKeys(true);
                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', this.managementAddress);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
                _context4.next = 20;
                break;

              case 9:
                _pubkeys = this._keyrings[spaceName].getPublicKeys(true);
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', _pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', _pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', spaceName);
                doc.addCustomProperty('root', this.DID);
                payload = {
                  subSigningKey: _pubkeys.signingKey,
                  subEncryptionKey: _pubkeys.asymEncryptionKey,
                  space: spaceName,
                  iat: null
                };
                _context4.next = 18;
                return this.signJWT(payload, {
                  use3ID: true
                });

              case 18:
                signature = _context4.sent.split('.')[2];
                doc.addCustomProperty('proof', {
                  alg: 'ES256K',
                  signature: signature
                });

              case 20:
                _context4.next = 22;
                return doc.commit({
                  noTimestamp: true
                });

              case 22:
                return _context4.abrupt("return", doc.DID);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _init3ID(_x4) {
        return _init3ID2.apply(this, arguments);
      }

      return _init3ID;
    }()
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(muportIpfs) {
        var keys, doc, docHash, publishToInfura;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                keys = this._mainKeyring.getPublicKeys();
                doc = createMuportDocument(keys.signingKey, this.managementAddress, keys.asymEncryptionKey);
                _context6.next = 4;
                return this._ipfs.add(Buffer.from(JSON.stringify(doc)));

              case 4:
                docHash = _context6.sent[0].hash;
                this._muportDID = 'did:muport:' + docHash;
                this.muportFingerprint = utils.sha256Multihash(this.muportDID);

                publishToInfura =
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee5() {
                    var ipfsMini;
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            ipfsMini = new IpfsMini(muportIpfs);
                            ipfsMini.addJSON(doc, function (err, res) {
                              if (err) console.error(err);
                            });

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function publishToInfura() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                publishToInfura();

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _initMuport(_x5) {
        return _initMuport2.apply(this, arguments);
      }

      return _initMuport;
    }()
  }, {
    key: "getKeyringBySpaceName",
    value: function getKeyringBySpaceName(name) {
      var split = name.split('.');

      if (split[0] === this.muportFingerprint) {
        return this._mainKeyring;
      } else {
        return this._keyrings[split[2]];
      }
    }
  }, {
    key: "initKeyringByName",
    value: function () {
      var _initKeyringByName = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(name) {
        var sig, entropy, seed;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._keyrings[name]) {
                  _context7.next = 14;
                  break;
                }

                _context7.next = 3;
                return utils.openSpaceConsent(this.managementAddress, this._ethereum, name);

              case 3:
                sig = _context7.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = HDNode.mnemonicToSeed(HDNode.entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                _context7.next = 9;
                return this._init3ID(name);

              case 9:
                this._subDIDs[name] = _context7.sent;
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context7.abrupt("return", true);

              case 14:
                return _context7.abrupt("return", false);

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initKeyringByName(_x6) {
        return _initKeyringByName.apply(this, arguments);
      }

      return initKeyringByName;
    }()
  }, {
    key: "logout",
    value: function logout() {
      localstorage.remove(STORAGE_KEY + this.managementAddress);
    }
  }, {
    key: "DID",
    get: function get() {
      return this._rootDID;
    }
  }, {
    key: "muportDID",
    get: function get() {
      return this._muportDID;
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(address, ethereum, ipfs) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            _3id,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context8.next = 7;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context8.next = 19;
                break;

              case 7:
                if (!opts.contentSignature) {
                  _context8.next = 11;
                  break;
                }

                sig = opts.contentSignature;
                _context8.next = 14;
                break;

              case 11:
                _context8.next = 13;
                return utils.openBoxConsent(normalizedAddress, ethereum);

              case 13:
                sig = _context8.sent;

              case 14:
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                seed = HDNode.mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: normalizedAddress,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 19:
                _3id = new ThreeId(serialized3id, ethereum, ipfs, opts);
                _context8.next = 22;
                return _3id._initDID(opts.muportIpfs || MUPORT_IPFS);

              case 22:
                return _context8.abrupt("return", _3id);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function getIdFromEthAddress(_x7, _x8, _x9) {
        return _getIdFromEthAddress.apply(this, arguments);
      }

      return getIdFromEthAddress;
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;
}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/3box/lib/3id/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/3id/index.js",}],
[167, {"./utils/verifier":166,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var verifier = require('./utils/verifier');

var Verified =
/*#__PURE__*/
function () {
  /**
   * Please use **box.verified** to get the instance of this class
   */
  function Verified(box) {
    (0, _classCallCheck2["default"])(this, Verified);
    this._box = box;
    this._did = box._3id.muportDID;
  }

  (0, _createClass2["default"])(Verified, [{
    key: "_addVerifiedPublicAccount",
    value: function () {
      var _addVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context.sent;
                _context.next = 5;
                return this._box["public"].set('proof_' + key, proof);

              case 5:
                return _context.abrupt("return", account);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _addVerifiedPublicAccount(_x, _x2, _x3) {
        return _addVerifiedPublicAccount2.apply(this, arguments);
      }

      return _addVerifiedPublicAccount;
    }()
  }, {
    key: "_getVerifiedPublicAccount",
    value: function () {
      var _getVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._box["public"].get('proof_' + key);

              case 2:
                proof = _context2.sent;
                return _context2.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getVerifiedPublicAccount(_x4, _x5) {
        return _getVerifiedPublicAccount2.apply(this, arguments);
      }

      return _getVerifiedPublicAccount;
    }()
  }, {
    key: "_addVerifiedPrivateAccount",
    value: function () {
      var _addVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context3.sent;
                _context3.next = 5;
                return this._box["private"].set('proof_' + key, proof);

              case 5:
                return _context3.abrupt("return", account);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _addVerifiedPrivateAccount(_x6, _x7, _x8) {
        return _addVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _addVerifiedPrivateAccount;
    }()
  }, {
    key: "_getVerifiedPrivateAccount",
    value: function () {
      var _getVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._box["private"].get('proof_' + key);

              case 2:
                proof = _context4.sent;
                return _context4.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getVerifiedPrivateAccount(_x9, _x10) {
        return _getVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _getVerifiedPrivateAccount;
    }()
    /**
     * Returns the verified DID of the user
     *
     * @return    {String}                            The DID of the user
     */

  }, {
    key: "DID",
    value: function () {
      var _DID = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this._did);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function DID() {
        return _DID.apply(this, arguments);
      }

      return DID;
    }()
    /**
     * Verifies that the user has a valid github account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "github",
    value: function () {
      var _github = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this._getVerifiedPublicAccount('github', verifier.verifyGithub));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function github() {
        return _github.apply(this, arguments);
      }

      return github;
    }()
    /**
     * Adds a github verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {Object}            gistUrl         URL of the proof
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "addGithub",
    value: function () {
      var _addGithub = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(gistUrl) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this._addVerifiedPublicAccount('github', gistUrl, verifier.verifyGithub));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addGithub(_x11) {
        return _addGithub.apply(this, arguments);
      }

      return addGithub;
    }()
    /**
     * Verifies that the user has a valid twitter account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "twitter",
    value: function () {
      var _twitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this._getVerifiedPublicAccount('twitter', verifier.verifyTwitter));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function twitter() {
        return _twitter.apply(this, arguments);
      }

      return twitter;
    }()
    /**
     * Adds a twitter verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of a twitter username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addTwitter",
    value: function () {
      var _addTwitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(claim) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this._addVerifiedPublicAccount('twitter', claim, verifier.verifyTwitter));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function addTwitter(_x12) {
        return _addTwitter.apply(this, arguments);
      }

      return addTwitter;
    }()
    /**
    * Verifies that the user has a verified email account
    * Throws an error otherwise.
    *
    * @return    {Object}                            Object containing username, proof, and the verifier
    */

  }, {
    key: "email",
    value: function () {
      var _email = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this._getVerifiedPrivateAccount('email', verifier.verifyEmail));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function email() {
        return _email.apply(this, arguments);
      }

      return email;
    }()
    /**
     * Adds an email verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of an email username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addEmail",
    value: function () {
      var _addEmail = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(claim) {
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this._addVerifiedPrivateAccount('email', claim, verifier.verifyEmail));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function addEmail(_x13) {
        return _addEmail.apply(this, arguments);
      }

      return addEmail;
    }()
  }]);
  return Verified;
}();

module.exports = Verified;
//# sourceMappingURL=node_modules/3box/lib/verified.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/verified.js",}],
[164, {"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"did-jwt":168}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * A module to verify & validate claims
 *
 * @name idUtils
 * @memberof Box
 */
var didJWT = require('did-jwt');

var DID_MUPORT_PREFIX = 'did:muport:';
module.exports = {
  /**
   * Check whether a string is a muport did or not
   *
   * @memberOf Box.idUtils
   * @param   {String}     address  A string containing a user profile address
   * @return  {*|boolean}           Whether the address is a muport did or not
   */
  isMuportDID: function isMuportDID(address) {
    return address.startsWith(DID_MUPORT_PREFIX);
  },

  /**
   * Check whether a string is a valid claim or not
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the audience of the JWT
   * @return {Promise<boolean>}                   whether the parameter is an actual claim
   */
  isClaim: function () {
    var _isClaim = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(claim) {
      var opts,
          _args = arguments;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.prev = 1;
              _context.next = 4;
              return didJWT.decodeJWT(claim, opts);

            case 4:
              return _context.abrupt("return", true);

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              return _context.abrupt("return", false);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 7]]);
    }));

    function isClaim(_x) {
      return _isClaim.apply(this, arguments);
    }

    return isClaim;
  }(),

  /**
   * Verify a claim and return its content.
   * See https://github.com/uport-project/did-jwt/ for more details.
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the JWT's audience
   * @return {Object}                             The validated claim
   */
  verifyClaim: didJWT.verifyJWT
};
//# sourceMappingURL=node_modules/3box/lib/utils/id.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/utils/id.js",}],
[2768, {"./src/access-controllers":2771}, function (require, module, exports) {
const AccessControllers = require('./src/access-controllers')
module.exports = AccessControllers

//# sourceMappingURL=node_modules/orbit-db-access-controllers/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/orbit-db-access-controllers/index.js",}],
[161, {"./keyValueStore":159,"./utils/index":165,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/get":182,"@babel/runtime/helpers/getPrototypeOf":183,"@babel/runtime/helpers/inherits":184,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/possibleConstructorReturn":197,"@babel/runtime/regenerator":206}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var KeyValueStore = require('./keyValueStore');

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var ProfileStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(ProfileStore, _KeyValueStore);

  function ProfileStore(orbitdb, name, linkProfile, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, ProfileStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ProfileStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this._linkProfile = linkProfile;
    return _this;
  }

  (0, _createClass2["default"])(ProfileStore, [{
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, value) {
        var opts,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                throwIfUndefined(key, 'key'); // if this is the noLink call we shouldn't call _linkProfile.

                if (opts.noLink) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return this._linkProfile();

              case 5:
                return _context.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "set", this).call(this, key, value));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function set(_x, _x2) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(keys, values) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                _context2.next = 3;
                return this._linkProfile();

              case 3:
                return _context2.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "setMultiple", this).call(this, keys, values));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setMultiple(_x3, _x4) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }]);
  return ProfileStore;
}(KeyValueStore);

module.exports = ProfileStore;
//# sourceMappingURL=node_modules/3box/lib/publicStore.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/publicStore.js",}],
[149, {"./legacyIpfs3boxAccessController":150,"./moderatorAccessController":151,"./odbIdentityProvider":152,"./threadAccessController":153}, function (require, module, exports) {
const OdbIdentityProvider = require('./odbIdentityProvider')
const ModeratorAccessController = require('./moderatorAccessController')
const ThreadAccessController = require('./threadAccessController')
const LegacyIPFS3BoxAccessController = require('./legacyIpfs3boxAccessController')

module.exports = { OdbIdentityProvider, ModeratorAccessController, ThreadAccessController, LegacyIPFS3BoxAccessController  }

//# sourceMappingURL=node_modules/3box-orbitdb-plugins/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box-orbitdb-plugins/src/index.js",}],
[2835, {"./db-manifest":2836,"./exchange-heads":2837,"./orbit-db-address":2838,"./utils":2839,"logplease":2658,"orbit-db-access-controllers":2768,"orbit-db-cache":2780,"orbit-db-counterstore":2782,"orbit-db-docstore":2785,"orbit-db-eventstore":2787,"orbit-db-feedstore":2789,"orbit-db-identity-provider":2790,"orbit-db-keystore":2797,"orbit-db-kvstore":2827,"orbit-db-pubsub":2828,"path":2873}, function (require, module, exports) {
'use strict'

const path = require('path')
const EventStore = require('orbit-db-eventstore')
const FeedStore = require('orbit-db-feedstore')
const KeyValueStore = require('orbit-db-kvstore')
const CounterStore = require('orbit-db-counterstore')
const DocumentStore = require('orbit-db-docstore')
const Pubsub = require('orbit-db-pubsub')
const Cache = require('orbit-db-cache')
const Keystore = require('orbit-db-keystore')
const Identities = require('orbit-db-identity-provider')
let AccessControllers = require('orbit-db-access-controllers')
const OrbitDBAddress = require('./orbit-db-address')
const createDBManifest = require('./db-manifest')
const exchangeHeads = require('./exchange-heads')
const { isDefined, io } = require('./utils')

const Logger = require('logplease')
const logger = Logger.create("orbit-db")
Logger.setLogLevel('ERROR')

// Mapping for 'database type' -> Class
let databaseTypes = {
  'counter': CounterStore,
  'eventlog': EventStore,
  'feed': FeedStore,
  'docstore': DocumentStore,
  'keyvalue': KeyValueStore,
}

  class OrbitDB {
  constructor(ipfs, identity, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    if (!isDefined(identity))
      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    this._ipfs = ipfs
    this.identity = identity
    this.id = options.peerId
    this._pubsub = options && options.broker
      ? new options.broker(this._ipfs)
      : new Pubsub(this._ipfs, this.id)
    this.directory = options.directory || './orbitdb'
    this.keystore = options.keystore
    this.cache = options.cache || Cache
    this.stores = {}
    this._directConnections = {}
    // AccessControllers module can be passed in to enable
    // testing with orbit-db-access-controller
    AccessControllers = options.AccessControllers || AccessControllers
  }

  static async createInstance (ipfs, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    const { id } = await ipfs.id()
    const directory = options.directory || './orbitdb'
    const keystore = options.keystore || Keystore.create(path.join(directory, id, '/keystore'))

    const identity = options.identity || await Identities.createIdentity({
      id: options.id || id,
      keystore: keystore,
    })
    options = Object.assign({}, options, {
      peerId: id ,
      directory: directory,
      keystore: keystore
    })
    const orbitdb = new OrbitDB(ipfs, identity, options)
    return orbitdb
  }

  /* Databases */
  async feed (address, options = {}) {
    options = Object.assign({ create: true, type: 'feed' }, options)
    return this.open(address, options)
  }

  async log (address, options = {}) {
    options = Object.assign({ create: true, type: 'eventlog' }, options)
    return this.open(address, options)
  }

  async eventlog (address, options = {}) {
    return this.log(address, options)
  }

  async keyvalue (address, options = {}) {
    options = Object.assign({ create: true, type: 'keyvalue' }, options)
    return this.open(address, options)
  }

  async kvstore (address, options = {}) {
    return this.keyvalue(address, options)
  }

  async counter (address, options = {}) {
    options = Object.assign({ create: true, type: 'counter' }, options)
    return this.open(address, options)
  }

  async docs (address, options = {}) {
    options = Object.assign({ create: true, type: 'docstore' }, options)
    return this.open(address, options)
  }

  async docstore (address, options = {}) {
    return this.docs(address, options)
  }

  async disconnect () {
    //close Keystore
    if (this.keystore.close)
      await this.keystore.close()

    // Close all open databases
    const databases = Object.values(this.stores)
    for (let db of databases) {
      await db.close()
      delete this.stores[db.address.toString()]
    }

    // Close a direct connection and remove it from internal state
    const removeDirectConnect = e => {
      this._directConnections[e].close()
      delete this._directConnections[e]
    }

    // Close all direct connections to peers
    Object.keys(this._directConnections).forEach(removeDirectConnect)

    // Disconnect from pubsub
    if (this._pubsub) {
      await this._pubsub.disconnect()
    }

    // Remove all databases from the state
    this.stores = {}
  }

  // Alias for disconnect()
  async stop () {
    await this.disconnect()
  }

  /* Private methods */
  async _createStore (type, address, options) {
    // Get the type -> class mapping
    const Store = databaseTypes[type]

    if (!Store)
      throw new Error(`Invalid database type '${type}'`)

    let accessController
    if (options.accessControllerAddress) {
      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)
    }

    const cache = await this._loadCache(this.directory, address)

    const opts = Object.assign({ replicate: true }, options, {
      accessController: accessController,
      keystore: this.keystore,
      cache: cache,
      onClose: this._onClose.bind(this),
    })
    const identity = options.identity || this.identity

    const store = new Store(this._ipfs, identity, address, opts)
    store.events.on('write', this._onWrite.bind(this))
    // ID of the store is the address as a string
    const addr = address.toString()
    this.stores[addr] = store

    // Subscribe to pubsub to get updates from peers,
    // this is what hooks us into the message propagation layer
    // and the p2p network
    if(opts.replicate && this._pubsub)
      this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this))

    return store
  }

  // Callback for local writes to the database. We the update to pubsub.
  _onWrite (address, entry, heads) {
    if(!heads) throw new Error("'heads' not defined")
    if(this._pubsub) this._pubsub.publish(address, heads)
  }

  // Callback for receiving a message from the network
  async _onMessage (address, heads) {
    const store = this.stores[address]
    try {
      logger.debug(`Received ${heads.length} heads for '${address}':\n`, JSON.stringify(heads.map(e => e.hash), null, 2))
      if (store && heads && heads.length > 0) {
        await store.sync(heads)
      }
    } catch (e) {
      logger.error(e)
    }
  }

  // Callback for when a peer connected to a database
  async _onPeerConnected (address, peer) {
    logger.debug(`New peer '${peer}' connected to '${address}'`)

    const getStore = address => this.stores[address]
    const getDirectConnection = peer => this._directConnections[peer]
    const onChannelCreated = channel => this._directConnections[channel._receiverID] = channel
    const onMessage = (address, heads) => this._onMessage(address, heads)

    const channel = await exchangeHeads(
      this._ipfs,
      address,
      peer,
      getStore,
      getDirectConnection,
      onMessage,
      onChannelCreated
    )

    if (getStore(address))
      getStore(address).events.emit('peer', peer)
  }

  // Callback when database was closed
  async _onClose (address) {
    logger.debug(`Close ${address}`)

    // Unsubscribe from pubsub
    if (this._pubsub) {
      await this._pubsub.unsubscribe(address)
    }

    delete this.stores[address]
  }

  async _determineAddress(name, type, options = {}) {
    if (!OrbitDB.isValidType(type))
      throw new Error(`Invalid database type '${type}'`)

    if (OrbitDBAddress.isValid(name))
      throw new Error(`Given database name is an address. Please give only the name of the database!`)

    // Create an AccessController, use IPFS AC as the default
    options.accessController = Object.assign({}, { name: name , type: 'ipfs' }, options.accessController)
    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController  || {})

    // Save the manifest to IPFS
    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)

    // Create the database address
    return OrbitDBAddress.parse(path.join('/orbitdb', manifestHash, name))
  }

  /* Create and Open databases */

  /*
    options = {
      accessController: { write: [] } // array of keys that can write to this database
      directory: './orbitdb', // directory in which to place the database files
      overwrite: false, // whether we should overwrite the existing database if it exists
    }
  */
  async create (name, type, options = {}) {
    logger.debug(`create()`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Creating database '${name}' as ${type} in '${directory}'`)

    // Create the database address
    const dbAddress = await this._determineAddress(name, type, options)

    // Load the locally saved database information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database locally
    const haveDB = await this._haveLocalData(cache, dbAddress)

    if (haveDB && !options.overwrite)
      throw new Error(`Database '${dbAddress}' already exists!`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    logger.debug(`Created database '${dbAddress}'`)

    // Open the database
    return this.open(dbAddress, options)
  }

  async determineAddress(name, type, options = {}) {
    const opts = Object.assign({}, { onlyHash: true }, options)
    return this._determineAddress(name, type, opts)
  }

  /*
      options = {
        localOnly: false // if set to true, throws an error if database can't be found locally
        create: false // whether to create the database
        type: TODO
        overwrite: TODO

      }
   */
  async open (address, options = {}) {
    logger.debug(`open()`)

    options = Object.assign({ localOnly: false, create: false }, options)
    logger.debug(`Open database '${address}'`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Look from '${directory}'`)

    // If address is just the name of database, check the options to crate the database
    if (!OrbitDBAddress.isValid(address)) {
      if (!options.create) {
        throw new Error(`'options.create' set to 'false'. If you want to create a database, set 'options.create' to 'true'.`)
      } else if (options.create && !options.type) {
        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)
      } else {
        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)
        options.overwrite = options.overwrite ? options.overwrite : true
        return this.create(address, options.type, options)
      }
    }

    // Parse the database address
    const dbAddress = OrbitDBAddress.parse(address)

    // Load the locally saved db information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database
    const haveDB = await this._haveLocalData(cache, dbAddress)

    logger.debug((haveDB ? 'Found' : 'Didn\'t find') + ` database '${dbAddress}'`)

    // If we want to try and open the database local-only, throw an error
    // if we don't have the database locally
    if (options.localOnly && !haveDB) {
      logger.warn(`Database '${dbAddress}' doesn't exist!`)
      throw new Error(`Database '${dbAddress}' doesn't exist!`)
    }

    logger.debug(`Loading Manifest for '${dbAddress}'`)

    // Get the database manifest from IPFS
    const manifest = await io.read(this._ipfs, dbAddress.root)
    logger.debug(`Manifest for '${dbAddress}':\n${JSON.stringify(manifest, null, 2)}`)

    // Make sure the type from the manifest matches the type that was given as an option
    if (options.type && manifest.type !== options.type)
      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    // Open the the database
    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController })
    return this._createStore(manifest.type, dbAddress, options)
  }

  // Save the database locally
  async _addManifestToCache (directory, dbAddress) {
    const cache = await this._loadCache(directory, dbAddress)
    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)
    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)
  }

  async _loadCache (directory, dbAddress) {
    let cache
    try {
      cache = await this.cache.load(directory, dbAddress)
    } catch (e) {
      console.log(e)
      logger.error("Couldn't load Cache:", e)
    }

    return cache
  }

  /**
   * Check if we have the database, or part of it, saved locally
   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]
   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]
   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]
   */
  async _haveLocalData (cache, dbAddress) {
    if (!cache) {
      return false
    }
    const data = await cache.get(path.join(dbAddress.toString(), '_manifest'))
    return data !== undefined && data !== null
  }

  /**
   * Returns supported database types as an Array of strings
   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']
   * @return {[Array]} [Supported database types]
   */
  static get databaseTypes () {
    return Object.keys(databaseTypes)
  }

  static isValidType (type) {
    return Object.keys(databaseTypes).includes(type)
  }

  static addDatabaseType (type, store) {
    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)
    databaseTypes[type] = store
  }

  static getDatabaseTypes () {
    return databaseTypes
  }

  static isValidAddress (address) {
    return OrbitDBAddress.isValid(address)
  }

  static parseAddress (address) {
    return OrbitDBAddress.parse(address)
  }
}

module.exports = OrbitDB

//# sourceMappingURL=node_modules/orbit-db/src/OrbitDB.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/orbit-db/src/OrbitDB.js",}],
[2186, {"./boot":2128,"./components":2161,"./config":2185,"./mfs-preload":2196,"./preload":2197,"./runtime/ipld-nodejs":2202,"./runtime/repo-nodejs":2205,"./state":2206,"buffer":1428,"cids":1446,"debug":1565,"events":1429,"ipfs-block-service":1981,"ipld":2227,"is-ipfs":2244,"libp2p-crypto":2352,"merge-options":2666,"multiaddr":2681,"multibase":2689,"multicodec":2692,"multihashes":2698,"multihashing-async":2108,"peer-book":2882,"peer-id":2883,"peer-info":2884}, function (require, module, exports) {
(function (Buffer){
'use strict'

const BlockService = require('ipfs-block-service')
const Ipld = require('ipld')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const crypto = require('libp2p-crypto')
const isIPFS = require('is-ipfs')
const multiaddr = require('multiaddr')
const multihash = require('multihashes')
const PeerBook = require('peer-book')
const multibase = require('multibase')
const multicodec = require('multicodec')
const multihashing = require('multihashing-async')
const CID = require('cids')
const debug = require('debug')
const mergeOptions = require('merge-options')
const EventEmitter = require('events')

const config = require('./config')
const boot = require('./boot')
const components = require('./components')

// replaced by repo-browser when running in the browser
const defaultRepo = require('./runtime/repo-nodejs')
const preload = require('./preload')
const mfsPreload = require('./mfs-preload')
const ipldOptions = require('./runtime/ipld-nodejs')

class IPFS extends EventEmitter {
  constructor (options) {
    super()

    const defaults = {
      init: true,
      start: true,
      EXPERIMENTAL: {},
      preload: {
        enabled: true,
        addresses: [
          '/dnsaddr/node0.preload.ipfs.io/https',
          '/dnsaddr/node1.preload.ipfs.io/https'
        ]
      }
    }

    options = config.validate(options || {})

    this._options = mergeOptions(defaults, options)

    if (options.init === false) {
      this._options.init = false
    }

    if (!(options.start === false)) {
      this._options.start = true
    }

    if (typeof options.repo === 'string' ||
        options.repo === undefined) {
      this._repo = defaultRepo(options.repo)
    } else {
      this._repo = options.repo
    }

    // IPFS utils
    this.log = debug('ipfs')
    this.log.err = debug('ipfs:err')

    // IPFS Core Internals
    // this._repo - assigned above
    this._peerInfoBook = new PeerBook()
    this._peerInfo = undefined
    this._bitswap = undefined
    this._blockService = new BlockService(this._repo)
    this._ipld = new Ipld(ipldOptions(this._blockService, this._options.ipld, this.log))
    this._preload = preload(this)
    this._mfsPreload = mfsPreload(this)
    this._ipns = undefined
    // eslint-disable-next-line no-console
    this._print = this._options.silent ? this.log : console.log

    // IPFS Core exposed components
    //   - for booting up a node
    this.init = components.init(this)
    this.preStart = components.preStart(this)
    this.start = components.start(this)
    this.stop = components.stop(this)
    this.shutdown = this.stop
    this.isOnline = components.isOnline(this)
    //   - interface-ipfs-core defined API
    Object.assign(this, components.filesRegular(this))
    this.version = components.version(this)
    this.id = components.id(this)
    this.repo = components.repo(this)
    this.bootstrap = components.bootstrap(this)
    this.config = components.config(this)
    this.block = components.block(this)
    this.object = components.object(this)
    this.dag = components.dag(this)
    this.files = components.filesMFS(this)
    this.libp2p = null // assigned on start
    this.swarm = components.swarm(this)
    this.name = components.name(this)
    this.bitswap = components.bitswap(this)
    this.pin = components.pin(this)
    this.ping = components.ping(this)
    this.pingPullStream = components.pingPullStream(this)
    this.pingReadableStream = components.pingReadableStream(this)
    this.pubsub = components.pubsub(this)
    this.dht = components.dht(this)
    this.dns = components.dns(this)
    this.key = components.key(this)
    this.stats = components.stats(this)
    this.resolve = components.resolve(this)

    if (this._options.EXPERIMENTAL.pubsub) {
      this.log('EXPERIMENTAL pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.ipnsPubsub) {
      if (!this._options.EXPERIMENTAL.pubsub) {
        this.log('EXPERIMENTAL pubsub is enabled to use IPNS pubsub')
        this._options.EXPERIMENTAL.pubsub = true
      }

      this.log('EXPERIMENTAL IPNS pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.sharding) {
      this.log('EXPERIMENTAL sharding is enabled')
    }

    this.state = require('./state')(this)

    boot(this)
  }
}

module.exports = IPFS

// Note: We need to do this to force browserify to load the Buffer module
const BufferImpl = Buffer
Object.assign(module.exports, { crypto, isIPFS, Buffer: BufferImpl, CID, multiaddr, multibase, multihash, multihashing, multicodec, PeerId, PeerInfo })

module.exports.createNode = (options) => {
  return new IPFS(options)
}

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ipfs/src/core/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ipfs/src/core/index.js",}],
[1872, {}, function (require, module, exports) {
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
Object.defineProperty(exports, "hasOwnProperty", { value: hasOwnProperty });
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;

//# sourceMappingURL=node_modules/fast-json-patch/lib/helpers.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/fast-json-patch/lib/helpers.js",}],
[1870, {"./helpers":1872,"fast-deep-equal":1873}, function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var areEquals = require('fast-deep-equal');
var helpers_1 = require("./helpers");
exports.JsonPatchError = helpers_1.PatchError;
exports.deepClone = helpers_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (key && key.indexOf('~') != -1) {
                    key = helpers_1.unescapePathComponent(key);
                }
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
/**
 * Default export for backwards compat
 */
exports.default = {
    JsonPatchError: exports.JsonPatchError,
    deepClone: exports.deepClone,
    getValueByPointer: getValueByPointer,
    applyOperation: applyOperation,
    applyPatch: applyPatch,
    applyReducer: applyReducer,
    validator: validator,
    validate: validate
};

//# sourceMappingURL=node_modules/fast-json-patch/lib/core.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/fast-json-patch/lib/core.js",}],
[232, {"./cid-util":231,"multibase":210,"multicodec":218,"multihashes":222,"uint8arrays/concat":223,"uint8arrays/equals":224,"uint8arrays/to-string":226}, function (require, module, exports) {
'use strict'

const mh = require('multihashes')
const multibase = require('multibase')
const multicodec = require('multicodec')
const CIDUtil = require('./cid-util')
const uint8ArrayConcat = require('uint8arrays/concat')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayEquals = require('uint8arrays/equals')

const codecs = multicodec.nameToCode
const codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {
  p[codecs[name]] = name
  return p
}, /** @type {Record<CodecCode, CodecName>} */({}))

const symbol = Symbol.for('@ipld/js-cid/CID')

/**
 * @typedef {Object} SerializedCID
 * @property {string} codec
 * @property {number} version
 * @property {Uint8Array} hash
 */
/**
 * @typedef {0|1} CIDVersion
 * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode
 * @typedef {import('multicodec').CodecName} CodecName
 * @typedef {import('multicodec').CodecCode} CodecCode
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 *
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Uint8Array)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {CIDVersion | string | Uint8Array | CID} version
   * @param {string|number} [codec]
   * @param {Uint8Array} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.bytes>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    // We have below three blank field accessors only because
    // otherwise TS will not pick them up if done after assignemnts

    /**
     * The version of the CID.
     *
     * @type {CIDVersion}
     */
    // eslint-disable-next-line no-unused-expressions
    this.version

    /**
     * The codec of the CID.
     *
     * @deprecated
     * @type {CodecName}
     */
    // eslint-disable-next-line no-unused-expressions
    this.codec

    /**
     * The multihash of the CID.
     *
     * @type {Uint8Array}
     */
    // eslint-disable-next-line no-unused-expressions
    this.multihash

    Object.defineProperty(this, symbol, { value: true })
    if (CID.isCID(version)) {
      // version is an exising CID instance
      const cid = /** @type {CID} */(version)
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = cid.multihash
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      // @ts-ignore
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (version instanceof Uint8Array) {
      const v = parseInt(version[0].toString(), 16)
      if (v === 1) {
        // version is a CID Uint8Array
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash Uint8Array, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    this.version = version

    if (typeof codec === 'number') {
      // @ts-ignore
      codec = codecInts[codec]
    }

    this.codec = /** @type {CodecName} */ (codec)

    this.multihash = /** @type {Uint8Array} */ (multihash)

    /**
     * Multibase name as string.
     *
     * @deprecated
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Uint8Array`
   *
   * @returns {Uint8Array}
   *
   */
  get bytes () {
    // @ts-ignore
    let bytes = this._bytes

    if (!bytes) {
      if (this.version === 0) {
        bytes = this.multihash
      } else if (this.version === 1) {
        const codec = multicodec.getCodeVarint(this.codec)
        bytes = uint8ArrayConcat([
          [1], codec, this.multihash
        ], 1 + codec.byteLength + this.multihash.byteLength)
      } else {
        throw new Error('unsupported version')
      }

      // Cache this Uint8Array so it doesn't have to be recreated
      Object.defineProperty(this, '_bytes', { value: bytes })
    }

    return bytes
  }

  /**
   * The prefix of the CID.
   *
   * @returns {Uint8Array}
   */
  get prefix () {
    const codec = multicodec.getCodeVarint(this.codec)
    const multihash = mh.prefix(this.multihash)
    const prefix = uint8ArrayConcat([
      [this.version], codec, multihash
    ], 1 + codec.byteLength + multihash.byteLength)

    return prefix
  }

  /**
   * The codec of the CID in its number form.
   *
   * @returns {CodecCode}
   */
  get code () {
    return codecs[this.codec]
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new CID(1, this.codec, this.multihash, this.multibaseName)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    // @ts-ignore non enumerable cache property
    if (this.string && this.string.length !== 0 && base === this.multibaseName) {
      // @ts-ignore non enumerable cache property
      return this.string
    }
    let str
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = uint8ArrayToString(multibase.encode(base, this.bytes))
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  /**
   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
   *
   * @returns {string}
   */
  [Symbol.for('nodejs.util.inspect.custom')] () {
    return 'CID(' + this.toString() + ')'
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {boolean}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      uint8ArrayEquals(this.multihash, other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other - The other CID.
   * @returns {void}
   */
  static validateCID (other) {
    const errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }

  /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is CID}
   */
  static isCID (value) {
    return value instanceof CID || Boolean(value && value[symbol])
  }
}

CID.codecs = codecs

module.exports = CID

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js",}],
[249, {}, function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js",}],
[3472, {"./decode.js":3470,"./encode.js":3471,"./length.js":3473}, function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

//# sourceMappingURL=node_modules/varint/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/varint/index.js",}],
[3476, {"util":3459}, function (require, module, exports) {
"use strict"

exports.TextEncoder =
  typeof TextEncoder !== "undefined" ? TextEncoder : require("util").TextEncoder

exports.TextDecoder =
  typeof TextDecoder !== "undefined" ? TextDecoder : require("util").TextDecoder

//# sourceMappingURL=node_modules/web-encoding/src/lib.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/web-encoding/src/lib.js",}],
[235, {"./constants":234,"./util":237,"buffer":1428}, function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {import("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js",}],
[2261, {"buffer":1428}, function (require, module, exports) {
(function (global,Buffer){


//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
        ? define(factory) :
        // cf. https://github.com/dankogai/js-base64/issues/119
        (function() {
            // existing version for noConflict()
            const _Base64 = global.Base64;
            const gBase64 = factory();
            gBase64.noConflict = () => {
                global.Base64 = _Base64;
                return gBase64;
            };
            if (global.Meteor) { // Meteor.js
                Base64 = gBase64;
            }
            global.Base64 = gBase64;
        })();
}((typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
        : this
), function() {
    'use strict';

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.1';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};

    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(k => gBase64.Base64[k] = gBase64[k]);
    return gBase64;
}));



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

//# sourceMappingURL=node_modules/js-base64/base64.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/js-base64/base64.js",}],
[243, {"./base-table":242}, function (require, module, exports) {
'use strict'

/** @typedef {import('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js",}],
[245, {"./base-table":242}, function (require, module, exports) {
'use strict'

/** @typedef {import('./generated-types').CodecName} CodecName */
/** @typedef {import('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js",}],
[246, {"./base-table":242}, function (require, module, exports) {
'use strict'

/** @typedef {import('./generated-types').CodecName} CodecName */
/** @typedef {import('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js",}],
[248, {"./base-table":242,"./util":247}, function (require, module, exports) {
'use strict'

/** @typedef {import('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js",}],
[251, {}, function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js",}],
[240, {"./decode.js":238,"./encode.js":239,"./length.js":241}, function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js",}],
[247, {"uint8arrays/from-string":252,"uint8arrays/to-string":257,"varint":240}, function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

//# sourceMappingURL=node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js",}],
[1477, {}, function (require, module, exports) {
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

//# sourceMappingURL=node_modules/crypt/crypt.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/crypt/crypt.js",}],
[1444, {}, function (require, module, exports) {
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

//# sourceMappingURL=node_modules/charenc/charenc.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/charenc/charenc.js",}],
[1465, {}, function (require, module, exports) {
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  if (isBuffer(val)) return 'buffer';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val);

  return typeof val;
};

// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js
function isBuffer(obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

//# sourceMappingURL=node_modules/component-type/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/component-type/index.js",}],
[2260, {}, function (require, module, exports) {

/**
 * Join `arr` with the trailing `str` defaulting to "and",
 * and `sep` string defaulting to ", ".
 *
 * @param {Array} arr
 * @param {String} str
 * @param {String} sep
 * @return {String}
 * @api public
 */

module.exports = function(arr, str, sep){
  str = str || 'and';
  sep = sep || ', ';

  if (arr.length < 2) return arr[0] || '';

  var oxford = str.slice(0, 2) === sep;

  if (!oxford) {
    str = ' ' + str;
  } else if (arr.length == 2) {
    str = str.slice(1);
  }

  return arr.slice(0, -1).join(sep) + str + ' ' + arr[arr.length - 1];
};

//# sourceMappingURL=node_modules/join-component/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/join-component/index.js",}],
[1177, {"is-retry-allowed":2250}, function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkError = isNetworkError;
exports.isRetryableError = isRetryableError;
exports.isSafeRequestError = isSafeRequestError;
exports.isIdempotentRequestError = isIdempotentRequestError;
exports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
exports.exponentialDelay = exponentialDelay;
exports.default = axiosRetry;

var _isRetryAllowed = require('is-retry-allowed');

var _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var namespace = 'axios-retry';

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkError(error) {
  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests
  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors
}

var SAFE_HTTP_METHODS = ['get', 'head', 'options'];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isRetryableError(error) {
  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isSafeRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isIdempotentRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}

/**
 * @return {number} - delay in milliseconds, always 0
 */
function noDelay() {
  return 0;
}

/**
 * @param  {number} [retryNumber=0]
 * @return {number} - delay in milliseconds
 */
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var delay = Math.pow(2, retryNumber) * 100;
  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
  return delay + randomSum;
}

/**
 * Initializes and returns the retry state for the given request/config
 * @param  {AxiosRequestConfig} config
 * @return {Object}
 */
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}

/**
 * Returns the axios-retry options for the current request
 * @param  {AxiosRequestConfig} config
 * @param  {AxiosRetryConfig} defaultOptions
 * @return {AxiosRetryConfig}
 */
function getRequestOptions(config, defaultOptions) {
  return Object.assign({}, defaultOptions, config[namespace]);
}

/**
 * @param  {Axios} axios
 * @param  {AxiosRequestConfig} config
 */
function fixConfig(axios, config) {
  if (axios.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues
 *
 * @example
 *
 * import axios from 'axios';
 *
 * axiosRetry(axios, { retries: 3 });
 *
 * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Exponential back-off retry delay between requests
 * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});
 *
 * // Custom retry delay
 * axiosRetry(axios, { retryDelay : (retryCount) => {
 *   return retryCount * 1000;
 * }});
 *
 * // Also works with custom axios instances
 * const client = axios.create({ baseURL: 'http://example.com' });
 * axiosRetry(client, { retries: 3 });
 *
 * client.get('/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Allows request-specific configuration
 * client
 *   .get('/test', {
 *     'axios-retry': {
 *       retries: 0
 *     }
 *   })
 *   .catch(error => { // The first request fails
 *     error !== undefined
 *   });
 *
 * @param {Axios} axios An axios instance (the axios object or one created from axios.create)
 * @param {Object} [defaultOptions]
 * @param {number} [defaultOptions.retries=3] Number of retries
 * @param {boolean} [defaultOptions.shouldResetTimeout=false]
 *        Defines if the timeout should be reset between retries
 * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]
 *        A function to determine if the error can be retried
 * @param {Function} [defaultOptions.retryDelay=noDelay]
 *        A function to determine the delay between retry requests
 */
function axiosRetry(axios, defaultOptions) {
  axios.interceptors.request.use(function (config) {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });

  axios.interceptors.response.use(null, function (error) {
    var config = error.config;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(error);
    }

    var _getRequestOptions = getRequestOptions(config, defaultOptions),
        _getRequestOptions$re = _getRequestOptions.retries,
        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,
        _getRequestOptions$re2 = _getRequestOptions.retryCondition,
        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,
        _getRequestOptions$re3 = _getRequestOptions.retryDelay,
        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,
        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,
        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;

    var currentState = getCurrentState(config);

    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;

    if (shouldRetry) {
      currentState.retryCount += 1;
      var delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
        var lastRequestDuration = Date.now() - currentState.lastRequestTime;
        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)
        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
      }

      config.transformRequest = [function (data) {
        return data;
      }];

      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve(axios(config));
        }, delay);
      });
    }

    return Promise.reject(error);
  });
}

// Compatibility with CommonJS
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/axios-retry/lib/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/axios-retry/lib/index.js",}],
[1180, {"./cancel/Cancel":1181,"./cancel/CancelToken":1182,"./cancel/isCancel":1183,"./core/Axios":1184,"./core/mergeConfig":1190,"./defaults":1193,"./helpers/bind":1194,"./helpers/isAxiosError":1199,"./helpers/spread":1203,"./utils":1204}, function (require, module, exports) {
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

//# sourceMappingURL=node_modules/axios/lib/axios.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/axios/lib/axios.js",}],
[1818, {"./bytes":1819,"./hash":1821,"./secp256k1v3-adapter":1824,"assert":1095,"bn.js":1385,"buffer":1428,"ethjs-util":1828}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns a zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
};
/**
 * Checks if a given address is a zero address.
 */
exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details, consult EIP-1191.
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
};
/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium).
 */
exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    pubKey = bytes_1.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }
    assert(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js",}],
[1827, {"./bytes":1819,"./hash":1821,"./secp256k1v3-adapter":1824,"bn.js":1385,"buffer":1428}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns the ECDSA signature of a message hash.
 */
exports.ecsign = function (msgHash, privateKey, chainId) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var recovery = sig.recovery;
    var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,
    };
    return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    // NOTE: with potential introduction of chainId this might need to be updated
    if (buf.length !== 65) {
        throw new Error('Invalid signature length');
    }
    var v = buf[64];
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64),
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new BN(r);
    var sBN = new BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v, chainId) {
    return chainId ? v - (2 * chainId + 35) : v - 27;
}
function isValidSigRecovery(recovery) {
    return recovery === 0 || recovery === 1;
}

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js",}],
[1819, {"bn.js":1385,"buffer":1428,"ethjs-util":1828}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */
exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) { right = false; }
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
exports.setLength = exports.setLengthLeft;
/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */
exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = exports.unpad;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjsUtil.isHexString(v)) {
                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjsUtil.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (BN.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js",}],
[1820, {"bn.js":1385,"buffer":1428}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var BN = require("bn.js");
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js",}],
[1823, {"./bytes":1819,"assert":1095,"buffer":1428,"ethjs-util":1828,"rlp":3166}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.stripZeros(v);
                assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js",}],
[1821, {"./bytes":1819,"buffer":1428,"create-hash":1473,"ethereum-cryptography/keccak":1767,"ethjs-util":1828,"rlp":3166}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
var _a = require('ethereum-cryptography/keccak'), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;
var createHash = require('create-hash');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Creates Keccak hash of the input
 * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
 * it's interpreted as hexadecimal, otherwise as utf8.
 * @param bits The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, 'utf8');
    }
    else {
        a = bytes_1.toBuffer(a);
    }
    if (!bits)
        bits = 256;
    switch (bits) {
        case 224: {
            return keccak224(a);
        }
        case 256: {
            return k256(a);
        }
        case 384: {
            return keccak384(a);
        }
        case 512: {
            return keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates SHA256 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256')
        .update(a)
        .digest();
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160')
        .update(a)
        .digest();
    if (padded === true) {
        return bytes_1.setLength(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js",}],
[1828, {"buffer":1428,"is-hex-prefixed":2241,"strip-hex-prefix":3376}, function (require, module, exports) {
(function (Buffer){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js",}],
[1824, {"./secp256k1v3-lib/der":1825,"./secp256k1v3-lib/index":1826,"buffer":1428,"ethereum-cryptography/secp256k1":1778}, function (require, module, exports) {
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
var secp256k1 = require('ethereum-cryptography/secp256k1');
var secp256k1v3 = require('./secp256k1v3-lib/index');
var der = require('./secp256k1v3-lib/der');
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        return false;
    }
    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
    }
    throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyNegate = function (privateKey) {
    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
        throw new Error('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
    }
    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
        keys.push(Uint8Array.from(publicKey));
    });
    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureNormalize = function (signature) {
    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureExport = function (signature) {
    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImport = function (signature) {
    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
        throw new RangeError('signature length is invalid');
    }
    var sigObj = der.signatureImportLax(signature);
    if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
    }
    return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
exports.sign = function (message, privateKey, options) {
    if (options === null) {
        throw new TypeError('options should be an Object');
    }
    var signOptions = undefined;
    if (options) {
        signOptions = {};
        if (options.data === null) {
            // validate option.data length
            throw new TypeError('options.data should be a Buffer');
        }
        if (options.data) {
            if (options.data.length != 32) {
                throw new RangeError('options.data length is invalid');
            }
            signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
            throw new TypeError('options.noncefn should be a Function');
        }
        if (options.noncefn) {
            // convert option.noncefn function signature
            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                var bufferData = data != null ? Buffer.from(data) : null;
                var buffer = Buffer.from('');
                if (options.noncefn) {
                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                }
                return new Uint8Array(buffer);
            };
        }
    }
    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid,
    };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.recover = function (message, signature, recid, compressed) {
    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError('public key length is invalid');
    }
    // ensure valid privateKey length
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js",}],
[3379, {}, function (require, module, exports) {

module.exports = function createSwappableProxy (initialTarget) {
  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    target = newTarget
  }
}

//# sourceMappingURL=node_modules/swappable-obj-proxy/src/createSwappableProxy.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/swappable-obj-proxy/src/createSwappableProxy.js",}],
[3378, {}, function (require, module, exports) {
const filterNoop = () => true
const internalEvents = ['newListener', 'removeListener']
const externalEventFilter = (name) => !internalEvents.includes(name)

module.exports = function createEventEmitterProxy (initialTarget, opts) {
  // parse options
  opts = opts || {}
  let eventFilter = opts.eventFilter || filterNoop
  if (eventFilter === 'skipInternal') eventFilter = externalEventFilter
  if (typeof eventFilter !== 'function') throw new Error('createEventEmitterProxy - Invalid eventFilter')

  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    const oldTarget = target
    target = newTarget
    // migrate listeners
    oldTarget.eventNames().filter(eventFilter).forEach((name) => {
      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler))
    })
    // remove old
    oldTarget.removeAllListeners()
  }
}

function getRawListeners(eventEmitter, name) {
  // prefer native
  if (eventEmitter.rawListeners) return eventEmitter.rawListeners(name)
  // fallback to lookup against internal object
  let events = eventEmitter._events[name] || []
  // ensure array
  if (!Array.isArray(events)) events = [events]
  // return copy
  return events.slice()
}

//# sourceMappingURL=node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js",}],
[1665, {"./BaseBlockTracker":1662,"./PollingBlockTracker":1663,"./SubscribeBlockTracker":1664}, function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./BaseBlockTracker"), exports);
__exportStar(require("./PollingBlockTracker"), exports);
__exportStar(require("./SubscribeBlockTracker"), exports);
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/eth-block-tracker/dist/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-block-tracker/dist/index.js",}],
[1697, {"json-rpc-engine/src/createAsyncMiddleware":1722}, function (require, module, exports) {
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')

const futureBlockRefRequests = ['eth_getTransactionByHash', 'eth_getTransactionReceipt']

module.exports = createBlockTrackerInspectorMiddleware

// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware ({ blockTracker }) {
  return createAsyncMiddleware(async (req, res, next) => {
    if (!futureBlockRefRequests.includes(req.method)) return next()
    await next()
    // abort if no result or no block number
    if (!res.result || !res.result.blockNumber) return
    // if number is higher, suggest block-tracker check for a new block
    const blockNumber = Number.parseInt(res.result.blockNumber, 16)
    const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16)
    if (blockNumber > currentBlockNumber) await blockTracker.checkForLatestBlock()
  })
}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/block-tracker-inspector.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/block-tracker-inspector.js",}],
[1734, {"./providerFromEngine":1733,"json-rpc-engine":1724}, function (require, module, exports) {
const JsonRpcEngine = require('json-rpc-engine')
const providerFromEngine = require('./providerFromEngine')

module.exports = providerFromMiddleware

function providerFromMiddleware(middleware) {
  const engine = new JsonRpcEngine()
  engine.push(middleware)
  const provider = providerFromEngine(engine)
  return provider
}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/providerFromMiddleware.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/providerFromMiddleware.js",}],
[1695, {"./cache-utils":1698,"json-rpc-engine/src/createAsyncMiddleware":1722}, function (require, module, exports) {
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const blockTagParamIndex = require('./cache-utils').blockTagParamIndex

module.exports = createBlockRefRewriteMiddleware

function createBlockRefRewriteMiddleware (opts = {}) {
  const { blockTracker } = opts
  if (!blockTracker) {
    throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.')
  }

  return createAsyncMiddleware(async (req, res, next) => {
    const blockRefIndex = blockTagParamIndex(req)
    // skip if method does not include blockRef
    if (blockRefIndex === undefined) return next()
    // skip if not "latest"
    let blockRef = req.params[blockRefIndex]
    // omitted blockRef implies "latest"
    if (blockRef === undefined) blockRef = 'latest'
    if (blockRef !== 'latest') return next()
    // rewrite blockRef to block-tracker's block number
    const latestBlockNumber = await blockTracker.getLatestBlock()
    req.params[blockRefIndex] = latestBlockNumber
    next()
  })

}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/block-ref-rewrite.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/block-ref-rewrite.js",}],
[1696, {"./cache-utils":1698,"clone":1450,"json-rpc-engine/src/createAsyncMiddleware":1722,"pify":1731}, function (require, module, exports) {
const pify = require('pify')
const clone = require('clone')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const blockTagParamIndex = require('./cache-utils').blockTagParamIndex

module.exports = createBlockRefMiddleware

function createBlockRefMiddleware (opts = {}) {
  const { provider, blockTracker } = opts
  if (!provider) throw Error('BlockRefMiddleware - mandatory "provider" option is missing.')
  if (!blockTracker) throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.')

  return createAsyncMiddleware(async (req, res, next) => {
    const blockRefIndex = blockTagParamIndex(req)
    // skip if method does not include blockRef
    if (blockRefIndex === undefined) return next()
    // skip if not "latest"
    let blockRef = req.params[blockRefIndex]
    // omitted blockRef implies "latest"
    if (blockRef === undefined) blockRef = 'latest'
    if (blockRef !== 'latest') return next()
    // lookup latest block
    const latestBlockNumber = await blockTracker.getLatestBlock()
    // create child request with specific block-ref
    const childRequest = clone(req)
    childRequest.params[blockRefIndex] = latestBlockNumber
    // perform child request
    const childRes = await pify(provider.sendAsync).call(provider, childRequest)
    // copy child response onto original response
    res.result = childRes.result
    res.error = childRes.error
  })

}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/block-ref.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/block-ref.js",}],
[1735, {"./cache-utils":1698,"clone":1450,"json-rpc-engine/src/createAsyncMiddleware":1722,"pify":1731}, function (require, module, exports) {
const clone = require('clone')
const pify = require('pify')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const blockTagParamIndex = require('./cache-utils').blockTagParamIndex

//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//

module.exports = createRetryOnEmptyMiddleware

// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e']

function createRetryOnEmptyMiddleware (opts = {}) {
  const { provider, blockTracker } = opts
  if (!provider) throw Error('BlockRefRewriteMiddleware - mandatory "provider" option is missing.')
  if (!blockTracker) throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.')

  return createAsyncMiddleware(async (req, res, next) => {
    const blockRefIndex = blockTagParamIndex(req)
    // skip if method does not include blockRef
    if (blockRefIndex === undefined) return next()
    // skip if not exact block references
    let blockRef = req.params[blockRefIndex]
    // omitted blockRef implies "latest"
    if (blockRef === undefined) blockRef = 'latest'
    // skip if non-number block reference
    if (['latest', 'pending'].includes(blockRef)) return next()
    // skip if block refernce is not a valid number
    const blockRefNumber = Number.parseInt(blockRef.slice(2), 16)
    if (Number.isNaN(blockRefNumber)) return next()
    // lookup latest block
    const latestBlockNumberHex = await blockTracker.getLatestBlock()
    const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16)
    // skip if request block number is higher than current
    if (blockRefNumber > latestBlockNumber) return next()
    // create child request with specific block-ref
    const childRequest = clone(req)
    // attempt child request until non-empty response is received
    const childResponse = await retry(10, async () => {
      const attemptResponse = await pify(provider.sendAsync).call(provider, childRequest)
      // verify result
      if (emptyValues.includes(attemptResponse.result)) {
        throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`)
      }
      return attemptResponse
    })
    // copy child response onto original response
    res.result = childResponse.result
    res.error = childResponse.error
  })

}

async function retry(maxRetries, asyncFn) {
  for (let index = 0; index < maxRetries; index++) {
    try {
      return await asyncFn()
    } catch (err) {
      await timeout(1000)
    }
  }
  throw new Error('BlockReEmitMiddleware - retries exhausted')
}

function timeout(duration) {
  return new Promise(resolve => setTimeout(resolve, duration))
}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/retryOnEmpty.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/retryOnEmpty.js",}],
[69, {"../../../../../shared/constants/app":3591}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

/**
 * This RPC method is called by the inpage provider whenever it detects the
 * accessing of a non-existent property on our window.web3 shim.
 * We collect this data to understand which sites are breaking due to the
 * removal of our window.web3.
 */
const logWeb3ShimUsage = {
  methodNames: [_app.MESSAGE_TYPE.LOG_WEB3_SHIM_USAGE],
  implementation: logWeb3ShimUsageHandler
};
var _default = logWeb3ShimUsage;
/**
 * @typedef {Object} LogWeb3ShimUsageOptions
 * @property {Function} sendMetrics - A function that registers a metrics event.
 * @property {Function} getWeb3ShimUsageState - A function that gets web3 shim
 * usage state for the given origin.
 * @property {Function} setWeb3ShimUsageRecorded - A function that records web3 shim
 * usage for a particular origin.
 */

/**
 * @param {import('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {import('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {LogWeb3ShimUsageOptions} options
 */

exports.default = _default;

function logWeb3ShimUsageHandler(req, res, _next, end, {
  sendMetrics,
  getWeb3ShimUsageState,
  setWeb3ShimUsageRecorded
}) {
  const {
    origin
  } = req;

  if (getWeb3ShimUsageState(origin) === undefined) {
    setWeb3ShimUsageRecorded(origin);
    sendMetrics({
      event: `Website Accessed window.web3 Shim`,
      category: 'inpage_provider',
      referrer: {
        url: origin
      }
    }, {
      excludeMetaMetricsId: true
    });
  }

  res.result = true;
  return end();
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js",}],
[71, {"../../../../../shared/constants/app":3591}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

const watchAsset = {
  methodNames: [_app.MESSAGE_TYPE.WATCH_ASSET, _app.MESSAGE_TYPE.WATCH_ASSET_LEGACY],
  implementation: watchAssetHandler
};
var _default = watchAsset;
/**
 * @typedef {Object} WatchAssetOptions
 * @property {Function} handleWatchAssetRequest - The wallet_watchAsset method implementation.
 */

/**
 * @typedef {Object} WatchAssetParam
 * @property {string} type - The type of the asset to watch.
 * @property {Object} options - Watch options for the asset.
 */

/**
 * @param {import('json-rpc-engine').JsonRpcRequest<WatchAssetParam>} req - The JSON-RPC request object.
 * @param {import('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {WatchAssetOptions} options
 */

exports.default = _default;

async function watchAssetHandler(req, res, _next, end, {
  handleWatchAssetRequest
}) {
  try {
    const {
      options: asset,
      type
    } = req.params;
    res.result = await handleWatchAssetRequest(asset, type);
    return end();
  } catch (error) {
    return end(error);
  }
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js",}],
[70, {"../../../../../shared/constants/app":3591,"../../../../../shared/constants/network":3595,"../../../../../shared/modules/network.utils":3605,"eth-rpc-errors":1748,"lodash":2646}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/constants/network");

var _network2 = require("../../../../../shared/modules/network.utils");

const switchEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN],
  implementation: switchEthereumChainHandler
};
var _default = switchEthereumChain;
exports.default = _default;

function findExistingNetwork(chainId, findCustomRpcBy) {
  if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
    return {
      chainId,
      ticker: _network.ETH_SYMBOL,
      nickname: _network.NETWORK_TO_NAME_MAP[chainId],
      rpcUrl: _network.CHAIN_ID_TO_RPC_URL_MAP[chainId],
      type: _network.CHAIN_ID_TO_TYPE_MAP[chainId]
    };
  }

  return findCustomRpcBy({
    chainId
  });
}

async function switchEthereumChainHandler(req, res, _next, end, {
  getCurrentChainId,
  findCustomRpcBy,
  setProviderType,
  updateRpcTarget,
  requestUserApproval
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network2.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network2.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  const requestData = findExistingNetwork(_chainId, findCustomRpcBy);

  if (requestData) {
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      res.result = null;
      return end();
    }

    try {
      const approvedRequestData = await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData
      });

      if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
        setProviderType(approvedRequestData.type);
      } else {
        await updateRpcTarget(approvedRequestData);
      }

      res.result = null;
    } catch (error) {
      return end(error);
    }

    return end();
  }

  return end(_ethRpcErrors.ethErrors.provider.custom({
    code: 4902,
    // To-be-standardized "unrecognized chain ID" error
    message: `Unrecognized chain ID "${chainId}". Try adding the chain using ${_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN} first.`
  }));
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js",}],
[66, {"../../../../../shared/constants/app":3591,"../../../../../shared/constants/network":3595,"../../../../../shared/modules/network.utils":3605,"../../../../../shared/modules/rpc.utils":3607,"@babel/runtime/helpers/interopRequireDefault":186,"eth-rpc-errors":1748,"lodash":2646,"valid-url":3465}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _validUrl = _interopRequireDefault(require("valid-url"));

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/modules/network.utils");

var _rpc = require("../../../../../shared/modules/rpc.utils");

var _network2 = require("../../../../../shared/constants/network");

const addEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN],
  implementation: addEthereumChainHandler
};
var _default = addEthereumChain;
exports.default = _default;

async function addEthereumChainHandler(req, res, _next, end, {
  addCustomRpc,
  getCurrentChainId,
  findCustomRpcBy,
  updateRpcTarget,
  requestUserApproval,
  sendMetrics
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId,
    chainName = null,
    blockExplorerUrls = null,
    nativeCurrency = null,
    rpcUrls
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId', 'chainName', 'blockExplorerUrls', 'iconUrls', 'rpcUrls', 'nativeCurrency']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const firstValidRPCUrl = Array.isArray(rpcUrls) ? rpcUrls.find(rpcUrl => _validUrl.default.isHttpsUri(rpcUrl)) : null;
  const firstValidBlockExplorerUrl = blockExplorerUrls !== null && Array.isArray(blockExplorerUrls) ? blockExplorerUrls.find(blockExplorerUrl => _validUrl.default.isHttpsUri(blockExplorerUrl)) : null;

  if (!firstValidRPCUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected an array with at least one valid string HTTPS url 'rpcUrls', Received:\n${rpcUrls}`
    }));
  }

  if (blockExplorerUrls !== null && !firstValidBlockExplorerUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected null or array with at least one valid string HTTPS URL 'blockExplorerUrl'. Received: ${blockExplorerUrls}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  if (_network2.CHAIN_ID_TO_NETWORK_ID_MAP[_chainId]) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `May not specify default MetaMask chain.`
    }));
  }

  const existingNetwork = findCustomRpcBy({
    chainId: _chainId
  });

  if (existingNetwork) {
    // If the network already exists, the request is considered successful
    res.result = null;
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      return end();
    } // Ask the user to switch the network


    try {
      await updateRpcTarget(await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData: {
          rpcUrl: existingNetwork.rpcUrl,
          chainId: existingNetwork.chainId,
          nickname: existingNetwork.nickname,
          ticker: existingNetwork.ticker
        }
      }));
      res.result = null;
    } catch (error) {
      // For the purposes of this method, it does not matter if the user
      // declines to switch the selected network. However, other errors indicate
      // that something is wrong.
      if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
        return end(error);
      }
    }

    return end();
  }

  let endpointChainId;

  try {
    endpointChainId = await (0, _rpc.jsonRpcRequest)(firstValidRPCUrl, 'eth_chainId');
  } catch (err) {
    return end(_ethRpcErrors.ethErrors.rpc.internal({
      message: `Request for method 'eth_chainId on ${firstValidRPCUrl} failed`,
      data: {
        networkErr: err
      }
    }));
  }

  if (_chainId !== endpointChainId) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Chain ID returned by RPC URL ${firstValidRPCUrl} does not match ${_chainId}`,
      data: {
        chainId: endpointChainId
      }
    }));
  }

  if (typeof chainName !== 'string' || !chainName) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected non-empty string 'chainName'. Received:\n${chainName}`
    }));
  }

  const _chainName = chainName.length > 100 ? chainName.substring(0, 100) : chainName;

  if (nativeCurrency !== null) {
    if (typeof nativeCurrency !== 'object' || Array.isArray(nativeCurrency)) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected null or object 'nativeCurrency'. Received:\n${nativeCurrency}`
      }));
    }

    if (nativeCurrency.decimals !== 18) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected the number 18 for 'nativeCurrency.decimals' when 'nativeCurrency' is provided. Received: ${nativeCurrency.decimals}`
      }));
    }

    if (!nativeCurrency.symbol || typeof nativeCurrency.symbol !== 'string') {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected a string 'nativeCurrency.symbol'. Received: ${nativeCurrency.symbol}`
      }));
    }
  }

  const ticker = (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || 'xMONI';

  if (typeof ticker !== 'string' || ticker.length < 2 || ticker.length > 6) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 2-6 character string 'nativeCurrency.symbol'. Received:\n${ticker}`
    }));
  }

  try {
    await addCustomRpc(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN,
      requestData: {
        chainId: _chainId,
        blockExplorerUrl: firstValidBlockExplorerUrl,
        chainName: _chainName,
        rpcUrl: firstValidRPCUrl,
        ticker
      }
    }));
    sendMetrics({
      event: 'Custom Network Added',
      category: 'Network',
      referrer: {
        url: origin
      },
      sensitiveProperties: {
        chain_id: _chainId,
        rpc_url: firstValidRPCUrl,
        network_name: _chainName,
        // Including network to override the default network
        // property included in all events. For RPC type networks
        // the MetaMetrics controller uses the rpcUrl for the network
        // property.
        network: firstValidRPCUrl,
        symbol: ticker,
        block_explorer_url: firstValidBlockExplorerUrl,
        source: 'dapp'
      }
    }); // Once the network has been added, the requested is considered successful

    res.result = null;
  } catch (error) {
    return end(error);
  } // Ask the user to switch the network


  try {
    await updateRpcTarget(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
      requestData: {
        rpcUrl: firstValidRPCUrl,
        chainId: _chainId,
        nickname: _chainName,
        ticker
      }
    }));
  } catch (error) {
    // For the purposes of this method, it does not matter if the user
    // declines to switch the selected network. However, other errors indicate
    // that something is wrong.
    if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
      return end(error);
    }
  }

  return end();
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js",}],
[67, {"../../../../../shared/constants/app":3591,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _app = require("../../../../../shared/constants/app");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This RPC method gets background state relevant to the provider.
 * The background sends RPC notifications on state changes, but the provider
 * first requests state on initialization.
 */
const getProviderState = {
  methodNames: [_app.MESSAGE_TYPE.GET_PROVIDER_STATE],
  implementation: getProviderStateHandler
};
var _default = getProviderState;
/**
 * @typedef {Object} ProviderStateHandlerResult
 * @property {string} chainId - The current chain ID.
 * @property {boolean} isUnlocked - Whether the extension is unlocked or not.
 * @property {string} networkVersion - The current network ID.
 */

/**
 * @typedef {Object} ProviderStateHandlerOptions
 * @property {() => ProviderStateHandlerResult} getProviderState - A function that
 * gets the current provider state.
 */

/**
 * @param {import('json-rpc-engine').JsonRpcRequest<[]>} req - The JSON-RPC request object.
 * @param {import('json-rpc-engine').JsonRpcResponse<ProviderStateHandlerResult>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {ProviderStateHandlerOptions} options
 */

exports.default = _default;

async function getProviderStateHandler(req, res, _next, end, {
  getProviderState: _getProviderState
}) {
  res.result = _objectSpread({}, await _getProviderState(req.origin));
  return end();
}

//# sourceMappingURL=app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js",}],
[1453, {}, function (require, module, exports) {
// Base58 encoding/decoding
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var ALPHABET_MAP = {}
for(var i = 0; i < ALPHABET.length; i++) {
  ALPHABET_MAP[ALPHABET.charAt(i)] = i
}
var BASE = 58

function encode(buffer) {
  if (buffer.length === 0) return ''

  var i, j, digits = [0]
  for (i = 0; i < buffer.length; i++) {
    for (j = 0; j < digits.length; j++) digits[j] <<= 8

    digits[0] += buffer[i]

    var carry = 0
    for (j = 0; j < digits.length; ++j) {
      digits[j] += carry

      carry = (digits[j] / BASE) | 0
      digits[j] %= BASE
    }

    while (carry) {
      digits.push(carry % BASE)

      carry = (carry / BASE) | 0
    }
  }

  // deal with leading zeros
  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0)

  // convert digits to a string
  var stringOutput = ""
  for (var i = digits.length - 1; i >= 0; i--) {
    stringOutput = stringOutput + ALPHABET[digits[i]]
  }
  return stringOutput
}

function decode(string) {
  if (string.length === 0) return []

  var i, j, bytes = [0]
  for (i = 0; i < string.length; i++) {
    var c = string[i]
    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character')

    for (j = 0; j < bytes.length; j++) bytes[j] *= BASE
    bytes[0] += ALPHABET_MAP[c]

    var carry = 0
    for (j = 0; j < bytes.length; ++j) {
      bytes[j] += carry

      carry = bytes[j] >> 8
      bytes[j] &= 0xff
    }

    while (carry) {
      bytes.push(carry & 0xff)

      carry >>= 8
    }
  }

  // deal with leading zeros
  for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0)

  return bytes.reverse()
}

module.exports = {
  encode: encode,
  decode: decode
}

//# sourceMappingURL=node_modules/coinstring/node_modules/bs58/lib/bs58.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/coinstring/node_modules/bs58/lib/bs58.js",}],
[938, {"buffer":1428,"is-hex-prefixed":2241,"strip-hex-prefix":3376}, function (require, module, exports) {
(function (Buffer){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js",}],
[939, {"./lib/api":940,"./lib/keccak":944}, function (require, module, exports) {
'use strict'
module.exports = require('./lib/api')(require('./lib/keccak'))

//# sourceMappingURL=node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js",}],
[3419, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/misc.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/misc.js",}],
[3431, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/params.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/params.js",}],
[3413, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/account.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/account.js",}],
[3433, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/trezor/management.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/trezor/management.js",}],
[3421, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/bitcoin.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/bitcoin.js",}],
[3420, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/binance.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/binance.js",}],
[3422, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/cardano.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/cardano.js",}],
[3423, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/coinInfo.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/coinInfo.js",}],
[3424, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/eos.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/eos.js",}],
[3425, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/ethereum.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/ethereum.js",}],
[3427, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/nem.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/nem.js",}],
[3426, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/lisk.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/lisk.js",}],
[3428, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/ripple.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/ripple.js",}],
[3429, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/stellar.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/stellar.js",}],
[3430, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/networks/tezos.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/networks/tezos.js",}],
[3416, {}, function (require, module, exports) {
"use strict";
//# sourceMappingURL=node_modules/trezor-connect/lib/types/backend/transactions.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/backend/transactions.js",}],
[3417, {"../constants":3398}, function (require, module, exports) {
"use strict";

var _constants = require("../constants");
//# sourceMappingURL=node_modules/trezor-connect/lib/types/events.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/events.js",}],
[3432, {"../../constants":3398}, function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
//# sourceMappingURL=node_modules/trezor-connect/lib/types/trezor/device.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/trezor/device.js",}],
[3415, {"../../constants":3398}, function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
//# sourceMappingURL=node_modules/trezor-connect/lib/types/backend/blockchain.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/backend/blockchain.js",}],
[3414, {"../constants":3398,"./account":3413,"./backend/blockchain":3415,"./events":3417,"./misc":3419,"./networks/binance":3420,"./networks/bitcoin":3421,"./networks/cardano":3422,"./networks/coinInfo":3423,"./networks/eos":3424,"./networks/ethereum":3425,"./networks/lisk":3426,"./networks/nem":3427,"./networks/ripple":3428,"./networks/stellar":3429,"./networks/tezos":3430,"./params":3431,"./trezor/device":3432,"./trezor/management":3433,"./trezor/protobuf":3434,"@babel/runtime/helpers/interopRequireWildcard":187}, function (require, module, exports) {
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var CONSTANTS = _interopRequireWildcard(require("../constants"));

var P = _interopRequireWildcard(require("./params"));

var Device = _interopRequireWildcard(require("./trezor/device"));

var Mgmnt = _interopRequireWildcard(require("./trezor/management"));

var Protobuf = _interopRequireWildcard(require("./trezor/protobuf"));

var Account = _interopRequireWildcard(require("./account"));

var Bitcoin = _interopRequireWildcard(require("./networks/bitcoin"));

var Binance = _interopRequireWildcard(require("./networks/binance"));

var Cardano = _interopRequireWildcard(require("./networks/cardano"));

var CoinInfo = _interopRequireWildcard(require("./networks/coinInfo"));

var EOS = _interopRequireWildcard(require("./networks/eos"));

var Ethereum = _interopRequireWildcard(require("./networks/ethereum"));

var Lisk = _interopRequireWildcard(require("./networks/lisk"));

var NEM = _interopRequireWildcard(require("./networks/nem"));

var Ripple = _interopRequireWildcard(require("./networks/ripple"));

var Stellar = _interopRequireWildcard(require("./networks/stellar"));

var Tezos = _interopRequireWildcard(require("./networks/tezos"));

var Misc = _interopRequireWildcard(require("./misc"));

var Events = _interopRequireWildcard(require("./events"));

var Blockchain = _interopRequireWildcard(require("./backend/blockchain"));
//# sourceMappingURL=node_modules/trezor-connect/lib/types/api.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/types/api.js",}],
[3393, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.FIAT_RATES_UPDATE = exports.NOTIFICATION = exports.BLOCK = exports.CONNECT = exports.ERROR = void 0;
// blockchain events
var ERROR = 'blockchain-error';
exports.ERROR = ERROR;
var CONNECT = 'blockchain-connect';
exports.CONNECT = CONNECT;
var BLOCK = 'blockchain-block';
exports.BLOCK = BLOCK;
var NOTIFICATION = 'blockchain-notification';
exports.NOTIFICATION = NOTIFICATION;
var FIAT_RATES_UPDATE = 'fiat-rates-update';
exports.FIAT_RATES_UPDATE = FIAT_RATES_UPDATE;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/blockchain.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/blockchain.js",}],
[3399, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.TYPES = void 0;
var TYPES = Object.freeze({
  'bitcoin': 'Bitcoin',
  'ethereum': 'Ethereum',
  'eos': 'Eos',
  'nem': 'NEM',
  'stellar': 'Stellar',
  'lisk': 'Lisk',
  'cardano': 'Cardano',
  'ripple': 'Ripple',
  'tezos': 'Tezors',
  'binance': 'Binance'
});
exports.TYPES = TYPES;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/network.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/network.js",}],
[3395, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.UNREADABLE = exports.WAIT_FOR_SELECTION = exports.WORD = exports.PASSPHRASE_ON_DEVICE = exports.PASSPHRASE = exports.PIN = exports.BUTTON = exports.LOADING = exports.USED_ELSEWHERE = exports.RELEASED = exports.ACQUIRED = exports.RELEASE = exports.ACQUIRE = exports.CHANGED = exports.DISCONNECT = exports.CONNECT_UNACQUIRED = exports.CONNECT = void 0;
// device list events
var CONNECT = 'device-connect';
exports.CONNECT = CONNECT;
var CONNECT_UNACQUIRED = 'device-connect_unacquired';
exports.CONNECT_UNACQUIRED = CONNECT_UNACQUIRED;
var DISCONNECT = 'device-disconnect';
exports.DISCONNECT = DISCONNECT;
var CHANGED = 'device-changed';
exports.CHANGED = CHANGED;
var ACQUIRE = 'device-acquire';
exports.ACQUIRE = ACQUIRE;
var RELEASE = 'device-release';
exports.RELEASE = RELEASE;
var ACQUIRED = 'device-acquired';
exports.ACQUIRED = ACQUIRED;
var RELEASED = 'device-released';
exports.RELEASED = RELEASED;
var USED_ELSEWHERE = 'device-used_elsewhere';
exports.USED_ELSEWHERE = USED_ELSEWHERE;
var LOADING = 'device-loading'; // trezor-link events in protobuf format

exports.LOADING = LOADING;
var BUTTON = 'button';
exports.BUTTON = BUTTON;
var PIN = 'pin';
exports.PIN = PIN;
var PASSPHRASE = 'passphrase';
exports.PASSPHRASE = PASSPHRASE;
var PASSPHRASE_ON_DEVICE = 'passphrase_on_device';
exports.PASSPHRASE_ON_DEVICE = PASSPHRASE_ON_DEVICE;
var WORD = 'word'; // custom

exports.WORD = WORD;
var WAIT_FOR_SELECTION = 'device-wait_for_selection'; // this string has different prefix than other constants and it's used as device path

exports.WAIT_FOR_SELECTION = WAIT_FOR_SELECTION;
var UNREADABLE = 'unreadable-device';
exports.UNREADABLE = UNREADABLE;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/device.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/device.js",}],
[3397, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CALL = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from iframe.html inline script before "window.onload" event. This is first message from iframe to window.opener.
var BOOTSTRAP = 'iframe-bootstrap'; // Message from iframe.js to window.opener, called after "window.onload" event. This is second message from iframe to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'iframe-loaded'; // Message from window.opener to iframe.js

exports.LOADED = LOADED;
var INIT = 'iframe-init'; // Error message from iframe.js to window.opener. Could be thrown during iframe initialization process

exports.INIT = INIT;
var ERROR = 'iframe-error'; // Message from window.opener to iframe. Call method

exports.ERROR = ERROR;
var CALL = 'iframe-call';
exports.CALL = CALL;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/iframe.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/iframe.js",}],
[3400, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CLOSE_WINDOW = exports.CANCEL_POPUP_REQUEST = exports.CLOSED = exports.HANDSHAKE = exports.EXTENSION_USB_PERMISSIONS = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from popup.html inline script before "window.onload" event. This is first message from popup to window.opener.
var BOOTSTRAP = 'popup-bootstrap'; // Message from popup.js to window.opener, called after "window.onload" event. This is second message from popup to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'popup-loaded'; // Message from window.opener to popup.js. Send settings to popup. This is first message from window.opener to popup.

exports.LOADED = LOADED;
var INIT = 'popup-init'; // Error message from popup to window.opener. Could be thrown during popup initialization process (POPUP.INIT)

exports.INIT = INIT;
var ERROR = 'popup-error'; // Message to webextensions, opens "trezor-usb-permission.html" within webextension

exports.ERROR = ERROR;
var EXTENSION_USB_PERMISSIONS = 'open-usb-permissions'; // Message called from both [popup > iframe] then [iframe > popup] in this exact order.
// Firstly popup call iframe to resolve popup promise in Core
// Then iframe reacts to POPUP.HANDSHAKE message and sends ConnectSettings, transport information and requested method details back to popup

exports.EXTENSION_USB_PERMISSIONS = EXTENSION_USB_PERMISSIONS;
var HANDSHAKE = 'popup-handshake'; // Event emitted from PopupManager at the end of popup closing process.
// Sent from popup thru window.opener to an iframe because message channel between popup and iframe is no longer available

exports.HANDSHAKE = HANDSHAKE;
var CLOSED = 'popup-closed'; // Message called from iframe to popup, it means that popup will not be needed (example: Blockchain methods are not using popup at all)
// This will close active popup window and/or clear opening process in PopupManager (maybe popup wasn't opened yet)

exports.CLOSED = CLOSED;
var CANCEL_POPUP_REQUEST = 'ui-cancel-popup-request'; // Message called from inline element in popup.html (window.closeWindow), this is used only with webextensions to properly handle popup close event

exports.CANCEL_POPUP_REQUEST = CANCEL_POPUP_REQUEST;
var CLOSE_WINDOW = 'window.close';
exports.CLOSE_WINDOW = CLOSE_WINDOW;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/popup.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/popup.js",}],
[3401, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.START_PENDING = exports.DISABLE_WEBUSB = exports.REQUEST = exports.STREAM = exports.UPDATE = exports.ERROR = exports.START = void 0;
var START = 'transport-start';
exports.START = START;
var ERROR = 'transport-error';
exports.ERROR = ERROR;
var UPDATE = 'transport-update';
exports.UPDATE = UPDATE;
var STREAM = 'transport-stream';
exports.STREAM = STREAM;
var REQUEST = 'transport-request_device';
exports.REQUEST = REQUEST;
var DISABLE_WEBUSB = 'transport-disable_webusb';
exports.DISABLE_WEBUSB = DISABLE_WEBUSB;
var START_PENDING = 'transport-start_pending';
exports.START_PENDING = START_PENDING;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/transport.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/transport.js",}],
[3402, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.IFRAME_FAILURE = exports.ADDRESS_VALIDATION = exports.BUNDLE_PROGRESS = exports.LOGIN_CHALLENGE_RESPONSE = exports.LOGIN_CHALLENGE_REQUEST = exports.CUSTOM_MESSAGE_RESPONSE = exports.CUSTOM_MESSAGE_REQUEST = exports.CHANGE_SETTINGS = exports.RECEIVE_WORD = exports.RECEIVE_FEE = exports.RECEIVE_ACCOUNT = exports.CHANGE_ACCOUNT = exports.RECEIVE_DEVICE = exports.RECEIVE_PASSPHRASE = exports.RECEIVE_PIN = exports.RECEIVE_CONFIRMATION = exports.RECEIVE_PERMISSION = exports.REQUEST_WORD = exports.REQUEST_BUTTON = exports.INSUFFICIENT_FUNDS = exports.UPDATE_CUSTOM_FEE = exports.SELECT_FEE = exports.SELECT_ACCOUNT = exports.SELECT_DEVICE = exports.SET_OPERATION = exports.LOADING = exports.CONNECT = exports.INVALID_PASSPHRASE_ACTION = exports.INVALID_PASSPHRASE = exports.REQUEST_PASSPHRASE_ON_DEVICE = exports.REQUEST_PASSPHRASE = exports.INVALID_PIN = exports.REQUEST_PIN = exports.REQUEST_CONFIRMATION = exports.REQUEST_PERMISSION = exports.CLOSE_UI_WINDOW = exports.REQUEST_UI_WINDOW = exports.DEVICE_NEEDS_BACKUP = exports.FIRMWARE_PROGRESS = exports.FIRMWARE_NOT_INSTALLED = exports.FIRMWARE_NOT_COMPATIBLE = exports.FIRMWARE_NOT_SUPPORTED = exports.FIRMWARE_OUTDATED = exports.FIRMWARE_OLD = exports.SEEDLESS = exports.INITIALIZE = exports.REQUIRE_MODE = exports.NOT_IN_BOOTLOADER = exports.BOOTLOADER = exports.TRANSPORT = void 0;
var TRANSPORT = 'ui-no_transport';
exports.TRANSPORT = TRANSPORT;
var BOOTLOADER = 'ui-device_bootloader_mode';
exports.BOOTLOADER = BOOTLOADER;
var NOT_IN_BOOTLOADER = 'ui-device_not_in_bootloader_mode';
exports.NOT_IN_BOOTLOADER = NOT_IN_BOOTLOADER;
var REQUIRE_MODE = 'ui-device_require_mode';
exports.REQUIRE_MODE = REQUIRE_MODE;
var INITIALIZE = 'ui-device_not_initialized';
exports.INITIALIZE = INITIALIZE;
var SEEDLESS = 'ui-device_seedless';
exports.SEEDLESS = SEEDLESS;
var FIRMWARE_OLD = 'ui-device_firmware_old';
exports.FIRMWARE_OLD = FIRMWARE_OLD;
var FIRMWARE_OUTDATED = 'ui-device_firmware_outdated';
exports.FIRMWARE_OUTDATED = FIRMWARE_OUTDATED;
var FIRMWARE_NOT_SUPPORTED = 'ui-device_firmware_unsupported';
exports.FIRMWARE_NOT_SUPPORTED = FIRMWARE_NOT_SUPPORTED;
var FIRMWARE_NOT_COMPATIBLE = 'ui-device_firmware_not_compatible';
exports.FIRMWARE_NOT_COMPATIBLE = FIRMWARE_NOT_COMPATIBLE;
var FIRMWARE_NOT_INSTALLED = 'ui-device_firmware_not_installed';
exports.FIRMWARE_NOT_INSTALLED = FIRMWARE_NOT_INSTALLED;
var FIRMWARE_PROGRESS = 'ui-firmware-progress';
exports.FIRMWARE_PROGRESS = FIRMWARE_PROGRESS;
var DEVICE_NEEDS_BACKUP = 'ui-device_needs_backup';
exports.DEVICE_NEEDS_BACKUP = DEVICE_NEEDS_BACKUP;
var REQUEST_UI_WINDOW = 'ui-request_window';
exports.REQUEST_UI_WINDOW = REQUEST_UI_WINDOW;
var CLOSE_UI_WINDOW = 'ui-close_window';
exports.CLOSE_UI_WINDOW = CLOSE_UI_WINDOW;
var REQUEST_PERMISSION = 'ui-request_permission';
exports.REQUEST_PERMISSION = REQUEST_PERMISSION;
var REQUEST_CONFIRMATION = 'ui-request_confirmation';
exports.REQUEST_CONFIRMATION = REQUEST_CONFIRMATION;
var REQUEST_PIN = 'ui-request_pin';
exports.REQUEST_PIN = REQUEST_PIN;
var INVALID_PIN = 'ui-invalid_pin';
exports.INVALID_PIN = INVALID_PIN;
var REQUEST_PASSPHRASE = 'ui-request_passphrase';
exports.REQUEST_PASSPHRASE = REQUEST_PASSPHRASE;
var REQUEST_PASSPHRASE_ON_DEVICE = 'ui-request_passphrase_on_device';
exports.REQUEST_PASSPHRASE_ON_DEVICE = REQUEST_PASSPHRASE_ON_DEVICE;
var INVALID_PASSPHRASE = 'ui-invalid_passphrase';
exports.INVALID_PASSPHRASE = INVALID_PASSPHRASE;
var INVALID_PASSPHRASE_ACTION = 'ui-invalid_passphrase_action';
exports.INVALID_PASSPHRASE_ACTION = INVALID_PASSPHRASE_ACTION;
var CONNECT = 'ui-connect';
exports.CONNECT = CONNECT;
var LOADING = 'ui-loading';
exports.LOADING = LOADING;
var SET_OPERATION = 'ui-set_operation';
exports.SET_OPERATION = SET_OPERATION;
var SELECT_DEVICE = 'ui-select_device';
exports.SELECT_DEVICE = SELECT_DEVICE;
var SELECT_ACCOUNT = 'ui-select_account';
exports.SELECT_ACCOUNT = SELECT_ACCOUNT;
var SELECT_FEE = 'ui-select_fee';
exports.SELECT_FEE = SELECT_FEE;
var UPDATE_CUSTOM_FEE = 'ui-update_custom_fee';
exports.UPDATE_CUSTOM_FEE = UPDATE_CUSTOM_FEE;
var INSUFFICIENT_FUNDS = 'ui-insufficient_funds';
exports.INSUFFICIENT_FUNDS = INSUFFICIENT_FUNDS;
var REQUEST_BUTTON = 'ui-button';
exports.REQUEST_BUTTON = REQUEST_BUTTON;
var REQUEST_WORD = 'ui-request_word';
exports.REQUEST_WORD = REQUEST_WORD;
var RECEIVE_PERMISSION = 'ui-receive_permission';
exports.RECEIVE_PERMISSION = RECEIVE_PERMISSION;
var RECEIVE_CONFIRMATION = 'ui-receive_confirmation';
exports.RECEIVE_CONFIRMATION = RECEIVE_CONFIRMATION;
var RECEIVE_PIN = 'ui-receive_pin';
exports.RECEIVE_PIN = RECEIVE_PIN;
var RECEIVE_PASSPHRASE = 'ui-receive_passphrase';
exports.RECEIVE_PASSPHRASE = RECEIVE_PASSPHRASE;
var RECEIVE_DEVICE = 'ui-receive_device';
exports.RECEIVE_DEVICE = RECEIVE_DEVICE;
var CHANGE_ACCOUNT = 'ui-change_account';
exports.CHANGE_ACCOUNT = CHANGE_ACCOUNT;
var RECEIVE_ACCOUNT = 'ui-receive_account';
exports.RECEIVE_ACCOUNT = RECEIVE_ACCOUNT;
var RECEIVE_FEE = 'ui-receive_fee';
exports.RECEIVE_FEE = RECEIVE_FEE;
var RECEIVE_WORD = 'ui-receive_word';
exports.RECEIVE_WORD = RECEIVE_WORD;
var CHANGE_SETTINGS = 'ui-change_settings';
exports.CHANGE_SETTINGS = CHANGE_SETTINGS;
var CUSTOM_MESSAGE_REQUEST = 'ui-custom_request';
exports.CUSTOM_MESSAGE_REQUEST = CUSTOM_MESSAGE_REQUEST;
var CUSTOM_MESSAGE_RESPONSE = 'ui-custom_response';
exports.CUSTOM_MESSAGE_RESPONSE = CUSTOM_MESSAGE_RESPONSE;
var LOGIN_CHALLENGE_REQUEST = 'ui-login_challenge_request';
exports.LOGIN_CHALLENGE_REQUEST = LOGIN_CHALLENGE_REQUEST;
var LOGIN_CHALLENGE_RESPONSE = 'ui-login_challenge_response';
exports.LOGIN_CHALLENGE_RESPONSE = LOGIN_CHALLENGE_RESPONSE;
var BUNDLE_PROGRESS = 'ui-bundle_progress';
exports.BUNDLE_PROGRESS = BUNDLE_PROGRESS;
var ADDRESS_VALIDATION = 'ui-address_validation';
exports.ADDRESS_VALIDATION = ADDRESS_VALIDATION;
var IFRAME_FAILURE = 'ui-iframe_failure';
exports.IFRAME_FAILURE = IFRAME_FAILURE;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/ui.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/ui.js",}],
[3394, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.POOL_RELAY_TYPE = exports.CERTIFICATE_TYPE = exports.ADDRESS_TYPE = exports.NETWORK_IDS = exports.PROTOCOL_MAGICS = void 0;
var PROTOCOL_MAGICS = Object.freeze({
  mainnet: 764824073,
  testnet: 42
});
exports.PROTOCOL_MAGICS = PROTOCOL_MAGICS;
var NETWORK_IDS = Object.freeze({
  mainnet: 1,
  testnet: 0
});
exports.NETWORK_IDS = NETWORK_IDS;
var ADDRESS_TYPE = Object.freeze({
  Base: 0,
  Pointer: 4,
  Enterprise: 6,
  Byron: 8,
  Reward: 14
});
exports.ADDRESS_TYPE = ADDRESS_TYPE;
var CERTIFICATE_TYPE = Object.freeze({
  StakeRegistration: 0,
  StakeDeregistration: 1,
  StakeDelegation: 2,
  StakePoolRegistration: 3
});
exports.CERTIFICATE_TYPE = CERTIFICATE_TYPE;
var POOL_RELAY_TYPE = Object.freeze({
  SingleHostIp: 0,
  SingleHostName: 1,
  MultipleHostName: 2
});
exports.POOL_RELAY_TYPE = POOL_RELAY_TYPE;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/cardano.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/cardano.js",}],
[3396, {"@babel/runtime/helpers/inheritsLoose":185,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/wrapNativeSuper":205}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.WEBUSB_ERROR_MESSAGE = exports.INVALID_PIN_ERROR_MESSAGE = exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = exports.TypedError = exports.TrezorError = exports.ERROR_CODES = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var ERROR_CODES = {
  'Init_NotInitialized': 'TrezorConnect not yet initialized',
  // race condition: call on not initialized Core (usually hot-reloading)
  'Init_AlreadyInitialized': 'TrezorConnect has been already initialized',
  // thrown by .init called multiple times
  'Init_IframeBlocked': 'Iframe blocked',
  // iframe injection blocked (ad-blocker)
  'Init_IframeTimeout': 'Iframe timeout',
  // iframe didn't load in specified time
  'Init_ManifestMissing': 'Manifest not set. Read more at https://github.com/trezor/connect/blob/develop/docs/index.md',
  // manifest is not set
  'Popup_ConnectionMissing': 'Unable to establish connection with iframe',
  // thrown by popup
  'Transport_Missing': 'Transport is missing',
  // no transport available
  'Transport_InvalidProtobuf': '',
  // generic error from transport layer (trezor-link)
  'Method_InvalidPackage': 'This version of trezor-connect is not suitable to work without browser. Use trezor-connect@extended package instead',
  // thrown by node and react-native env while using regular 'web' package
  'Method_InvalidParameter': '',
  // replaced by generic text
  'Method_NotAllowed': 'Method not allowed for this configuration',
  // example: device management in popup mode
  'Method_PermissionsNotGranted': 'Permissions not granted',
  // permission/confirmation not granted in popup
  'Method_Cancel': 'Cancelled',
  // permission/confirmation not granted in popup OR .cancel() custom error
  'Method_Interrupted': 'Popup closed',
  // interruption: popup closed
  'Method_UnknownCoin': 'Coin not found',
  // coin definition not found
  'Method_AddressNotMatch': 'Addresses do not match',
  // thrown by all getAddress methods with custom UI validation
  'Method_FirmwareUpdate_DownloadFailed': 'Failed to download firmware binary',
  // thrown by FirmwareUpdate method
  'Method_CustomMessage_Callback': 'Parameter "callback" is not a function',
  // thrown by CustomMessage method
  'Method_Discovery_BundleException': '',
  // thrown by getAccountInfo method
  'Method_Override': 'override',
  // inner "error", it's more like a interruption
  'Method_NoResponse': 'Call resolved without response',
  // thrown by npm index(es), call to Core resolved without response, should not happen
  'Backend_NotSupported': 'BlockchainLink settings not found in coins.json',
  // thrown by methods which using backends, blockchainLink not defined for this coin
  'Backend_WorkerMissing': '',
  // thrown by BlockchainLink class, worker not specified
  'Backend_Disconnected': 'Backend disconnected',
  // thrown by BlockchainLink class
  'Backend_Invalid': 'Invalid backend',
  // thrown by BlockchainLink class, invalid backend (ie: backend for wrong coin set)
  'Backend_Error': '',
  // thrown by BlockchainLink class, generic message from 'blockchain-link'
  'Runtime': '',
  // thrown from several places, this shouldn't ever happen tho
  'Device_NotFound': 'Device not found',
  'Device_InitializeFailed': '',
  // generic error from firmware while calling "Initialize" message
  'Device_FwException': '',
  // generic FirmwareException type
  'Device_ModeException': '',
  // generic Device.UnexpectedMode type
  'Device_Disconnected': 'Device disconnected',
  // device disconnected during call
  'Device_UsedElsewhere': 'Device is used in another window',
  // interruption: current session toked by other application
  'Device_InvalidState': 'Passphrase is incorrect',
  // authorization error (device state comparison)
  'Device_CallInProgress': 'Device call in progress' // thrown when trying to make another call while current is still running

};
exports.ERROR_CODES = ERROR_CODES;

var TrezorError = /*#__PURE__*/function (_Error) {
  (0, _inheritsLoose2["default"])(TrezorError, _Error);

  function TrezorError(code, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.code = code;
    _this.message = message;
    return _this;
  }

  return TrezorError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.TrezorError = TrezorError;

var TypedError = function TypedError(id, message) {
  return new TrezorError(id, message || ERROR_CODES[id]);
}; // a slight hack
// this error string is hard-coded
// in both bridge and extension


exports.TypedError = TypedError;
var WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = 'wrong previous session';
exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = WRONG_PREVIOUS_SESSION_ERROR_MESSAGE;
var INVALID_PIN_ERROR_MESSAGE = 'PIN invalid';
exports.INVALID_PIN_ERROR_MESSAGE = INVALID_PIN_ERROR_MESSAGE;
var WEBUSB_ERROR_MESSAGE = 'NetworkError: Unable to claim interface.';
exports.WEBUSB_ERROR_MESSAGE = WEBUSB_ERROR_MESSAGE;
//# sourceMappingURL=node_modules/trezor-connect/lib/constants/errors.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/constants/errors.js",}],
[3437, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var render = function render(className, url, origin) {
  var query = className || '.trezor-webusb-button';
  var buttons = document.querySelectorAll(query);
  var src = url + "?" + Date.now();
  buttons.forEach(function (b) {
    if (b.getElementsByTagName('iframe').length < 1) {
      var bounds = b.getBoundingClientRect();
      var btnIframe = document.createElement('iframe');
      btnIframe.frameBorder = '0';
      btnIframe.width = Math.round(bounds.width) + 'px';
      btnIframe.height = Math.round(bounds.height) + 'px';
      btnIframe.style.position = 'absolute';
      btnIframe.style.top = '0px';
      btnIframe.style.left = '0px';
      btnIframe.style.zIndex = '1'; // btnIframe.style.opacity = '0'; // this makes click impossible on cross-origin

      btnIframe.setAttribute('allow', 'usb');
      btnIframe.setAttribute('scrolling', 'no');

      btnIframe.onload = function () {
        btnIframe.contentWindow.postMessage({// style: JSON.stringify( window.getComputedStyle(b) ),
          // outer: b.outerHTML,
          // inner: b.innerHTML
        }, origin);
      };

      btnIframe.src = src; // inject iframe into button

      b.append(btnIframe);
    }
  });
};

var _default = render;
exports["default"] = _default;
//# sourceMappingURL=node_modules/trezor-connect/lib/webusb/button.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/webusb/button.js",}],
[3435, {}, function (require, module, exports) {
(function (global){
"use strict";

exports.__esModule = true;
exports.popupConsole = exports.enableByPrefix = exports.getLog = exports.enable = exports.init = exports["default"] = void 0;

var _this = void 0;

// https://stackoverflow.com/questions/7505623/colors-in-javascript-console
// https://github.com/pimterry/loglevel/blob/master/lib/loglevel.js
// http://www.color-hex.com/color-palette/5016
var colors = {
  // green
  'DescriptorStream': 'color: #77ab59',
  'DeviceList': 'color: #36802d',
  'Device': 'color: #bada55',
  'Core': 'color: #c9df8a',
  'IFrame': 'color: #FFFFFF; background: #f4a742;',
  'Popup': 'color: #f48a00'
};

var Log = /*#__PURE__*/function () {
  function Log(prefix, enabled) {
    if (enabled === void 0) {
      enabled = false;
    }

    this.prefix = prefix;
    this.enabled = enabled;
    this.messages = [];
    this.css = colors[prefix] || 'color: #000000; background: #FFFFFF;';
  }

  var _proto = Log.prototype;

  _proto.addMessage = function addMessage(level, prefix) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.messages.push({
      level: level,
      prefix: prefix,
      message: args,
      timestamp: new Date().getTime()
    });
  };

  _proto.log = function log() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    this.addMessage.apply(this, ['log', this.prefix].concat(args)); // eslint-disable-next-line no-console

    if (this.enabled) {
      var _console;

      (_console = console).log.apply(_console, [this.prefix].concat(args));
    }
  };

  _proto.error = function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    this.addMessage.apply(this, ['error', this.prefix].concat(args)); // eslint-disable-next-line no-console

    if (this.enabled) {
      var _console2;

      (_console2 = console).error.apply(_console2, [this.prefix].concat(args));
    }
  };

  _proto.warn = function warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    this.addMessage.apply(this, ['warn', this.prefix].concat(args)); // eslint-disable-next-line no-console

    if (this.enabled) {
      var _console3;

      (_console3 = console).warn.apply(_console3, [this.prefix].concat(args));
    }
  };

  _proto.debug = function debug() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    this.addMessage.apply(this, ['debug', this.prefix].concat(args)); // eslint-disable-next-line no-console

    if (this.enabled) {
      var _console4;

      (_console4 = console).log.apply(_console4, ['%c' + this.prefix, this.css].concat(args));
    }
  };

  return Log;
}();

exports["default"] = Log;
var _logs = {};

var init = function init(prefix, enabled) {
  var enab = typeof enabled === 'boolean' ? enabled : false;
  var instance = new Log(prefix, enab);
  _logs[prefix] = instance;
  return instance;
};

exports.init = init;

var enable = function enable(enabled) {
  for (var _i = 0, _Object$keys = Object.keys(_logs); _i < _Object$keys.length; _i++) {
    var l = _Object$keys[_i];
    _logs[l].enabled = enabled;
  }
};

exports.enable = enable;

var getLog = function getLog(args) {
  // if
  var logs = [];

  for (var _i2 = 0, _Object$keys2 = Object.keys(_logs); _i2 < _Object$keys2.length; _i2++) {
    var l = _Object$keys2[_i2];
    logs = logs.concat(_logs[l].messages);
  }

  logs.sort(function (a, b) {
    return a.timestamp - b.timestamp;
  });
  return logs;
};

exports.getLog = getLog;

var enableByPrefix = function enableByPrefix(prefix, enabled) {
  if (_logs[prefix]) {
    _logs[prefix].enabled = enabled;
  }
}; // TODO: enable/disable log at runtime


exports.enableByPrefix = enableByPrefix;

var popupConsole = function popupConsole(tag, postMessage) {
  var c = global.console;
  var orig = {
    error: c.error,
    // warn: c.warn,
    info: c.info,
    debug: c.debug,
    log: c.log
  };
  var log = [];

  var inject = function inject(method, level) {
    return function () {
      // args.unshift('[popup.js]');
      var time = new Date().toUTCString();

      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      log.push([level, time].concat(args));
      postMessage.apply(_this, [{
        type: tag,
        level: level,
        time: time,
        args: JSON.stringify(args)
      } // { type: 'LOG', level: level, time: time, args: JSON.stringify(deepClone(args)) }
      ]);
      return method.apply(c, args);
    };
  };

  for (var level in orig) {
    c[level] = inject(orig[level], level);
  }
};

exports.popupConsole = popupConsole;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

//# sourceMappingURL=node_modules/trezor-connect/lib/utils/debug.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/utils/debug.js",}],
[3410, {}, function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.errorMessage = exports.parseMessage = void 0;

// parse MessageEvent .data into CoreMessage
var parseMessage = function parseMessage(messageData) {
  var message = {
    event: messageData.event,
    type: messageData.type,
    payload: messageData.payload
  };

  if (typeof messageData.id === 'number') {
    message.id = messageData.id;
  }

  if (typeof messageData.success === 'boolean') {
    message.success = messageData.success;
  }

  return message;
}; // common response used straight from npm index (not from Core)


exports.parseMessage = parseMessage;

var errorMessage = function errorMessage(error) {
  return {
    success: false,
    payload: {
      error: error.message,
      code: error.code
    }
  };
};

exports.errorMessage = errorMessage;
//# sourceMappingURL=node_modules/trezor-connect/lib/message/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/message/index.js",}],
[3409, {"../constants":3398,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.BlockchainMessage = exports.ResponseMessage = exports.TransportMessage = exports.DeviceMessage = exports.UiMessage = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var UiMessage = function UiMessage(type, payload) {
  return {
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  };
};

exports.UiMessage = UiMessage;

var DeviceMessage = function DeviceMessage(type, payload) {
  return {
    event: _constants.DEVICE_EVENT,
    type: type,
    payload: payload
  };
};

exports.DeviceMessage = DeviceMessage;

var TransportMessage = function TransportMessage(type, payload) {
  return {
    event: _constants.TRANSPORT_EVENT,
    type: type,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: payload.error ? _objectSpread(_objectSpread({}, payload), {}, {
      error: payload.error.message,
      code: payload.error.code
    }) : payload
  };
};

exports.TransportMessage = TransportMessage;

var ResponseMessage = function ResponseMessage(id, success, payload) {
  if (payload === void 0) {
    payload = null;
  }

  return {
    event: _constants.RESPONSE_EVENT,
    type: _constants.RESPONSE_EVENT,
    id: id,
    success: success,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: success ? payload : {
      error: payload.error.message,
      code: payload.error.code
    }
  };
};

exports.ResponseMessage = ResponseMessage;

var BlockchainMessage = function BlockchainMessage(type, payload) {
  return {
    event: _constants.BLOCKCHAIN_EVENT,
    type: type,
    payload: payload
  };
};

exports.BlockchainMessage = BlockchainMessage;
//# sourceMappingURL=node_modules/trezor-connect/lib/message/builder.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/message/builder.js",}],
[3403, {"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186}, function (require, module, exports) {
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.parse = exports.corsValidator = exports.getEnv = exports.DEFAULT_PRIORITY = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*
 * Initial settings for connect.
 * It could be changed by passing values into TrezorConnect.init(...) method
 */
var VERSION = '8.1.23';
var versionN = VERSION.split('.').map(function (s) {
  return parseInt(s);
}); // const DIRECTORY = `${ versionN[0] }${ (versionN[1] > 0 ? `.${versionN[1]}` : '') }/`;

var DIRECTORY = versionN[0] + "/";
var DEFAULT_DOMAIN = "https://connect.trezor.io/" + DIRECTORY;
var DEFAULT_PRIORITY = 2;
exports.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
var initialSettings = {
  configSrc: './data/config.json',
  // constant
  version: VERSION,
  // constant
  debug: false,
  priority: DEFAULT_PRIORITY,
  trustedHost: false,
  connectSrc: DEFAULT_DOMAIN,
  iframeSrc: DEFAULT_DOMAIN + "iframe.html",
  popup: true,
  popupSrc: DEFAULT_DOMAIN + "popup.html",
  webusbSrc: DEFAULT_DOMAIN + "webusb.html",
  transportReconnect: false,
  webusb: true,
  pendingTransportEvent: true,
  supportedBrowser: typeof navigator !== 'undefined' ? !/Trident|MSIE|Edge/.test(navigator.userAgent) : true,
  manifest: null,
  env: 'web',
  lazyLoad: false,
  timestamp: new Date().getTime(),
  interactionTimeout: 600 // 5 minutes

};
var currentSettings = initialSettings;

var parseManifest = function parseManifest(manifest) {
  if (!manifest) return;
  if (typeof manifest.email !== 'string') return;
  if (typeof manifest.appUrl !== 'string') return;
  return {
    email: manifest.email,
    appUrl: manifest.appUrl
  };
};

var getEnv = function getEnv() {
  // $FlowIssue: chrome is not declared outside the project
  if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
    return 'webextension';
  }

  if (typeof navigator !== 'undefined') {
    if (typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
      return 'react-native';
    }

    var userAgent = navigator.userAgent.toLowerCase();

    if (userAgent.indexOf(' electron/') > -1) {
      return 'electron';
    }
  } // if (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
  //     return 'react-native';
  // }
  // if (typeof process !== 'undefined' && process.versions.hasOwnProperty('electron')) {
  //     return 'electron';
  // }


  return 'web';
}; // Cors validation copied from Trezor Bridge
// see: https://github.com/trezor/trezord-go/blob/05991cea5900d18bcc6ece5ae5e319d138fc5551/server/api/api.go#L229
// Its pointless to allow `trezor-connect` endpoints { connectSrc } for domains other than listed below
// `trezord` will block communication anyway


exports.getEnv = getEnv;

var corsValidator = function corsValidator(url) {
  if (typeof url !== 'string') return;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//)) return url;
  if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//)) return url;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//)) return url;
  if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//)) return url;
};

exports.corsValidator = corsValidator;

var parse = function parse(input) {
  if (input === void 0) {
    input = {};
  }

  var settings = _objectSpread({}, currentSettings);

  if (Object.prototype.hasOwnProperty.call(input, 'debug')) {
    if (Array.isArray(input)) {// enable log with prefix
    }

    if (typeof input.debug === 'boolean') {
      settings.debug = input.debug;
    } else if (typeof input.debug === 'string') {
      settings.debug = input.debug === 'true';
    }
  }

  if (typeof input.connectSrc === 'string') {
    settings.connectSrc = input.connectSrc;
  } // For debugging purposes `connectSrc` could be defined in `global.__TREZOR_CONNECT_SRC` variable


  if (typeof global !== 'undefined' && typeof global.__TREZOR_CONNECT_SRC === 'string') {
    settings.connectSrc = corsValidator(global.__TREZOR_CONNECT_SRC);
    settings.debug = true;
  } // For debugging purposes `connectSrc` could be defined in url query of hosting page. Usage:
  // https://3rdparty-page.com/?trezor-connect-src=https://localhost:8088/


  if (typeof window !== 'undefined' && window.location && typeof window.location.search === 'string') {
    var vars = window.location.search.split('&');
    var customUrl = vars.find(function (v) {
      return v.indexOf('trezor-connect-src') >= 0;
    });

    if (customUrl) {
      var _customUrl$split = customUrl.split('='),
          connectSrc = _customUrl$split[1];

      settings.connectSrc = corsValidator(decodeURIComponent(connectSrc));
      settings.debug = true;
    }
  }

  var src = settings.connectSrc || DEFAULT_DOMAIN;
  settings.iframeSrc = src + "iframe.html";
  settings.popupSrc = src + "popup.html";
  settings.webusbSrc = src + "webusb.html";

  if (typeof input.transportReconnect === 'boolean') {
    settings.transportReconnect = input.transportReconnect;
  }

  if (typeof input.webusb === 'boolean') {
    settings.webusb = input.webusb;
  }

  if (typeof input.popup === 'boolean') {
    settings.popup = input.popup;
  }

  if (typeof input.lazyLoad === 'boolean') {
    settings.lazyLoad = input.lazyLoad;
  }

  if (typeof input.pendingTransportEvent === 'boolean') {
    settings.pendingTransportEvent = input.pendingTransportEvent;
  } // local files


  if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
    settings.origin = "file://" + window.location.pathname;
    settings.webusb = false;
  }

  if (typeof input.extension === 'string') {
    settings.extension = input.extension;
  }

  if (typeof input.env === 'string') {
    settings.env = input.env;
  } else {
    settings.env = getEnv();
  }

  if (typeof input.timestamp === 'number') {
    settings.timestamp = input.timestamp;
  }

  if (typeof input.interactionTimeout === 'number') {
    settings.interactionTimeout = input.interactionTimeout;
  }

  if (typeof input.manifest === 'object') {
    settings.manifest = parseManifest(input.manifest);
  }

  currentSettings = settings;
  return currentSettings;
};

exports.parse = parse;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

//# sourceMappingURL=node_modules/trezor-connect/lib/data/ConnectSettings.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/data/ConnectSettings.js",}],
[3406, {"../constants":3398,"../env/browser/networkUtils":3405,"../utils/deferred":3436,"./inline-styles":3407,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _deferred = require("../utils/deferred");

var _constants = require("../constants");

var _networkUtils = require("../env/browser/networkUtils");

var _inlineStyles = _interopRequireDefault(require("./inline-styles"));

var instance;
exports.instance = instance;
var origin;
exports.origin = origin;
var initPromise = (0, _deferred.create)();
exports.initPromise = initPromise;
var timeout = 0;
exports.timeout = timeout;
var error;
exports.error = error;
var _messageID = 0; // every postMessage to iframe has its own promise to resolve

var messagePromises = {};
exports.messagePromises = messagePromises;

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    var existedFrame, src, manifestString, manifest, onLoad;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            exports.initPromise = initPromise = (0, _deferred.create)();
            existedFrame = document.getElementById('trezorconnect');

            if (existedFrame) {
              exports.instance = instance = existedFrame;
            } else {
              exports.instance = instance = document.createElement('iframe');
              instance.frameBorder = '0';
              instance.width = '0px';
              instance.height = '0px';
              instance.style.position = 'absolute';
              instance.style.display = 'none';
              instance.style.border = '0px';
              instance.style.width = '0px';
              instance.style.height = '0px';
              instance.id = 'trezorconnect';
            }

            if (settings.env === 'web') {
              manifestString = settings.manifest ? JSON.stringify(settings.manifest) : 'undefined'; // note: btoa(undefined) === btoa('undefined') === "dW5kZWZpbmVk"

              manifest = "version=" + settings.version + "&manifest=" + encodeURIComponent(btoa(JSON.stringify(manifestString)));
              src = settings.iframeSrc + "?" + manifest;
            } else {
              src = settings.iframeSrc;
            }

            instance.setAttribute('src', src);

            if (settings.webusb) {
              instance.setAttribute('allow', 'usb');
            }

            exports.origin = origin = (0, _networkUtils.getOrigin)(instance.src);
            exports.timeout = timeout = window.setTimeout(function () {
              initPromise.reject(_constants.ERRORS.TypedError('Init_IframeTimeout'));
            }, 10000);

            onLoad = function onLoad() {
              if (!instance) {
                initPromise.reject(_constants.ERRORS.TypedError('Init_IframeBlocked'));
                return;
              }

              try {
                // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                var iframeOrigin = instance.contentWindow.location.origin;

                if (!iframeOrigin || iframeOrigin === 'null') {
                  // eslint-disable-next-line no-use-before-define
                  handleIframeBlocked();
                  return;
                }
              } catch (e) {// empty
              }

              var extension; // $FlowIssue chrome is not declared outside

              if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                chrome.runtime.onConnect.addListener(function () {});
                extension = chrome.runtime.id;
              }

              instance.contentWindow.postMessage({
                type: _constants.IFRAME.INIT,
                payload: {
                  settings: settings,
                  extension: extension
                }
              }, origin);
              instance.onload = undefined;
            }; // IE hack


            if (instance.attachEvent) {
              instance.attachEvent('onload', onLoad);
            } else {
              instance.onload = onLoad;
            } // inject iframe into host document body


            if (document.body) {
              document.body.appendChild(instance); // eslint-disable-next-line no-use-before-define

              injectStyleSheet();
            }

            _context.prev = 11;
            _context.next = 14;
            return initPromise.promise;

          case 14:
            _context.next = 20;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](11);

            // reset state to allow initialization again
            if (instance) {
              if (instance.parentNode) {
                instance.parentNode.removeChild(instance);
              } // eslint-disable-next-line require-atomic-updates


              exports.instance = instance = null;
            }

            throw _context.t0;

          case 20:
            _context.prev = 20;
            window.clearTimeout(timeout);
            exports.timeout = timeout = 0;
            return _context.finish(20);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 16, 20, 24]]);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var injectStyleSheet = function injectStyleSheet() {
  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  var doc = instance.ownerDocument;
  var head = doc.head || doc.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.setAttribute('id', 'TrezorConnectStylesheet'); // $FlowIssue

  if (style.styleSheet) {
    // IE
    // $FlowIssue
    style.styleSheet.cssText = _inlineStyles["default"];
    head.appendChild(style);
  } else {
    style.appendChild(document.createTextNode(_inlineStyles["default"]));
    head.append(style);
  }
};

var handleIframeBlocked = function handleIframeBlocked() {
  window.clearTimeout(timeout);
  exports.error = error = _constants.ERRORS.TypedError('Init_IframeBlocked'); // eslint-disable-next-line no-use-before-define

  dispose();
  initPromise.reject(error);
}; // post messages to iframe


var postMessage = function postMessage(message, usePromise) {
  if (usePromise === void 0) {
    usePromise = true;
  }

  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  if (usePromise) {
    _messageID++;
    message.id = _messageID;
    messagePromises[_messageID] = (0, _deferred.create)();
    var promise = messagePromises[_messageID].promise;
    instance.contentWindow.postMessage(message, origin);
    return promise;
  }

  instance.contentWindow.postMessage(message, origin);
  return null;
};

exports.postMessage = postMessage;

var dispose = function dispose() {
  if (instance && instance.parentNode) {
    try {
      instance.parentNode.removeChild(instance);
    } catch (error) {// do nothing
    }
  }

  exports.instance = instance = null;
  exports.timeout = timeout = 0;
};

exports.dispose = dispose;

var clearTimeout = function clearTimeout() {
  window.clearTimeout(timeout);
};

exports.clearTimeout = clearTimeout;
//# sourceMappingURL=node_modules/trezor-connect/lib/iframe/builder.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/iframe/builder.js",}],
[3411, {"../constants/iframe":3397,"../constants/popup":3400,"../constants/ui":3402,"../env/browser/networkUtils":3405,"../utils/deferred":3436,"./showPopupRequest":3412,"@babel/runtime/helpers/assertThisInitialized":175,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/inheritsLoose":185,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/helpers/interopRequireWildcard":187,"@babel/runtime/regenerator":206,"events":1429}, function (require, module, exports) {
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var POPUP = _interopRequireWildcard(require("../constants/popup"));

var IFRAME = _interopRequireWildcard(require("../constants/iframe"));

var UI = _interopRequireWildcard(require("../constants/ui"));

var _showPopupRequest = require("./showPopupRequest");

var _networkUtils = require("../env/browser/networkUtils");

var _deferred = require("../utils/deferred");

// const POPUP_REQUEST_TIMEOUT: number = 602;
var POPUP_REQUEST_TIMEOUT = 850;
var POPUP_CLOSE_INTERVAL = 500;
var POPUP_OPEN_TIMEOUT = 3000;

var PopupManager = /*#__PURE__*/function (_EventEmitter) {
  (0, _inheritsLoose2["default"])(PopupManager, _EventEmitter);

  // Window
  function PopupManager(settings) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestTimeout", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closeInterval", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extensionTabId", 0);
    _this.settings = settings;
    _this.origin = (0, _networkUtils.getOrigin)(settings.popupSrc);
    _this.handleMessage = _this.handleMessage.bind((0, _assertThisInitialized2["default"])(_this));
    _this.iframeHandshake = (0, _deferred.create)(IFRAME.LOADED);

    if (_this.settings.env === 'webextension') {
      _this.handleExtensionConnect = _this.handleExtensionConnect.bind((0, _assertThisInitialized2["default"])(_this));
      _this.handleExtensionMessage = _this.handleExtensionMessage.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

      chrome.runtime.onConnect.addListener(_this.handleExtensionConnect);
    }

    window.addEventListener('message', _this.handleMessage, false);
    return _this;
  }

  var _proto = PopupManager.prototype;

  _proto.request = function request(lazyLoad) {
    var _this2 = this;

    if (lazyLoad === void 0) {
      lazyLoad = false;
    }

    // popup request
    // TODO: ie - open immediately and hide it but post handshake after timeout
    // bring popup window to front
    if (this.locked) {
      if (this._window) {
        if (this.settings.env === 'webextension') {
          // $FlowIssue chrome not declared outside
          chrome.tabs.update(this._window.id, {
            active: true
          });
        } else {
          this._window.focus();
        }
      }

      return;
    }

    var openFn = this.open.bind(this);
    this.locked = true;

    if (!this.settings.supportedBrowser) {
      openFn();
    } else {
      var timeout = lazyLoad || this.settings.env === 'webextension' ? 1 : POPUP_REQUEST_TIMEOUT;
      this.requestTimeout = window.setTimeout(function () {
        _this2.requestTimeout = 0;
        openFn(lazyLoad);
      }, timeout);
    }
  };

  _proto.cancel = function cancel() {
    this.close();
  };

  _proto.unlock = function unlock() {
    this.locked = false;
  };

  _proto.open = function open(lazyLoad) {
    var _this3 = this;

    var src = this.settings.popupSrc;

    if (!this.settings.supportedBrowser) {
      this.openWrapper(src + "#unsupported");
      return;
    }

    this.popupPromise = (0, _deferred.create)(POPUP.LOADED);
    this.openWrapper(lazyLoad ? src + "#loading" : src);
    this.closeInterval = window.setInterval(function () {
      if (!_this3._window) return;

      if (_this3.settings.env === 'webextension') {
        // $FlowIssue chrome not declared outside
        chrome.tabs.get(_this3._window.id, function (tab) {
          if (!tab) {
            _this3.close();

            _this3.emit(POPUP.CLOSED);
          }
        });
      } else if (_this3._window.closed) {
        _this3.close();

        _this3.emit(POPUP.CLOSED);
      }
    }, POPUP_CLOSE_INTERVAL); // open timeout will be cancelled by POPUP.BOOTSTRAP message

    this.openTimeout = window.setTimeout(function () {
      _this3.close();

      (0, _showPopupRequest.showPopupRequest)(_this3.open.bind(_this3), function () {
        _this3.emit(POPUP.CLOSED);
      });
    }, POPUP_OPEN_TIMEOUT);
  };

  _proto.openWrapper = function openWrapper(url) {
    var _this4 = this;

    if (this.settings.env === 'webextension') {
      // $FlowIssue chrome not declared outside
      chrome.windows.getCurrent(null, function (currentWindow) {
        // Request coming from extension popup,
        // create new window above instead of opening new tab
        if (currentWindow.type !== 'normal') {
          // $FlowIssue chrome not declared outside
          chrome.windows.create({
            url: url
          }, function (newWindow) {
            // $FlowIssue chrome not declared outside
            chrome.tabs.query({
              windowId: newWindow.id,
              active: true
            }, function (tabs) {
              _this4._window = tabs[0];
            });
          });
        } else {
          // $FlowIssue chrome not declared outside
          chrome.tabs.query({
            currentWindow: true,
            active: true
          }, function (tabs) {
            _this4.extensionTabId = tabs[0].id; // $FlowIssue chrome not declared outside

            chrome.tabs.create({
              url: url,
              index: tabs[0].index + 1
            }, function (tab) {
              _this4._window = tab;
            });
          });
        }
      });
    } else if (this.settings.env === 'electron') {
      this._window = window.open(url, 'modal');
    } else {
      this._window = window.open('', '_blank');

      if (this._window) {
        this._window.location.href = url; // otherwise android/chrome loose window.opener reference
      }
    }
  };

  _proto.handleExtensionConnect = function handleExtensionConnect(port) {
    if (port.name !== 'trezor-connect') return;

    if (!this._window || this._window && this._window.id !== port.sender.tab.id) {
      port.disconnect();
      return;
    } // since POPUP.BOOTSTRAP will not be handled by "handleMessage" we need to threat "content-script" connection as the same event
    // popup is opened properly, now wait for POPUP.LOADED message (in this case handled by "handleExtensionMessage")


    window.clearTimeout(this.openTimeout);
    this.extensionPort = port; // $FlowIssue need to update ChromePort definition

    this.extensionPort.onMessage.addListener(this.handleExtensionMessage);
  };

  _proto.handleExtensionMessage = function handleExtensionMessage(message) {
    var _this5 = this;

    if (!this.extensionPort) return;
    var port = this.extensionPort;
    var data = message.data;
    if (!data || typeof data !== 'object') return;

    if (data.type === POPUP.ERROR) {
      // handle popup error
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      }

      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        port.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this5.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        });
      });
    } else if (data.type === POPUP.EXTENSION_USB_PERMISSIONS) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.query({
        currentWindow: true,
        active: true
      }, function (tabs) {
        // $FlowIssue chrome not declared outside
        chrome.tabs.create({
          url: 'trezor-usb-permissions.html',
          index: tabs[0].index + 1
        }, function (tab) {// do nothing
        });
      });
    } else if (data.type === POPUP.CLOSE_WINDOW) {
      this.emit(POPUP.CLOSED);
      this.close();
    }
  };

  _proto.handleMessage = function handleMessage(message) {
    var _this6 = this;

    // ignore messages from domain other then popup origin and without data
    // const data: CoreMessage = message.data;
    var data = message.data;
    if ((0, _networkUtils.getOrigin)(message.origin) !== this.origin || !data || typeof data !== 'object') return;

    if (data.type === IFRAME.LOADED) {
      var useBroadcastChannel = data.payload && typeof data.payload.useBroadcastChannel === 'boolean' ? data.payload.useBroadcastChannel : false;
      this.iframeHandshake.resolve(useBroadcastChannel);
    } else if (data.type === POPUP.BOOTSTRAP) {
      // popup is opened properly, now wait for POPUP.LOADED message
      window.clearTimeout(this.openTimeout);
    } else if (data.type === POPUP.ERROR && this._window) {
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      } // popup is successfully loaded


      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        _this6._window.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this6.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        }, _this6.origin);
      }); // send ConnectSettings to popup
      // note this settings and iframe.ConnectSettings could be different (especially: origin, popup, webusb, debug)
      // now popup is able to load assets
    } else if (data.type === POPUP.CANCEL_POPUP_REQUEST || data.type === UI.CLOSE_UI_WINDOW) {
      this.close();
    }
  };

  _proto.close = function close() {
    this.locked = false;
    this.popupPromise = undefined;

    if (this.requestTimeout) {
      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = 0;
    }

    if (this.openTimeout) {
      window.clearTimeout(this.openTimeout);
      this.openTimeout = 0;
    }

    if (this.closeInterval) {
      window.clearInterval(this.closeInterval);
      this.closeInterval = 0;
    }

    if (this.extensionPort) {
      this.extensionPort.disconnect();
      this.extensionPort = null;
    } // switch to previously focused tab


    if (this.extensionTabId) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.update(this.extensionTabId, {
        active: true
      });
      this.extensionTabId = 0;
    }

    if (this._window) {
      if (this.settings.env === 'webextension') {
        // eslint-disable-next-line no-unused-vars
        var _e = chrome.runtime.lastError; // $FlowIssue chrome not declared outside

        chrome.tabs.remove(this._window.id, function () {
          // eslint-disable-next-line no-unused-vars
          _e = chrome.runtime.lastError;
        });
      } else {
        this._window.close();
      }

      this._window = null;
    }
  };

  _proto.postMessage = /*#__PURE__*/function () {
    var _postMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(message) {
      var _this7 = this;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this._window && message.type !== UI.REQUEST_UI_WINDOW && this.openTimeout)) {
                _context.next = 4;
                break;
              }

              this.close();
              (0, _showPopupRequest.showPopupRequest)(this.open.bind(this), function () {
                _this7.emit(POPUP.CLOSED);
              });
              return _context.abrupt("return");

            case 4:
              if (!this.popupPromise) {
                _context.next = 7;
                break;
              }

              _context.next = 7;
              return this.popupPromise.promise;

            case 7:
              // post message to popup window
              if (this._window) {
                this._window.postMessage(message, this.origin);
              }

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function postMessage(_x) {
      return _postMessage.apply(this, arguments);
    }

    return postMessage;
  }();

  _proto.onBeforeUnload = function onBeforeUnload() {
    this.close();
  };

  return PopupManager;
}(_events["default"]);

exports["default"] = PopupManager;
//# sourceMappingURL=node_modules/trezor-connect/lib/popup/PopupManager.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/trezor-connect/lib/popup/PopupManager.js",}],
[2251, {}, function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * Check if an object is contained within another object.
 *
 * Returns `true` if:
 * - all enumerable keys of *subset* are also enumerable in *superset*, and
 * - every value assigned to an enumerable key of *subset* strictly equals
 *   the value assigned to the same key of *superset* – or is a subset of it.
 *
 * @param  {Object}  superset
 * @param  {Object}  subset
 *
 * @returns  {Boolean}
 *
 * @module    is-subset
 * @function  default
 * @alias     isSubset
 */
var isSubset = (function (_isSubset) {
  function isSubset(_x, _x2) {
    return _isSubset.apply(this, arguments);
  }

  isSubset.toString = function () {
    return _isSubset.toString();
  };

  return isSubset;
})(function (superset, subset) {
  if (typeof superset !== 'object' || superset === null || (typeof subset !== 'object' || subset === null)) return false;

  return Object.keys(subset).every(function (key) {
    if (!superset.propertyIsEnumerable(key)) return false;

    var subsetItem = subset[key];
    var supersetItem = superset[key];
    if (typeof subsetItem === 'object' && subsetItem !== null ? !isSubset(supersetItem, subsetItem) : supersetItem !== subsetItem) return false;

    return true;
  });
});

exports['default'] = isSubset;
module.exports = exports['default'];
//# sourceMappingURL=node_modules/is-subset/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/is-subset/index.js",}],
[3201, {"./src/classes":3202,"./src/errorCodes.json":3203,"./src/errors":3205,"./src/utils":3206}, function (require, module, exports) {

const { EthereumRpcError, EthereumProviderError } = require('./src/classes')
const {
  serializeError, getMessageFromCode,
} = require('./src/utils')
const ethErrors = require('./src/errors')
const ERROR_CODES = require('./src/errorCodes.json')

module.exports = {
  ethErrors,
  EthereumRpcError,
  EthereumProviderError,
  serializeError,
  getMessageFromCode,

  /** @type ErrorCodes */
  ERROR_CODES,
}

// Types

/**
 * @typedef {Object} EthereumProviderErrorCodes
 * @property {number} userRejectedRequest
 * @property {number} unauthorized
 * @property {number} unsupportedMethod
 * @property {number} disconnected
 * @property {number} chainDisconnected
 */

/**
 * @typedef {Object} EthereumRpcErrorCodes
 * @property {number} parse
 * @property {number} invalidRequest
 * @property {number} invalidParams
 * @property {number} methodNotFound
 * @property {number} limitExceeded
 * @property {number} internal
 * @property {number} invalidInput
 * @property {number} resourceNotFound
 * @property {number} resourceUnavailable
 * @property {number} transactionRejected
 * @property {number} methodNotSupported
 */

/**
 * @typedef ErrorCodes
 * @property {EthereumRpcErrorCodes} rpc
 * @property {EthereumProviderErrorCodes} provider
 */

//# sourceMappingURL=node_modules/rpc-cap/node_modules/eth-rpc-errors/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/eth-rpc-errors/index.js",}],
[3171, {}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseController = void 0;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
class BaseController {
    /**
     * Creates a BaseController instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config = {}, state = {}) {
        /**
         * Map of all sibling child controllers keyed by name if this
         * controller is composed using a ComposableController, allowing
         * any API on any sibling controller to be accessed
         */
        this.context = {};
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = [];
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        // Use assign since generics can't be spread: https://git.io/vpRhY
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns - This controller instance
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options
     *
     * @returns - Current configuration
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration
     *
     * @param config - New configuration options
     * @param overwrite - Overwrite config instead of merging
     * @param fullUpdate - Boolean that defines if the update is partial or not
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);
            for (const key in this.internalConfig) {
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this[key] = this.internalConfig[key];
                }
            }
        }
        else {
            for (const key in config) {
                /* istanbul ignore else */
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this.internalConfig[key] = config[key];
                    this[key] = config[key];
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        this.requiredControllers.forEach((name) => {
            if (!this.context[name]) {
                throw new Error(`${this.name} must be composed with ${name}.`);
            }
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state
     *
     * @param state - New state
     * @param overwrite - Overwrite state instead of merging
     */
    update(state, overwrite = false) {
        this.internalState = overwrite ? Object.assign({}, state) : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
exports.BaseController = BaseController;
exports.default = BaseController;
//# sourceMappingURL=BaseController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/BaseController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/BaseController.js",}],
[3172, {"./BaseController":3171}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableController = void 0;
const BaseController_1 = require("./BaseController");
/**
 * Controller that can be used to compose multiple controllers together
 */
class ComposableController extends BaseController_1.default {
    /**
     * Creates a ComposableController instance
     *
     * @param controllers - Map of names to controller instances
     * @param initialState - Initial state keyed by child controller name
     */
    constructor(controllers = [], initialState) {
        super();
        this.internalControllers = [];
        /**
         * Map of stores to compose together
         */
        this.context = {};
        /**
         * Name of this controller used during composition
         */
        this.name = 'ComposableController';
        this.initialize();
        this.cachedState = initialState;
        this.controllers = controllers;
        this.cachedState = undefined;
    }
    /**
     * Get current list of child composed store instances
     *
     * @returns - List of names to controller instances
     */
    get controllers() {
        return this.internalControllers;
    }
    /**
     * Set new list of controller instances
     *
     * @param controllers - List of names to controller instsances
     */
    set controllers(controllers) {
        this.internalControllers = controllers;
        const initialState = {};
        controllers.forEach((controller) => {
            const { name } = controller;
            this.context[name] = controller;
            controller.context = this.context;
            this.cachedState && this.cachedState[name] && controller.update(this.cachedState[name]);
            initialState[name] = controller.state;
            controller.subscribe((state) => {
                this.update({ [name]: state });
            });
        });
        controllers.forEach((controller) => {
            controller.onComposed();
        });
        this.update(initialState, true);
    }
    /**
     * Flat state representation, one that isn't keyed
     * of controller name. Instead, all child controller state is merged
     * together into a single, flat object.
     *
     * @returns - Merged state representation of all child controllers
     */
    get flatState() {
        let flatState = {};
        for (const name in this.context) {
            flatState = Object.assign(Object.assign({}, flatState), this.context[name].state);
        }
        return flatState;
    }
}
exports.ComposableController = ComposableController;
exports.default = ComposableController;
//# sourceMappingURL=ComposableController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/ComposableController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/ComposableController.js",}],
[3190, {"../BaseController":3171,"../util":3192,"ethereumjs-util":3211}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const util_1 = require("../util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that manages a list of recipient addresses associated with nicknames
 */
class AddressBookController extends BaseController_1.default {
    /**
     * Creates an AddressBookController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address
     *
     * @param chainId - Chain id identifies the current chain
     * @param address - Recipient address to delete
     */
    delete(chainId, address) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        if (!ethereumjs_util_1.isValidAddress(address) || !this.state.addressBook[chainId] || !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address
     *
     * @param address - Recipient address to add or update
     * @param name - Nickname to associate with this address
     * @param chainId - Chain id identifies the current chain
     * @param memo - User's note about address
     * @returns - Boolean indicating if the address was successfully set
     */
    set(address, name, chainId = '1', memo = '') {
        address = ethereumjs_util_1.toChecksumAddress(address);
        if (!ethereumjs_util_1.isValidAddress(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
        };
        const ensName = util_1.normalizeEnsName(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/user/AddressBookController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/user/AddressBookController.js",}],
[3180, {"../BaseController":3171,"../util":3192,"ethereumjs-util":3211}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRatesController = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval for token-to-fiat exchange rates
 * for tokens stored in the AssetsController
 */
class TokenRatesController extends BaseController_1.default {
    /**
     * Creates a TokenRatesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.tokenList = [];
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenRatesController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['AssetsController', 'CurrencyRateController'];
        this.defaultConfig = {
            disabled: true,
            interval: 180000,
            nativeCurrency: 'eth',
            tokens: [],
        };
        this.defaultState = { contractExchangeRates: {} };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        this.poll();
    }
    getPricingURL(query) {
        return `https://api.coingecko.com/api/v3/simple/token_price/ethereum?${query}`;
    }
    /**
     * Sets a new polling interval
     *
     * @param interval - Polling interval used to fetch new token rates
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateExchangeRates());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sets a new token list to track prices
     *
     * @param tokens - List of tokens to track exchange rates for
     */
    set tokens(tokens) {
        this.tokenList = tokens;
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    /**
     * Fetches a pairs of token address and native currency
     *
     * @param query - Query according to tokens in tokenList and native currency
     * @returns - Promise resolving to exchange rates for given pairs
     */
    fetchExchangeRate(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return util_1.handleFetch(this.getPricingURL(query));
        });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const assets = this.context.AssetsController;
        const currencyRate = this.context.CurrencyRateController;
        assets.subscribe(() => {
            this.configure({ tokens: assets.state.tokens });
        });
        currencyRate.subscribe(() => {
            this.configure({ nativeCurrency: currencyRate.state.nativeCurrency });
        });
    }
    /**
     * Updates exchange rates for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateExchangeRates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenList.length === 0) {
                return;
            }
            const newContractExchangeRates = {};
            const { nativeCurrency } = this.config;
            const pairs = this.tokenList.map((token) => token.address).join(',');
            const query = `contract_addresses=${pairs}&vs_currencies=${nativeCurrency.toLowerCase()}`;
            const prices = yield this.fetchExchangeRate(query);
            this.tokenList.forEach((token) => {
                const address = ethereumjs_util_1.toChecksumAddress(token.address);
                const price = prices[token.address.toLowerCase()];
                newContractExchangeRates[address] = price ? price[nativeCurrency.toLowerCase()] : 0;
            });
            this.update({ contractExchangeRates: newContractExchangeRates });
        });
    }
}
exports.TokenRatesController = TokenRatesController;
exports.default = TokenRatesController;
//# sourceMappingURL=TokenRatesController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js",}],
[3179, {"../BaseController":3171,"../util":3192,"ethereumjs-util":3211}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalancesController = exports.BN = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const { BN } = require('ethereumjs-util');
exports.BN = BN;
/**
 * Controller that passively polls on a set interval token balances
 * for tokens stored in the AssetsController
 */
class TokenBalancesController extends BaseController_1.default {
    /**
     * Creates a TokenBalancesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenBalancesController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['AssetsContractController', 'AssetsController'];
        this.defaultConfig = {
            interval: 180000,
            tokens: [],
        };
        this.defaultState = { contractBalances: {} };
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new token balances
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateBalances());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Updates balances for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const assetsContract = this.context.AssetsContractController;
            const assets = this.context.AssetsController;
            const { selectedAddress } = assets.config;
            const { tokens } = this.config;
            const newContractBalances = {};
            for (const i in tokens) {
                const { address } = tokens[i];
                newContractBalances[address] = yield assetsContract.getBalanceOf(address, selectedAddress);
            }
            this.update({ contractBalances: newContractBalances });
        });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const assets = this.context.AssetsController;
        assets.subscribe(({ tokens }) => {
            this.configure({ tokens });
            this.updateBalances();
        });
    }
}
exports.TokenBalancesController = TokenBalancesController;
exports.default = TokenBalancesController;
//# sourceMappingURL=TokenBalancesController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js",}],
[3191, {"../BaseController":3171,"ethereumjs-util":3211}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencesController = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that stores shared settings and exposes convenience methods
 */
class PreferencesController extends BaseController_1.default {
    /**
     * Creates a PreferencesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PreferencesController';
        this.defaultState = {
            featureFlags: {},
            frequentRpcList: [],
            identities: {},
            ipfsGateway: 'https://ipfs.io/ipfs/',
            lostIdentities: {},
            selectedAddress: '',
        };
        this.initialize();
    }
    /**
     * Adds identities to state
     *
     * @param addresses - List of addresses to use to generate new identities
     */
    addIdentities(addresses) {
        const { identities } = this.state;
        addresses.forEach((address) => {
            address = ethereumjs_util_1.toChecksumAddress(address);
            if (identities[address]) {
                return;
            }
            const identityCount = Object.keys(identities).length;
            identities[address] = { name: `Account ${identityCount + 1}`, address };
        });
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Removes an identity from state
     *
     * @param address - Address of the identity to remove
     */
    removeIdentity(address) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { identities } = this.state;
        if (!identities[address]) {
            return;
        }
        delete identities[address];
        this.update({ identities: Object.assign({}, identities) });
        if (address === this.state.selectedAddress) {
            this.update({ selectedAddress: Object.keys(identities)[0] });
        }
    }
    /**
     * Associates a new label with an identity
     *
     * @param address - Address of the identity to associate
     * @param label - New label to assign
     */
    setAccountLabel(address, label) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { identities } = this.state;
        identities[address] = identities[address] || {};
        identities[address].name = label;
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Enable or disable a specific feature flag
     *
     * @param feature - Feature to toggle
     * @param activated - Value to assign
     */
    setFeatureFlag(feature, activated) {
        const oldFeatureFlags = this.state.featureFlags;
        const featureFlags = Object.assign(Object.assign({}, oldFeatureFlags), { [feature]: activated });
        this.update({ featureFlags: Object.assign({}, featureFlags) });
    }
    /**
     * Synchronizes the current identity list with new identities
     *
     * @param addresses - List of addresses corresponding to identities to sync
     * @returns - Newly-selected address after syncing
     */
    syncIdentities(addresses) {
        addresses = addresses.map((address) => ethereumjs_util_1.toChecksumAddress(address));
        const { identities, lostIdentities } = this.state;
        const newlyLost = {};
        for (const identity in identities) {
            if (addresses.indexOf(identity) === -1) {
                newlyLost[identity] = identities[identity];
                delete identities[identity];
            }
        }
        if (Object.keys(newlyLost).length > 0) {
            for (const key in newlyLost) {
                lostIdentities[key] = newlyLost[key];
            }
        }
        this.update({ identities: Object.assign({}, identities), lostIdentities: Object.assign({}, lostIdentities) });
        this.addIdentities(addresses);
        if (addresses.indexOf(this.state.selectedAddress) === -1) {
            this.update({ selectedAddress: addresses[0] });
        }
        return this.state.selectedAddress;
    }
    /**
     * Generates and stores a new list of stored identities based on address
     *
     * @param addresses - List of addresses to use as a basis for each identity
     */
    updateIdentities(addresses) {
        addresses = addresses.map((address) => ethereumjs_util_1.toChecksumAddress(address));
        const oldIdentities = this.state.identities;
        const identities = addresses.reduce((ids, address, index) => {
            ids[address] = oldIdentities[address] || {
                address,
                name: `Account ${index + 1}`,
            };
            return ids;
        }, {});
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Adds custom RPC URL to state
     *
     * @param url - Custom RPC URL
     * @param chainId? - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     * @param rpcPrefs? - Personalized preferences
     *
     */
    addToFrequentRpcList(url, chainId, ticker, nickname, rpcPrefs) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        const newFrequestRpc = { rpcUrl: url, chainId, ticker, nickname, rpcPrefs };
        frequentRpcList.push(newFrequestRpc);
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Removes custom RPC URL from state
     *
     * @param url - Custom RPC URL
     */
    removeFromFrequentRpcList(url) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Sets selected address
     *
     * @param selectedAddress - Ethereum address
     */
    setSelectedAddress(selectedAddress) {
        this.update({ selectedAddress: ethereumjs_util_1.toChecksumAddress(selectedAddress) });
    }
    /**
     * Sets new IPFS gateway
     *
     * @param ipfsGateway - IPFS gateway string
     */
    setIpfsGateway(ipfsGateway) {
        this.update({ ipfsGateway });
    }
}
exports.PreferencesController = PreferencesController;
exports.default = PreferencesController;
//# sourceMappingURL=PreferencesController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/user/PreferencesController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/user/PreferencesController.js",}],
[3175, {"../BaseController":3171,"ethereumjs-util":3211,"human-standard-collectible-abi":1927,"human-standard-token-abi":1928,"single-call-balance-checker-abi":3305,"web3":3525}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsContractController = void 0;
const BaseController_1 = require("../BaseController");
// TODO: Destructuring this line introduces a compilation error
// eslint-disable-next-line prefer-destructuring
const BN = require('ethereumjs-util').BN;
const Web3 = require('web3');
const abiERC20 = require('human-standard-token-abi');
const abiERC721 = require('human-standard-collectible-abi');
const abiSingleCallBalancesContract = require('single-call-balance-checker-abi');
const ERC721METADATA_INTERFACE_ID = '0x5b5e139f';
const ERC721ENUMERABLE_INTERFACE_ID = '0x780e9d63';
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
/**
 * Controller that interacts with contracts on mainnet through web3
 */
class AssetsContractController extends BaseController_1.default {
    /**
     * Creates a AssetsContractController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsContractController';
        this.defaultConfig = {
            provider: undefined,
        };
        this.initialize();
    }
    /**
     *
     * Query if a contract implements an interface
     *
     * @param address - Asset contract address
     * @param interfaceId - Interface identifier
     * @returns - Promise resolving to whether the contract implements `interfaceID`
     */
    contractSupportsInterface(address, interfaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.supportsInterface(interfaceId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Sets a new provider
     *
     * @property provider - Provider used to create a new underlying Web3 instance
     */
    set provider(provider) {
        this.web3 = new Web3(provider);
    }
    /**
     * Query if contract implements ERC721Metadata interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Metadata interface
     */
    contractSupportsMetadataInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721METADATA_INTERFACE_ID);
        });
    }
    /**
     * Query if contract implements ERC721Enumerable interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Enumerable interface
     */
    contractSupportsEnumerableInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721ENUMERABLE_INTERFACE_ID);
        });
    }
    /**
     * Get balance or count for current account on specific asset contract
     *
     * @param address - Asset contract address
     * @param selectedAddress - Current account public address
     * @returns - Promise resolving to BN object containing balance for current account on specific asset contract
     */
    getBalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC20).at(address);
            return new Promise((resolve, reject) => {
                contract.balanceOf(selectedAddress, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Enumerate assets assigned to an owner
     *
     * @param address - ERC721 asset contract address
     * @param selectedAddress - Current account public address
     * @param index - A collectible counter less than `balanceOf(selectedAddress)`
     * @returns - Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'
     */
    getCollectibleTokenId(address, selectedAddress, index) {
        const contract = this.web3.eth.contract(abiERC721).at(address);
        return new Promise((resolve, reject) => {
            contract.tokenOfOwnerByIndex(selectedAddress, index, (error, result) => {
                /* istanbul ignore if */
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result.toNumber());
            });
        });
    }
    /**
     * Query for tokenURI for a given asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the 'tokenURI'
     */
    getCollectibleTokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.tokenURI(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given ERC20 asset
     *
     * @param address - ERC20 asset contract address
     * @returns - Promise resolving to the 'decimals'
     */
    getTokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC20).at(address);
            return new Promise((resolve, reject) => {
                contract.decimals((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'name'
     */
    getAssetName(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.name((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for symbol for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'symbol'
     */
    getAssetSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.symbol((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for owner for a given ERC721 asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the owner address
     */
    getOwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.ownerOf(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns contract instance of
     *
     * @returns - Promise resolving to the 'tokenURI'
     */
    getBalancesInSingleCall(selectedAddress, tokensToDetect) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(abiSingleCallBalancesContract).at(SINGLE_CALL_BALANCES_ADDRESS);
            return new Promise((resolve, reject) => {
                contract.balances([selectedAddress], tokensToDetect, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const nonZeroBalances = {};
                    /* istanbul ignore else */
                    if (result.length > 0) {
                        tokensToDetect.forEach((tokenAddress, index) => {
                            const balance = result[index];
                            /* istanbul ignore else */
                            if (!balance.isZero()) {
                                nonZeroBalances[tokenAddress] = balance;
                            }
                        });
                    }
                    resolve(nonZeroBalances);
                });
            });
        });
    }
}
exports.AssetsContractController = AssetsContractController;
exports.default = AssetsContractController;
//# sourceMappingURL=AssetsContractController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js",}],
[3178, {"../BaseController":3171,"../util":3192,"await-semaphore":1175}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyRateController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const { Mutex } = require('await-semaphore');
/**
 * Controller that passively polls on a set interval for an exchange rate from the current base
 * asset to the current currency
 */
class CurrencyRateController extends BaseController_1.default {
    /**
     * Creates a CurrencyRateController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.activeCurrency = '';
        this.activeNativeCurrency = '';
        this.mutex = new Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'CurrencyRateController';
        this.defaultConfig = {
            currentCurrency: this.getCurrentCurrencyFromState(state),
            disabled: true,
            interval: 180000,
            nativeCurrency: 'ETH',
            includeUSDRate: false,
        };
        this.defaultState = {
            conversionDate: 0,
            conversionRate: 0,
            currentCurrency: this.defaultConfig.currentCurrency,
            nativeCurrency: this.defaultConfig.nativeCurrency,
            usdConversionRate: 0,
        };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        this.poll();
    }
    getCurrentCurrencyFromState(state) {
        return state && state.currentCurrency ? state.currentCurrency : 'usd';
    }
    getPricingURL(currentCurrency, nativeCurrency, includeUSDRate) {
        return (`https://min-api.cryptocompare.com/data/price?fsym=` +
            `${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}` +
            `${includeUSDRate && currentCurrency.toUpperCase() !== 'USD' ? ',USD' : ''}`);
    }
    /**
     * Sets a currency to track
     *
     * @param currentCurrency - ISO 4217 currency code
     */
    set currentCurrency(currentCurrency) {
        this.activeCurrency = currentCurrency;
        util_1.safelyExecute(() => this.updateExchangeRate());
    }
    /**
     * Sets a new native currency
     *
     * @param symbol - Symbol for the base asset
     */
    set nativeCurrency(symbol) {
        this.activeNativeCurrency = symbol;
        util_1.safelyExecute(() => this.updateExchangeRate());
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new exchange rate
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateExchangeRate());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Fetches the exchange rate for a given currency
     *
     * @param currency - ISO 4217 currency code
     * @param nativeCurrency - Symbol for base asset
     * @param includeUSDRate - Whether to add the USD rate to the fetch
     * @returns - Promise resolving to exchange rate for given currency
     */
    fetchExchangeRate(currency, nativeCurrency = this.activeNativeCurrency, includeUSDRate) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield util_1.handleFetch(this.getPricingURL(currency, nativeCurrency, includeUSDRate));
            const conversionRate = Number(json[currency.toUpperCase()]);
            const usdConversionRate = Number(json.USD);
            if (!Number.isFinite(conversionRate)) {
                throw new Error(`Invalid response for ${currency.toUpperCase()}: ${json[currency.toUpperCase()]}`);
            }
            if (includeUSDRate && !Number.isFinite(usdConversionRate)) {
                throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);
            }
            return {
                conversionDate: Date.now() / 1000,
                conversionRate,
                currentCurrency: currency,
                nativeCurrency,
                usdConversionRate,
            };
        });
    }
    /**
     * Updates exchange rate for the current currency
     *
     * @returns Promise resolving to currency data or undefined if disabled
     */
    updateExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled || !this.activeCurrency || !this.activeNativeCurrency) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            try {
                const { conversionDate, conversionRate, usdConversionRate } = yield this.fetchExchangeRate(this.activeCurrency, this.activeNativeCurrency, this.includeUSDRate);
                const newState = {
                    conversionDate,
                    conversionRate,
                    currentCurrency: this.activeCurrency,
                    nativeCurrency: this.activeNativeCurrency,
                    usdConversionRate: this.includeUSDRate ? usdConversionRate : this.defaultState.usdConversionRate,
                };
                this.update(newState);
                return this.state;
            }
            finally {
                releaseLock();
            }
        });
    }
}
exports.CurrencyRateController = CurrencyRateController;
exports.default = CurrencyRateController;
//# sourceMappingURL=CurrencyRateController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js",}],
[3174, {"../BaseController":3171,"../util":3192,"ethjs-query":1854}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTrackerController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const EthjsQuery = require('ethjs-query');
/**
 * Controller that tracks information for all accounts in the current keychain
 */
class AccountTrackerController extends BaseController_1.default {
    /**
     * Creates an AccountTracker instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AccountTrackerController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['PreferencesController'];
        /**
         * Refreshes all accounts in the current keychain
         */
        this.refresh = () => __awaiter(this, void 0, void 0, function* () {
            this.syncAccounts();
            const { accounts } = this.state;
            for (const address in accounts) {
                yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield this.ethjsQuery.getBalance(address);
                    accounts[address] = { balance: util_1.BNToHex(balance) };
                    this.update({ accounts: Object.assign({}, accounts) });
                }));
            }
        });
        this.defaultConfig = {
            interval: 10000,
        };
        this.defaultState = { accounts: {} };
        this.initialize();
    }
    syncAccounts() {
        const { state: { identities }, } = this.context.PreferencesController;
        const { accounts } = this.state;
        const addresses = Object.keys(identities);
        const existing = Object.keys(accounts);
        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
        newAddresses.forEach((address) => {
            accounts[address] = { balance: '0x0' };
        });
        oldAddresses.forEach((address) => {
            delete accounts[address];
        });
        this.update({ accounts: Object.assign({}, accounts) });
    }
    /**
     * Sets a new provider
     *
     * @param provider - Provider used to create a new underlying EthQuery instance
     */
    set provider(provider) {
        this.ethjsQuery = new EthjsQuery(provider);
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const preferences = this.context.PreferencesController;
        preferences.subscribe(this.refresh);
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval trigger a 'refresh'
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.refresh());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
}
exports.AccountTrackerController = AccountTrackerController;
exports.default = AccountTrackerController;
//# sourceMappingURL=AccountTrackerController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js",}],
[3173, {"../BaseController":3171,"eth-rpc-errors":3196,"nanoid":3235}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const nanoid_1 = require("nanoid");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const BaseController_1 = require("../BaseController");
const APPROVALS_STORE_KEY = 'pendingApprovals';
const APPROVAL_COUNT_STORE_KEY = 'pendingApprovalCount';
const getAlreadyPendingMessage = (origin, type) => (`Request of type '${type}' already pending for origin ${origin}. Please wait.`);
const defaultState = { [APPROVALS_STORE_KEY]: {}, [APPROVAL_COUNT_STORE_KEY]: 0 };
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends BaseController_1.default {
    /**
     * @param opts - Options bag
     * @param opts.defaultApprovalType - The default type for approvals.
     * @param opts.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     */
    constructor(config, state) {
        const { defaultApprovalType, showApprovalRequest } = config;
        if (!defaultApprovalType || typeof defaultApprovalType !== 'string') {
            throw new Error('Must specify non-empty string defaultApprovalType.');
        }
        if (typeof showApprovalRequest !== 'function') {
            throw new Error('Must specify function showApprovalRequest.');
        }
        super(config, state || defaultState);
        this.defaultApprovalType = defaultApprovalType;
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this.initialize();
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request. The
     * default type will be used if no type is specified.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request. The
     * default type will be used if no type is specified.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        const info = this.state[APPROVALS_STORE_KEY][id];
        return info
            ? Object.assign({}, info) : undefined;
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a, _b;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return Number(Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type)));
        }
        if (origin) {
            return ((_b = this._origins.get(origin)) === null || _b === void 0 ? void 0 : _b.size) || 0;
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state[APPROVALS_STORE_KEY])) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * @returns The current total approval request count, for all types and
     * origins.
     */
    getTotalApprovalCount() {
        return this.state[APPROVAL_COUNT_STORE_KEY];
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type && typeof _type === 'string') {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            if (typeof _type !== 'string') {
                throw new Error('May not specify non-string type.');
            }
            for (const approval of Object.values(this.state[APPROVALS_STORE_KEY])) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify non-empty string id, origin, or type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    resolve(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     */
    clear() {
        const rejectionError = eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable('The request was rejected; please try again.');
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(defaultState, true);
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type = this.defaultApprovalType, id = nanoid_1.nanoid(), requestData) {
        var _a;
        this._validateAddParams(id, origin, type, requestData);
        if ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(type)) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'May not specify empty or non-string type.';
        }
        else if (requestData && (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        const originSet = this._origins.get(origin) || new Set();
        originSet.add(type);
        if (!this._origins.has(origin)) {
            this._origins.set(origin, originSet);
        }
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _addToStore(id, origin, type, requestData) {
        const approval = { id, origin, type, time: Date.now() };
        if (requestData) {
            approval.requestData = requestData;
        }
        this.update({
            [APPROVALS_STORE_KEY]: Object.assign(Object.assign({}, this.state[APPROVALS_STORE_KEY]), { [id]: approval }),
            [APPROVAL_COUNT_STORE_KEY]: this.state[APPROVAL_COUNT_STORE_KEY] + 1,
        }, true);
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        const approvals = this.state[APPROVALS_STORE_KEY];
        const { origin, type } = approvals[id];
        this._origins.get(origin).delete(type);
        if (this._isEmptyOrigin(origin)) {
            this._origins.delete(origin);
        }
        const newApprovals = Object.assign({}, approvals);
        delete newApprovals[id];
        this.update({
            [APPROVALS_STORE_KEY]: newApprovals,
            [APPROVAL_COUNT_STORE_KEY]: this.state[APPROVAL_COUNT_STORE_KEY] - 1,
        }, true);
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new Error(`Approval with id '${id}' not found.`);
        }
        this._delete(id);
        return callbacks;
    }
    /**
     * Checks whether there are any approvals associated with the given
     * origin.
     *
     * @param origin - The origin to check.
     * @returns True if the origin has no approvals, false otherwise.
     */
    _isEmptyOrigin(origin) {
        var _a;
        return !((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.size);
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/approval/ApprovalController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/approval/ApprovalController.js",}],
[3184, {"../util":3192,"./AbstractMessageManager":3183,"uuid/v1":3463}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
const random = require('uuid/v1');
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class MessageManager extends AbstractMessageManager_1.default {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'MessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = random();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.MessageManager = MessageManager;
exports.default = MessageManager;
//# sourceMappingURL=MessageManager.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js",}],
[3182, {"../BaseController":3171,"await-semaphore":1175,"eth-keyring-controller":1738,"eth-sig-util":1750,"ethereumjs-util":3211,"ethereumjs-wallet":1816,"ethereumjs-wallet/thirdparty":1829}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyringController = exports.KeyringTypes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_sig_util_1 = require("eth-sig-util");
const BaseController_1 = require("../BaseController");
const Keyring = require('eth-keyring-controller');
const { Mutex } = require('await-semaphore');
const Wallet = require('ethereumjs-wallet');
const ethUtil = require('ethereumjs-util');
const importers = require('ethereumjs-wallet/thirdparty');
const privates = new WeakMap();
/**
 * Available keyring types
 */
var KeyringTypes;
(function (KeyringTypes) {
    KeyringTypes["simple"] = "Simple Key Pair";
    KeyringTypes["hd"] = "HD Key Tree";
})(KeyringTypes = exports.KeyringTypes || (exports.KeyringTypes = {}));
/**
 * Controller responsible for establishing and managing user identity
 */
class KeyringController extends BaseController_1.default {
    /**
     * Creates a KeyringController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.mutex = new Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'KeyringController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['PreferencesController'];
        privates.set(this, { keyring: new Keyring(Object.assign({ initState: state }, config)) });
        this.defaultState = Object.assign(Object.assign({}, privates.get(this).keyring.store.getState()), { keyrings: [] });
        this.initialize();
        this.fullUpdate();
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const preferences = this.context.PreferencesController;
            const primaryKeyring = privates.get(this).keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            const oldAccounts = yield privates.get(this).keyring.getAccounts();
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            const newAccounts = yield privates.get(this).keyring.getAccounts();
            yield this.verifySeedPhrase();
            preferences.updateIdentities(newAccounts);
            newAccounts.forEach((selectedAddress) => {
                if (!oldAccounts.includes(selectedAddress)) {
                    preferences.update({ selectedAddress });
                }
            });
            return this.fullUpdate();
        });
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccountWithoutUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates.get(this).keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            yield this.verifySeedPhrase();
            return this.fullUpdate();
        });
    }
    /**
     * Effectively the same as creating a new keychain then populating it
     * using the given seed phrase
     *
     * @param password - Password to unlock keychain
     * @param seed - Seed phrase to restore keychain
     * @returns - Promise resolving to th restored keychain object
     */
    createNewVaultAndRestore(password, seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const preferences = this.context.PreferencesController;
            const releaseLock = yield this.mutex.acquire();
            try {
                preferences.updateIdentities([]);
                const vault = yield privates.get(this).keyring.createNewVaultAndRestore(password, seed);
                preferences.updateIdentities(yield privates.get(this).keyring.getAccounts());
                preferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Create a new primary keychain and wipe any previous keychains
     *
     * @param password - Password to unlock the new vault
     * @returns - Newly-created keychain object
     */
    createNewVaultAndKeychain(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const preferences = this.context.PreferencesController;
            const releaseLock = yield this.mutex.acquire();
            try {
                const vault = yield privates.get(this).keyring.createNewVaultAndKeychain(password);
                preferences.updateIdentities(yield privates.get(this).keyring.getAccounts());
                preferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Returns the status of the vault
     *
     * @returns - Boolean returning true if the vault is unlocked
     */
    isUnlocked() {
        return privates.get(this).keyring.memStore.getState().isUnlocked;
    }
    /**
     * Gets the seed phrase of the HD keyring
     *
     * @param password - Password of the keyring
     * @returns - Promise resolving to the seed phrase
     */
    exportSeedPhrase(password) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.keyrings[0].mnemonic;
        }
        throw new Error('Invalid password');
    }
    /**
     * Gets the private key from the keyring controlling an address
     *
     * @param password - Password of the keyring
     * @param address - Address to export
     * @returns - Promise resolving to the private key for an address
     */
    exportAccount(password, address) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.exportAccount(address);
        }
        throw new Error('Invalid password');
    }
    /**
     * Returns the public addresses of all accounts for the current keyring
     *
     * @returns - A promise resolving to an array of addresses
     */
    getAccounts() {
        return privates.get(this).keyring.getAccounts();
    }
    /**
     * Imports an account with the specified import strategy
     *
     * @param strategy - Import strategy name
     * @param args - Array of arguments to pass to the underlying stategy
     * @returns - Promise resolving to current state when the import is complete
     */
    importAccountWithStrategy(strategy, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let privateKey;
            const preferences = this.context.PreferencesController;
            switch (strategy) {
                case 'privateKey':
                    const [importedKey] = args;
                    if (!importedKey) {
                        throw new Error('Cannot import an empty key.');
                    }
                    const prefixed = ethUtil.addHexPrefix(importedKey);
                    if (!ethUtil.isValidPrivate(ethUtil.toBuffer(prefixed))) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    privateKey = ethUtil.stripHexPrefix(prefixed);
                    break;
                case 'json':
                    let wallet;
                    const [input, password] = args;
                    try {
                        wallet = importers.fromEtherWallet(input, password);
                    }
                    catch (e) {
                        wallet = wallet || Wallet.fromV3(input, password, true);
                    }
                    privateKey = ethUtil.bufferToHex(wallet.getPrivateKey());
                    break;
            }
            const newKeyring = yield privates.get(this).keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);
            const accounts = yield newKeyring.getAccounts();
            const allAccounts = yield privates.get(this).keyring.getAccounts();
            preferences.updateIdentities(allAccounts);
            preferences.update({ selectedAddress: accounts[0] });
            return this.fullUpdate();
        });
    }
    /**
     * Removes an account from keyring state
     *
     * @param address - Address of the account to remove
     * @returns - Promise resolving current state when this account removal completes
     */
    removeAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const preferences = this.context.PreferencesController;
            preferences.removeIdentity(address);
            yield privates.get(this).keyring.removeAccount(address);
            return this.fullUpdate();
        });
    }
    /**
     * Deallocates all secrets and locks the wallet
     *
     * @returns - Promise resolving to current state
     */
    setLocked() {
        return privates.get(this).keyring.setLocked();
    }
    /**
     * Signs message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signMessage(messageParams) {
        return privates.get(this).keyring.signMessage(messageParams);
    }
    /**
     * Signs personal message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signPersonalMessage(messageParams) {
        return privates.get(this).keyring.signPersonalMessage(messageParams);
    }
    /**
     * Signs typed message by calling down into a specific keyring
     *
     * @param messageParams - TypedMessageParams object to sign
     * @param version - Compatibility version EIP712
     * @returns - Promise resolving to a signed message string or an error if any
     */
    signTypedMessage(messageParams, version) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = eth_sig_util_1.normalize(messageParams.from);
                const { password } = privates.get(this).keyring;
                const privateKey = yield this.exportAccount(password, address);
                const privateKeyBuffer = ethUtil.toBuffer(ethUtil.addHexPrefix(privateKey));
                switch (version) {
                    case 'V1':
                        // signTypedDataLegacy will throw if the data is invalid.
                        return eth_sig_util_1.signTypedDataLegacy(privateKeyBuffer, { data: messageParams.data });
                    case 'V3':
                        return eth_sig_util_1.signTypedData(privateKeyBuffer, { data: JSON.parse(messageParams.data) });
                    case 'V4':
                        return eth_sig_util_1.signTypedData_v4(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                }
            }
            catch (error) {
                throw new Error(`Keyring Controller signTypedMessage: ${error}`);
            }
        });
    }
    /**
     * Signs a transaction by calling down into a specific keyring
     *
     * @param transaction - Transaction object to sign
     * @param from - Address to sign from, should be in keychain
     * @returns - Promise resolving to a signed transaction string
     */
    signTransaction(transaction, from) {
        return privates.get(this).keyring.signTransaction(transaction, from);
    }
    /**
     * Attempts to decrypt the current vault and load its keyrings
     *
     * @param password - Password to unlock the keychain
     * @returns - Promise resolving to the current state
     */
    submitPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const preferences = this.context.PreferencesController;
            yield privates.get(this).keyring.submitPassword(password);
            const accounts = yield privates.get(this).keyring.getAccounts();
            yield preferences.syncIdentities(accounts);
            return this.fullUpdate();
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        privates.get(this).keyring.store.subscribe(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        return privates.get(this).keyring.store.unsubscribe(listener);
    }
    /**
     * Adds new listener to be notified when the wallet is locked
     *
     * @param listener - Callback triggered when wallet is locked
     * @returns - EventEmitter if listener added
     */
    onLock(listener) {
        return privates.get(this).keyring.on('lock', listener);
    }
    /**
     * Adds new listener to be notified when the wallet is unlocked
     *
     * @param listener - Callback triggered when wallet is unlocked
     * @returns - EventEmitter if listener added
     */
    onUnlock(listener) {
        return privates.get(this).keyring.on('unlock', listener);
    }
    /**
     * Verifies the that the seed phrase restores the current keychain's accounts
     *
     * @returns - Promise resolving if the verification succeeds
     */
    verifySeedPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates.get(this).keyring.getKeyringsByType(KeyringTypes.hd)[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found.');
            }
            const seedWords = (yield primaryKeyring.serialize()).mnemonic;
            const accounts = yield primaryKeyring.getAccounts();
            /* istanbul ignore if */
            if (accounts.length === 0) {
                throw new Error('Cannot verify an empty keyring.');
            }
            const TestKeyringClass = privates.get(this).keyring.getKeyringClassForType(KeyringTypes.hd);
            const testKeyring = new TestKeyringClass({ mnemonic: seedWords, numberOfAccounts: accounts.length });
            const testAccounts = yield testKeyring.getAccounts();
            /* istanbul ignore if */
            if (testAccounts.length !== accounts.length) {
                throw new Error('Seed phrase imported incorrect number of accounts.');
            }
            testAccounts.forEach((account, i) => {
                /* istanbul ignore if */
                if (account.toLowerCase() !== accounts[i].toLowerCase()) {
                    throw new Error('Seed phrase imported different accounts.');
                }
            });
            return seedWords;
        });
    }
    /**
     * Update keyrings in state and calls KeyringController fullUpdate method returning current state
     *
     * @returns - Promise resolving to current state
     */
    fullUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyrings = yield Promise.all(privates.get(this).keyring.keyrings.map((keyring, index) => __awaiter(this, void 0, void 0, function* () {
                const keyringAccounts = yield keyring.getAccounts();
                const accounts = Array.isArray(keyringAccounts)
                    ? keyringAccounts.map((address) => ethereumjs_util_1.toChecksumAddress(address))
                    : /* istanbul ignore next */ [];
                return {
                    accounts,
                    index,
                    type: keyring.type,
                };
            })));
            this.update({ keyrings: [...keyrings] });
            return privates.get(this).keyring.fullUpdate();
        });
    }
}
exports.KeyringController = KeyringController;
exports.default = KeyringController;
//# sourceMappingURL=KeyringController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/keyring/KeyringController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/keyring/KeyringController.js",}],
[3186, {"../util":3192,"./AbstractMessageManager":3183,"uuid/v1":3463}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMessageManager = void 0;
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
const random = require('uuid/v1');
/**
 * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.
 */
class TypedMessageManager extends AbstractMessageManager_1.default {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TypedMessageManager';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['NetworkController'];
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
     *
     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, version, req) {
        return new Promise((resolve, reject) => {
            if (version === 'V1') {
                util_1.validateTypedSignMessageDataV1(messageParams);
            }
            if (version === 'V3') {
                util_1.validateTypedSignMessageDataV3(messageParams);
            }
            const messageId = this.addUnapprovedMessage(messageParams, version, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
                    case 'errored':
                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
                    default:
                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
     * unapproved TypedMessages.
     *
     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
     * is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created TypedMessage
     */
    addUnapprovedMessage(messageParams, version, req) {
        const messageId = random();
        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
        if (req) {
            messageParams.origin = req.origin;
        }
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_signTypedData',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
        return messageId;
    }
    /**
     * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the TypedMessage to error
     * @param error - The error to be included in TypedMessage
     */
    setMessageStatusErrored(messageId, error) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.error = error;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'errored');
    }
    /**
     * Removes the metamaskId and version properties from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId and version properties removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        delete messageParams.version;
        return Promise.resolve(messageParams);
    }
}
exports.TypedMessageManager = TypedMessageManager;
exports.default = TypedMessageManager;
//# sourceMappingURL=TypedMessageManager.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js",}],
[3176, {"../BaseController":3171,"../util":3192,"await-semaphore":1175,"ethereumjs-util":3211,"events":1429,"uuid/v1":3463}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsController = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const { Mutex } = require('await-semaphore');
const random = require('uuid/v1');
/**
 * Controller that stores assets and exposes convenience methods
 */
class AssetsController extends BaseController_1.default {
    /**
     * Creates a AssetsController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.mutex = new Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['AssetsContractController', 'NetworkController', 'PreferencesController'];
        this.defaultConfig = {
            networkType: 'mainnet',
            selectedAddress: '',
        };
        this.defaultState = {
            allCollectibleContracts: {},
            allCollectibles: {},
            allTokens: {},
            collectibleContracts: [],
            collectibles: [],
            ignoredCollectibles: [],
            ignoredTokens: [],
            suggestedAssets: [],
            tokens: [],
        };
        this.initialize();
    }
    getCollectibleApi(contractAddress, tokenId) {
        return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;
    }
    getCollectibleContractInformationApi(contractAddress) {
        return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;
    }
    failSuggestedAsset(suggestedAssetMeta, error) {
        suggestedAssetMeta.status = 'failed';
        suggestedAssetMeta.error = {
            message: error.toString(),
            stack: error.stack,
        };
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
    }
    /**
     * Get collectible tokenURI API following ERC721
     *
     * @param contractAddress - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Collectible tokenURI
     */
    getCollectibleTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetsContract = this.context.AssetsContractController;
            const supportsMetadata = yield assetsContract.contractSupportsMetadataInterface(contractAddress);
            /* istanbul ignore if */
            if (!supportsMetadata) {
                return '';
            }
            const tokenURI = yield assetsContract.getCollectibleTokenURI(contractAddress, tokenId);
            return tokenURI;
        });
    }
    /**
     * Request individual collectible information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromApi(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = this.getCollectibleApi(contractAddress, tokenId);
            let collectibleInformation;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                collectibleInformation = yield util_1.handleFetch(tokenURI, { headers: { 'X-API-KEY': this.openSeaApiKey } });
            }
            else {
                collectibleInformation = yield util_1.handleFetch(tokenURI);
            }
            const { name, description, image_original_url } = collectibleInformation;
            return { image: image_original_url, name, description };
        });
    }
    /**
     * Request individual collectible information from contracts that follows Metadata Interface
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = yield this.getCollectibleTokenURI(contractAddress, tokenId);
            const object = yield util_1.handleFetch(tokenURI);
            const image = object.hasOwnProperty('image') ? 'image' : /* istanbul ignore next */ 'image_url';
            return { image: object[image], name: object.name };
        });
    }
    /**
     * Request individual collectible information (name, image url and description)
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformation(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromApi(contractAddress, tokenId);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);
            }));
            /* istanbul ignore next */
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {};
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromApi(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = this.getCollectibleContractInformationApi(contractAddress);
            let collectibleContractObject;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                collectibleContractObject = yield util_1.handleFetch(api, { headers: { 'X-API-KEY': this.openSeaApiKey } });
            }
            else {
                collectibleContractObject = yield util_1.handleFetch(api);
            }
            const { name, symbol, image_url, description, total_supply } = collectibleContractObject;
            return { name, symbol, image_url, description, total_supply };
        });
    }
    /**
     * Request collectible contract information from the contract itself
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromContract(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetsContractController = this.context.AssetsContractController;
            const name = yield assetsContractController.getAssetName(contractAddress);
            const symbol = yield assetsContractController.getAssetSymbol(contractAddress);
            return { name, symbol };
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the collectible contract name, image and description
     */
    getCollectibleContractInformation(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromApi(contractAddress);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromContract(contractAddress);
            }));
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {};
        });
    }
    /**
     * Adds an individual collectible to the stored collectible list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param opts - Collectible optional information (name, image and description)
     * @returns - Promise resolving to the current collectible list
     */
    addIndividualCollectible(address, tokenId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = ethereumjs_util_1.toChecksumAddress(address);
                const { allCollectibles, collectibles } = this.state;
                const { networkType, selectedAddress } = this.config;
                const existingEntry = collectibles.find((collectible) => collectible.address === address && collectible.tokenId === tokenId);
                if (existingEntry) {
                    return collectibles;
                }
                const { name, image, description } = opts || (yield this.getCollectibleInformation(address, tokenId));
                const newEntry = { address, tokenId, name, image, description };
                const newCollectibles = [...collectibles, newEntry];
                const addressCollectibles = allCollectibles[selectedAddress];
                const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [networkType]: newCollectibles });
                const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
                this.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });
                return newCollectibles;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @param detection? - Whether the collectible is manually added or auto-detected
     * @returns - Promise resolving to the current collectible contracts list
     */
    addCollectibleContract(address, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = ethereumjs_util_1.toChecksumAddress(address);
                const { allCollectibleContracts, collectibleContracts } = this.state;
                const { networkType, selectedAddress } = this.config;
                const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address === address);
                if (existingEntry) {
                    return collectibleContracts;
                }
                const contractInformation = yield this.getCollectibleContractInformation(address);
                const { name, symbol, image_url, description, total_supply } = contractInformation;
                // If being auto-detected opensea information is expected
                // Oherwise at least name and symbol from contract is needed
                if ((detection && !image_url) || Object.keys(contractInformation).length === 0) {
                    return collectibleContracts;
                }
                const newEntry = {
                    address,
                    description,
                    logo: image_url,
                    name,
                    symbol,
                    totalSupply: total_supply,
                };
                const newCollectibleContracts = [...collectibleContracts, newEntry];
                const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
                const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [networkType]: newCollectibleContracts });
                const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
                this.update({
                    allCollectibleContracts: newAllCollectibleContracts,
                    collectibleContracts: newCollectibleContracts,
                });
                return newCollectibleContracts;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Removes an individual collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreIndividualCollectible(address, tokenId) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { allCollectibles, collectibles, ignoredCollectibles } = this.state;
        const { networkType, selectedAddress } = this.config;
        const newIgnoredCollectibles = [...ignoredCollectibles];
        const newCollectibles = collectibles.filter((collectible) => {
            if (collectible.address === address && collectible.tokenId === tokenId) {
                const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);
                !alreadyIgnored && newIgnoredCollectibles.push(collectible);
                return false;
            }
            return true;
        });
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [networkType]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({
            allCollectibles: newAllCollectibles,
            collectibles: newCollectibles,
            ignoredCollectibles: newIgnoredCollectibles,
        });
    }
    /**
     * Removes an individual collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeIndividualCollectible(address, tokenId) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { allCollectibles, collectibles } = this.state;
        const { networkType, selectedAddress } = this.config;
        const newCollectibles = collectibles.filter((collectible) => !(collectible.address === address && collectible.tokenId === tokenId));
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [networkType]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });
    }
    /**
     * Removes a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible contracts list
     */
    removeCollectibleContract(address) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { allCollectibleContracts, collectibleContracts } = this.state;
        const { networkType, selectedAddress } = this.config;
        const newCollectibleContracts = collectibleContracts.filter((collectibleContract) => !(collectibleContract.address === address));
        const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
        const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [networkType]: newCollectibleContracts });
        const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
        this.update({
            allCollectibleContracts: newAllCollectibleContracts,
            collectibleContracts: newCollectibleContracts,
        });
        return newCollectibleContracts;
    }
    /**
     * Sets an OpenSea API key to retrieve collectible information
     *
     * @param openSeaApiKey - OpenSea API key
     */
    setApiKey(openSeaApiKey) {
        this.openSeaApiKey = openSeaApiKey;
    }
    /**
     * Adds a token to the stored token list
     *
     * @param address - Hex address of the token contract
     * @param symbol - Symbol of the token
     * @param decimals - Number of decimals the token uses
     * @param image - Image of the token
     * @returns - Current token list
     */
    addToken(address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = ethereumjs_util_1.toChecksumAddress(address);
                const { allTokens, tokens } = this.state;
                const { networkType, selectedAddress } = this.config;
                const newEntry = { address, symbol, decimals, image };
                const previousEntry = tokens.find((token) => token.address === address);
                if (previousEntry) {
                    const previousIndex = tokens.indexOf(previousEntry);
                    tokens[previousIndex] = newEntry;
                }
                else {
                    tokens.push(newEntry);
                }
                const addressTokens = allTokens[selectedAddress];
                const newAddressTokens = Object.assign(Object.assign({}, addressTokens), { [networkType]: tokens });
                const newAllTokens = Object.assign(Object.assign({}, allTokens), { [selectedAddress]: newAddressTokens });
                const newTokens = [...tokens];
                this.update({ allTokens: newAllTokens, tokens: newTokens });
                return newTokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a new suggestedAsset to state. Parameters will be validated according to
     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
     *
     * @param asset - Asset to be watched. For now only ERC20 tokens are accepted.
     * @param type - Asset type
     * @returns - Object containing a promise resolving to the suggestedAsset address if accepted
     */
    watchAsset(asset, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const suggestedAssetMeta = {
                asset,
                id: random(),
                status: 'pending',
                time: Date.now(),
                type,
            };
            try {
                switch (type) {
                    case 'ERC20':
                        util_1.validateTokenToWatch(asset);
                        break;
                    default:
                        throw new Error(`Asset of type ${type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case 'accepted':
                            return resolve(meta.asset.address);
                        case 'rejected':
                            return reject(new Error('User rejected to watch the asset.'));
                        case 'failed':
                            return reject(new Error(meta.error.message));
                    }
                });
            });
            const { suggestedAssets } = this.state;
            suggestedAssets.push(suggestedAssetMeta);
            this.update({ suggestedAssets: [...suggestedAssets] });
            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
            return { result, suggestedAssetMeta };
        });
    }
    /**
     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
     * adding the asset to corresponding asset state. In this case ERC20 tokens.
     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     * @returns - Promise resolving when this operation completes
     */
    acceptWatchAsset(suggestedAssetID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { suggestedAssets } = this.state;
            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
            const suggestedAssetMeta = suggestedAssets[index];
            try {
                switch (suggestedAssetMeta.type) {
                    case 'ERC20':
                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
                        yield this.addToken(address, symbol, decimals, image);
                        suggestedAssetMeta.status = 'accepted';
                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                        break;
                    default:
                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
            }
            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
            this.update({ suggestedAssets: [...newSuggestedAssets] });
        });
    }
    /**
     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     */
    rejectWatchAsset(suggestedAssetID) {
        const { suggestedAssets } = this.state;
        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
        const suggestedAssetMeta = suggestedAssets[index];
        if (!suggestedAssetMeta) {
            return;
        }
        suggestedAssetMeta.status = 'rejected';
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
        this.update({ suggestedAssets: [...newSuggestedAssets] });
    }
    /**
     * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param opts - Collectible optional information (name, image and description)
     * @param detection? - Whether the collectible is manually added or autodetected
     * @returns - Promise resolving to the current collectible list
     */
    addCollectible(address, tokenId, opts, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            address = ethereumjs_util_1.toChecksumAddress(address);
            const newCollectibleContracts = yield this.addCollectibleContract(address, detection);
            // If collectible contract was not added, do not add individual collectible
            const collectibleContract = newCollectibleContracts.find((contract) => contract.address === address);
            // If collectible contract information, add individual collectible
            if (collectibleContract) {
                yield this.addIndividualCollectible(address, tokenId, opts);
            }
        });
    }
    /**
     * Removes a token from the stored token list and saves it in ignored tokens list
     *
     * @param address - Hex address of the token contract
     */
    removeAndIgnoreToken(address) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { allTokens, tokens, ignoredTokens } = this.state;
        const { networkType, selectedAddress } = this.config;
        const newIgnoredTokens = [...ignoredTokens];
        const newTokens = tokens.filter((token) => {
            if (token.address === address) {
                const alreadyIgnored = newIgnoredTokens.find((t) => t.address === address);
                !alreadyIgnored && newIgnoredTokens.push(token);
                return false;
            }
            return true;
        });
        const addressTokens = allTokens[selectedAddress];
        const newAddressTokens = Object.assign(Object.assign({}, addressTokens), { [networkType]: newTokens });
        const newAllTokens = Object.assign(Object.assign({}, allTokens), { [selectedAddress]: newAddressTokens });
        this.update({ allTokens: newAllTokens, tokens: newTokens, ignoredTokens: newIgnoredTokens });
    }
    /**
     * Removes a token from the stored token list
     *
     * @param address - Hex address of the token contract
     */
    removeToken(address) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        const { allTokens, tokens } = this.state;
        const { networkType, selectedAddress } = this.config;
        const newTokens = tokens.filter((token) => token.address !== address);
        const addressTokens = allTokens[selectedAddress];
        const newAddressTokens = Object.assign(Object.assign({}, addressTokens), { [networkType]: newTokens });
        const newAllTokens = Object.assign(Object.assign({}, allTokens), { [selectedAddress]: newAddressTokens });
        this.update({ allTokens: newAllTokens, tokens: newTokens });
    }
    /**
     * Removes a collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeCollectible(address, tokenId) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        this.removeIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address === address);
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes a collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreCollectible(address, tokenId) {
        address = ethereumjs_util_1.toChecksumAddress(address);
        this.removeAndIgnoreIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address === address);
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes all tokens from the ignored list
     */
    clearIgnoredTokens() {
        this.update({ ignoredTokens: [] });
    }
    /**
     * Removes all collectibles from the ignored list
     */
    clearIgnoredCollectibles() {
        this.update({ ignoredCollectibles: [] });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const preferences = this.context.PreferencesController;
        const network = this.context.NetworkController;
        preferences.subscribe(({ selectedAddress }) => {
            const { allCollectibleContracts, allCollectibles, allTokens } = this.state;
            const { networkType } = this.config;
            this.configure({ selectedAddress });
            this.update({
                collectibleContracts: (allCollectibleContracts[selectedAddress] && allCollectibleContracts[selectedAddress][networkType]) || [],
                collectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],
                tokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || [],
            });
        });
        network.subscribe(({ provider }) => {
            const { allCollectibleContracts, allCollectibles, allTokens } = this.state;
            const { selectedAddress } = this.config;
            const networkType = provider.type;
            this.configure({ networkType });
            this.update({
                collectibleContracts: (allCollectibleContracts[selectedAddress] && allCollectibleContracts[selectedAddress][networkType]) || [],
                collectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],
                tokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || [],
            });
        });
    }
}
exports.AssetsController = AssetsController;
exports.default = AssetsController;
//# sourceMappingURL=AssetsController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsController.js",}],
[3177, {"../BaseController":3171,"../util":3192,"@metamask/contract-metadata":857,"ethereumjs-util":3211}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsDetectionController = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const contractMap = require('@metamask/contract-metadata');
const DEFAULT_INTERVAL = 180000;
const MAINNET = 'mainnet';
/**
 * Controller that passively polls on a set interval for assets auto detection
 */
class AssetsDetectionController extends BaseController_1.default {
    /**
     * Creates a AssetsDetectionController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsDetectionController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['AssetsContractController', 'AssetsController', 'NetworkController', 'PreferencesController'];
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: 'mainnet',
            selectedAddress: '',
            tokens: [],
        };
        this.initialize();
        this.poll();
    }
    getOwnerCollectiblesApi(address) {
        return `https://api.opensea.io/api/v1/assets?owner=${address}&limit=300`;
    }
    getOwnerCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            const { selectedAddress } = this.config;
            const api = this.getOwnerCollectiblesApi(selectedAddress);
            const assetsController = this.context.AssetsController;
            let response;
            try {
                /* istanbul ignore if */
                if (assetsController.openSeaApiKey) {
                    response = yield util_1.timeoutFetch(api, { headers: { 'X-API-KEY': assetsController.openSeaApiKey } }, 15000);
                }
                else {
                    response = yield util_1.timeoutFetch(api, {}, 15000);
                }
            }
            catch (e) {
                /* istanbul ignore next */
                return [];
            }
            const collectiblesArray = yield response.json();
            const collectibles = collectiblesArray.assets;
            return collectibles;
        });
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to auto detect assets
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.detectAssets();
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Checks whether network is mainnet or not
     *
     * @returns - Whether current network is mainnet
     */
    isMainnet() {
        if (this.config.networkType !== MAINNET || this.disabled) {
            return false;
        }
        return true;
    }
    /**
     * Detect assets owned by current account on mainnet
     */
    detectAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            this.detectTokens();
            this.detectCollectibles();
        });
    }
    /**
     * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet
     */
    detectTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const tokensAddresses = this.config.tokens.filter(/* istanbul ignore next*/ (token) => token.address);
            const tokensToDetect = [];
            for (const address in contractMap) {
                const contract = contractMap[address];
                if (contract.erc20 && !(address in tokensAddresses)) {
                    tokensToDetect.push(address);
                }
            }
            const assetsContractController = this.context.AssetsContractController;
            const { selectedAddress } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                const balances = yield assetsContractController.getBalancesInSingleCall(selectedAddress, tokensToDetect);
                const assetsController = this.context.AssetsController;
                const { ignoredTokens } = assetsController.state;
                for (const tokenAddress in balances) {
                    let ignored;
                    /* istanbul ignore else */
                    if (ignoredTokens.length) {
                        ignored = ignoredTokens.find((token) => token.address === ethereumjs_util_1.toChecksumAddress(tokenAddress));
                    }
                    if (!ignored) {
                        yield assetsController.addToken(tokenAddress, contractMap[tokenAddress].symbol, contractMap[tokenAddress].decimals);
                    }
                }
            }));
        });
    }
    /**
     * Triggers asset ERC721 token auto detection on mainnet
     * adding new collectibles and removing not owned collectibles
     */
    detectCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const { selectedAddress } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                const assetsController = this.context.AssetsController;
                const { ignoredCollectibles } = assetsController.state;
                let collectiblesToRemove = assetsController.state.collectibles;
                const apiCollectibles = yield this.getOwnerCollectibles();
                const addCollectiblesPromises = apiCollectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                    const { token_id, image_original_url, name, description, asset_contract: { address }, } = collectible;
                    let ignored;
                    /* istanbul ignore else */
                    if (ignoredCollectibles.length) {
                        ignored = ignoredCollectibles.find((c) => {
                            /* istanbul ignore next */
                            return c.address === ethereumjs_util_1.toChecksumAddress(address) && c.tokenId === Number(token_id);
                        });
                    }
                    /* istanbul ignore else */
                    if (!ignored) {
                        yield assetsController.addCollectible(address, Number(token_id), {
                            description,
                            image: image_original_url,
                            name,
                        }, true);
                    }
                    collectiblesToRemove = collectiblesToRemove.filter((c) => {
                        return !(c.tokenId === Number(token_id) && c.address === ethereumjs_util_1.toChecksumAddress(address));
                    });
                }));
                yield Promise.all(addCollectiblesPromises);
                collectiblesToRemove.forEach(({ address, tokenId }) => {
                    assetsController.removeCollectible(address, tokenId);
                });
            }));
        });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const preferences = this.context.PreferencesController;
        const network = this.context.NetworkController;
        const assets = this.context.AssetsController;
        assets.subscribe(({ tokens }) => {
            this.configure({ tokens });
        });
        preferences.subscribe(({ selectedAddress }) => {
            const actualSelectedAddress = this.config.selectedAddress;
            if (selectedAddress !== actualSelectedAddress) {
                this.configure({ selectedAddress });
                this.detectAssets();
            }
        });
        network.subscribe(({ provider }) => {
            this.configure({ networkType: provider.type });
        });
    }
}
exports.AssetsDetectionController = AssetsDetectionController;
exports.default = AssetsDetectionController;
//# sourceMappingURL=AssetsDetectionController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js",}],
[3185, {"../util":3192,"./AbstractMessageManager":3183,"uuid/v1":3463}, function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonalMessageManager = void 0;
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
const random = require('uuid/v1');
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class PersonalMessageManager extends AbstractMessageManager_1.default {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PersonalMessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = random();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'personal_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.PersonalMessageManager = PersonalMessageManager;
exports.default = PersonalMessageManager;
//# sourceMappingURL=PersonalMessageManager.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js",}],
[3187, {"../BaseController":3171,"await-semaphore":1175,"eth-json-rpc-infura/src/createProvider":1692,"eth-query":1744,"web3-provider-engine//zero.js":3523,"web3-provider-engine/subproviders/provider.js":3513}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkController = void 0;
const BaseController_1 = require("../BaseController");
const EthQuery = require('eth-query');
const Subprovider = require('web3-provider-engine/subproviders/provider.js');
const createInfuraProvider = require('eth-json-rpc-infura/src/createProvider');
const createMetamaskProvider = require('web3-provider-engine//zero.js');
const { Mutex } = require('await-semaphore');
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * Controller that creates and manages an Ethereum network provider
 */
class NetworkController extends BaseController_1.default {
    /**
     * Creates a NetworkController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.internalProviderConfig = {};
        this.mutex = new Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'NetworkController';
        this.defaultState = {
            network: 'loading',
            provider: { type: 'mainnet' },
        };
        this.initialize();
    }
    initializeProvider(type, rpcTarget, chainId, ticker, nickname) {
        switch (type) {
            case 'kovan':
            case 'mainnet':
            case 'rinkeby':
            case 'goerli':
            case 'ropsten':
                this.setupInfuraProvider(type);
                break;
            case 'localhost':
                this.setupStandardProvider(LOCALHOST_RPC_URL);
                break;
            case 'rpc':
                rpcTarget && this.setupStandardProvider(rpcTarget, chainId, ticker, nickname);
                break;
        }
    }
    refreshNetwork() {
        this.update({ network: 'loading' });
        const { rpcTarget, type, chainId, ticker } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker);
        this.lookupNetwork();
    }
    registerProvider() {
        this.provider.on('error', this.verifyNetwork.bind(this));
        this.ethQuery = new EthQuery(this.provider);
    }
    setupInfuraProvider(type) {
        const infuraProvider = createInfuraProvider({ network: type, projectId: this.config.infuraProjectId });
        const infuraSubprovider = new Subprovider(infuraProvider);
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            dataSubprovider: infuraSubprovider,
            engineParams: {
                blockTrackerProvider: infuraProvider,
                pollingInterval: 12000,
            },
        });
        this.updateProvider(createMetamaskProvider(config));
    }
    setupStandardProvider(rpcTarget, chainId, ticker, nickname) {
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            chainId,
            engineParams: { pollingInterval: 12000 },
            nickname,
            rpcUrl: rpcTarget,
            ticker,
        });
        this.updateProvider(createMetamaskProvider(config));
    }
    updateProvider(provider) {
        this.safelyStopProvider(this.provider);
        this.provider = provider;
        this.registerProvider();
    }
    safelyStopProvider(provider) {
        setTimeout(() => {
            provider && provider.stop();
        }, 500);
    }
    verifyNetwork() {
        this.state.network === 'loading' && this.lookupNetwork();
    }
    /**
     * Sets a new configuration for web3-provider-engine
     *
     * @param providerConfig - web3-provider-engine configuration
     */
    set providerConfig(providerConfig) {
        this.internalProviderConfig = providerConfig;
        const { type, rpcTarget, chainId, ticker, nickname } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker, nickname);
        this.registerProvider();
        this.lookupNetwork();
    }
    /**
     * Refreshes the current network code
     */
    lookupNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.ethQuery || !this.ethQuery.sendAsync) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            this.ethQuery.sendAsync({ method: 'net_version' }, (error, network) => {
                this.update({ network: error ? /* istanbul ignore next*/ 'loading' : network });
                releaseLock();
            });
        });
    }
    /**
     * Convenience method to update provider network type settings
     *
     * @param type - Human readable network name
     */
    setProviderType(type) {
        const _a = this.state.provider, { rpcTarget, chainId, nickname } = _a, providerState = __rest(_a, ["rpcTarget", "chainId", "nickname"]);
        this.update({
            provider: Object.assign(Object.assign({}, providerState), { type, ticker: 'ETH' }),
        });
        this.refreshNetwork();
    }
    /**
     * Convenience method to update provider RPC settings
     *
     * @param rpcTarget - RPC endpoint URL
     * @param chainId? - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     */
    setRpcTarget(rpcTarget, chainId, ticker, nickname) {
        this.update({
            provider: Object.assign(Object.assign({}, this.state.provider), { type: 'rpc', ticker, rpcTarget, chainId, nickname }),
        });
        this.refreshNetwork();
    }
}
exports.NetworkController = NetworkController;
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/network/NetworkController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/network/NetworkController.js",}],
[3188, {"../BaseController":3171,"../util":3192,"eth-phishing-detect/src/config.json":1742,"eth-phishing-detect/src/detector":1743}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhishingController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const DEFAULT_PHISHING_RESPONSE = require('eth-phishing-detect/src/config.json');
const PhishingDetector = require('eth-phishing-detect/src/detector');
/**
 * Controller that passively polls on a set interval for approved and unapproved website origins
 */
class PhishingController extends BaseController_1.default {
    /**
     * Creates a PhishingController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.configUrl = 'https://cdn.jsdelivr.net/gh/MetaMask/eth-phishing-detect@master/src/config.json';
        /**
         * Name of this controller used during composition
         */
        this.name = 'PhishingController';
        this.defaultConfig = { interval: 60 * 60 * 1000 };
        this.defaultState = {
            phishing: DEFAULT_PHISHING_RESPONSE,
            whitelist: [],
        };
        this.detector = new PhishingDetector(this.defaultState.phishing);
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new approval lists
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updatePhishingLists());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Determines if a given origin is unapproved
     *
     * @param origin - Domain origin of a website
     * @returns - True if the origin is an unapproved origin
     */
    test(origin) {
        if (this.state.whitelist.indexOf(origin) !== -1) {
            return false;
        }
        return this.detector.check(origin).result;
    }
    /**
     * Temporarily marks a given origin as approved
     */
    bypass(origin) {
        const { whitelist } = this.state;
        if (whitelist.indexOf(origin) !== -1) {
            return;
        }
        this.update({ whitelist: [...whitelist, origin] });
    }
    /**
     * Updates lists of approved and unapproved website origins
     *
     * @returns Promise resolving when this operation completes
     */
    updatePhishingLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const phishingOpts = yield this.queryConfig(this.configUrl);
            if (phishingOpts) {
                this.detector = new PhishingDetector(phishingOpts);
                this.update({
                    phishing: phishingOpts,
                });
            }
        });
    }
    queryConfig(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(input, { cache: 'no-cache' });
            switch (response.status) {
                case 200: {
                    return yield response.json();
                }
                case 304:
                case 403: {
                    return null;
                }
                default: {
                    throw new Error(`Fetch failed with status '${response.status}' for request '${input}'`);
                }
            }
        });
    }
}
exports.PhishingController = PhishingController;
exports.default = PhishingController;
//# sourceMappingURL=PhishingController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/third-party/PhishingController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/third-party/PhishingController.js",}],
[3192, {"buffer":1428,"eth-ens-namehash":1667,"eth-rpc-errors":3196,"eth-sig-util":1750,"ethereumjs-util":3211,"jsonschema":2287}, function (require, module, exports) {
(function (Buffer){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeEnsName = exports.timeoutFetch = exports.handleFetch = exports.successfulFetch = exports.isSmartContractCode = exports.validateTokenToWatch = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = exports.validateTransaction = exports.safelyExecute = exports.normalizeTransaction = exports.hexToText = exports.hexToBN = exports.handleTransactionFetch = exports.getAlethioApiUrl = exports.getEtherscanApiUrl = exports.getBuyURL = exports.fractionBN = exports.BNToHex = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_sig_util_1 = require("eth-sig-util");
const jsonschema = require('jsonschema');
const { BN, stripHexPrefix } = require('ethereumjs-util');
const ensNamehash = require('eth-ens-namehash');
const hexRe = /^[0-9A-Fa-f]+$/gu;
const NORMALIZERS = {
    data: (data) => ethereumjs_util_1.addHexPrefix(data),
    from: (from) => ethereumjs_util_1.addHexPrefix(from).toLowerCase(),
    gas: (gas) => ethereumjs_util_1.addHexPrefix(gas),
    gasPrice: (gasPrice) => ethereumjs_util_1.addHexPrefix(gasPrice),
    nonce: (nonce) => ethereumjs_util_1.addHexPrefix(nonce),
    to: (to) => ethereumjs_util_1.addHexPrefix(to).toLowerCase(),
    value: (value) => ethereumjs_util_1.addHexPrefix(value),
};
/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - BN instance to convert to a hex string
 * @returns - '0x'-prefixed hex string
 *
 */
function BNToHex(inputBn) {
    return ethereumjs_util_1.addHexPrefix(inputBn.toString(16));
}
exports.BNToHex = BNToHex;
/**
 * Used to multiply a BN by a fraction
 *
 * @param targetBN - Number to multiply by a fraction
 * @param numerator - Numerator of the fraction multiplier
 * @param denominator - Denominator of the fraction multiplier
 * @returns - Product of the multiplication
 */
function fractionBN(targetBN, numerator, denominator) {
    const numBN = new BN(numerator);
    const denomBN = new BN(denominator);
    return targetBN.mul(numBN).div(denomBN);
}
exports.fractionBN = fractionBN;
/**
 * Return a URL that can be used to obtain ETH for a given network
 *
 * @param networkCode - Network code of desired network
 * @param address - Address to deposit obtained ETH
 * @param amount - How much ETH is desired
 * @returns - URL to buy ETH based on network
 */
function getBuyURL(networkCode = '1', address, amount = 5) {
    switch (networkCode) {
        case '1':
            return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
        case '3':
            return 'https://faucet.metamask.io/';
        case '4':
            return 'https://www.rinkeby.io/';
        case '5':
            return 'https://goerli-faucet.slock.it/';
        case '42':
            return 'https://github.com/kovan-testnet/faucet';
    }
}
exports.getBuyURL = getBuyURL;
/**
 * Return a URL that can be used to fetch ETH transactions
 *
 * @param networkType - Network type of desired network
 * @param address - Address to get the transactions from
 * @param fromBlock? - Block from which transactions are needed
 * @returns - URL to fetch the transactions from
 */
function getEtherscanApiUrl(networkType, address, fromBlock) {
    let etherscanSubdomain = 'api';
    /* istanbul ignore next */
    if (networkType !== 'mainnet') {
        etherscanSubdomain = `api-${networkType}`;
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1`;
    if (fromBlock) {
        url += `&startBlock=${fromBlock}`;
    }
    return url;
}
exports.getEtherscanApiUrl = getEtherscanApiUrl;
/**
 * Return a URL that can be used to fetch ERC20 token transactions
 *
 * @param networkType - Network type of desired network
 * @param address - Address to get the transactions from
 * @param opt? - Object that can contain fromBlock and Alethio service API key
 * @returns - URL to fetch the transactions from
 */
function getAlethioApiUrl(networkType, address, opt) {
    if (networkType !== 'mainnet') {
        return { url: '', headers: {} };
    }
    let url = `https://api.aleth.io/v1/token-transfers?filter[to]=${address}`;
    // From alethio implementation
    // cursor = hardcoded prefix `0x00` + fromBlock in hex format + max possible tx index `ffff`
    let fromBlock = opt && opt.fromBlock;
    if (fromBlock) {
        fromBlock = parseInt(fromBlock).toString(16);
        let prev = `0x00${fromBlock}ffff`;
        while (prev.length < 34) {
            prev += '0';
        }
        url += `&page[prev]=${prev}`;
    }
    /* istanbul ignore next */
    const headers = opt && opt.alethioApiKey ? { Authorization: `Bearer ${opt.alethioApiKey}` } : undefined;
    return { url, headers };
}
exports.getAlethioApiUrl = getAlethioApiUrl;
/**
 * Handles the fetch of incoming transactions
 *
 * @param networkType - Network type of desired network
 * @param address - Address to get the transactions from
 * @param opt? - Object that can contain fromBlock and Alethio service API key
 * @returns - Responses for both ETH and ERC20 token transactions
 */
function handleTransactionFetch(networkType, address, opt) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = getEtherscanApiUrl(networkType, address, opt && opt.fromBlock);
        const etherscanResponsePromise = handleFetch(url);
        const alethioUrl = getAlethioApiUrl(networkType, address, opt);
        const alethioResponsePromise = alethioUrl.url !== '' && handleFetch(alethioUrl.url, { headers: alethioUrl.headers });
        let [etherscanResponse, alethioResponse] = yield Promise.all([etherscanResponsePromise, alethioResponsePromise]);
        if (etherscanResponse.status === '0' || etherscanResponse.result.length <= 0) {
            etherscanResponse = { result: [] };
        }
        if (!alethioUrl.url || !alethioResponse || !alethioResponse.data) {
            alethioResponse = { data: [] };
        }
        return [etherscanResponse, alethioResponse];
    });
}
exports.handleTransactionFetch = handleTransactionFetch;
/**
 * Converts a hex string to a BN object
 *
 * @param inputHex - Number represented as a hex string
 * @returns - A BN instance
 *
 */
function hexToBN(inputHex) {
    return new BN(stripHexPrefix(inputHex), 16);
}
exports.hexToBN = hexToBN;
/**
 * A helper function that converts hex data to human readable string
 *
 * @param hex - The hex string to convert to string
 * @returns - A human readable string conversion
 *
 */
function hexToText(hex) {
    try {
        const stripped = stripHexPrefix(hex);
        const buff = Buffer.from(stripped, 'hex');
        return buff.toString('utf8');
    }
    catch (e) {
        /* istanbul ignore next */
        return hex;
    }
}
exports.hexToText = hexToText;
/**
 * Normalizes properties on a Transaction object
 *
 * @param transaction - Transaction object to normalize
 * @returns - Normalized Transaction object
 */
function normalizeTransaction(transaction) {
    const normalizedTransaction = { from: '' };
    let key;
    for (key in NORMALIZERS) {
        if (transaction[key]) {
            normalizedTransaction[key] = NORMALIZERS[key](transaction[key]);
        }
    }
    return normalizedTransaction;
}
exports.normalizeTransaction = normalizeTransaction;
/**
 * Execute and return an asynchronous operation without throwing errors
 *
 * @param operation - Function returning a Promise
 * @param logError - Determines if the error should be logged
 * @param retry - Function called if an error is caught
 * @returns - Promise resolving to the result of the async operation
 */
function safelyExecute(operation, logError = false, retry) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield operation();
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            retry && retry(error);
        }
    });
}
exports.safelyExecute = safelyExecute;
/**
 * Validates a Transaction object for required properties and throws in
 * the event of any validation error.
 *
 * @param transaction - Transaction object to validate
 */
function validateTransaction(transaction) {
    if (!transaction.from || typeof transaction.from !== 'string' || !ethereumjs_util_1.isValidAddress(transaction.from)) {
        throw new Error(`Invalid "from" address: ${transaction.from} must be a valid string.`);
    }
    if (transaction.to === '0x' || transaction.to === undefined) {
        if (transaction.data) {
            delete transaction.to;
        }
        else {
            throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
        }
    }
    else if (transaction.to !== undefined && !ethereumjs_util_1.isValidAddress(transaction.to)) {
        throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
    }
    if (transaction.value !== undefined) {
        const value = transaction.value.toString();
        if (value.includes('-')) {
            throw new Error(`Invalid "value": ${value} is not a positive number.`);
        }
        if (value.includes('.')) {
            throw new Error(`Invalid "value": ${value} number must be denominated in wei.`);
        }
        const intValue = parseInt(transaction.value, 10);
        const isValid = Number.isFinite(intValue) && !Number.isNaN(intValue) && !isNaN(Number(value)) && Number.isSafeInteger(intValue);
        if (!isValid) {
            throw new Error(`Invalid "value": ${value} number must be a valid number.`);
        }
    }
}
exports.validateTransaction = validateTransaction;
/**
 * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
 * it is already formatted as a hex.
 *
 * @param data - The buffer data to convert to a hex
 * @returns - A hex string conversion of the buffer data
 *
 */
function normalizeMessageData(data) {
    try {
        const stripped = stripHexPrefix(data);
        if (stripped.match(hexRe)) {
            return ethereumjs_util_1.addHexPrefix(stripped);
        }
    }
    catch (e) {
        /* istanbul ignore next */
    }
    return ethereumjs_util_1.bufferToHex(Buffer.from(data, 'utf8'));
}
exports.normalizeMessageData = normalizeMessageData;
/**
 * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in
 * the event of any validation error.
 *
 * @param messageData - PersonalMessageParams object to validate
 */
function validateSignMessageData(messageData) {
    if (!messageData.from || typeof messageData.from !== 'string' || !ethereumjs_util_1.isValidAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid string.`);
    }
}
exports.validateSignMessageData = validateSignMessageData;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V1.
 *
 * @param messageData - TypedMessageParams object to validate
 * @param activeChainId - Active chain id
 */
function validateTypedSignMessageDataV1(messageData) {
    if (!messageData.from || typeof messageData.from !== 'string' || !ethereumjs_util_1.isValidAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || !Array.isArray(messageData.data)) {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    try {
        // typedSignatureHash will throw if the data is invalid.
        eth_sig_util_1.typedSignatureHash(messageData.data);
    }
    catch (e) {
        throw new Error(`Expected EIP712 typed data.`);
    }
}
exports.validateTypedSignMessageDataV1 = validateTypedSignMessageDataV1;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V3.
 *
 * @param messageData - TypedMessageParams object to validate
 */
function validateTypedSignMessageDataV3(messageData) {
    if (!messageData.from || typeof messageData.from !== 'string' || !ethereumjs_util_1.isValidAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    let data;
    try {
        data = JSON.parse(messageData.data);
    }
    catch (e) {
        throw new Error('Data must be passed as a valid JSON string.');
    }
    const validation = jsonschema.validate(data, eth_sig_util_1.TYPED_MESSAGE_SCHEMA);
    if (validation.errors.length > 0) {
        throw new Error('Data must conform to EIP-712 schema. See https://git.io/fNtcx.');
    }
}
exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
/**
 * Validates a ERC20 token to be added with EIP747.
 *
 * @param token - Token object to validate
 */
function validateTokenToWatch(token) {
    const { address, symbol, decimals } = token;
    if (!address || !symbol || typeof decimals === 'undefined') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Must specify address, symbol, and decimals.`);
    }
    if (typeof symbol !== 'string') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol: not a string.`);
    }
    if (symbol.length > 6) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol "${symbol}": longer than 6 characters.`);
    }
    const numDecimals = parseInt(decimals, 10);
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid decimals "${decimals}": must be 0 <= 36.`);
    }
    if (!ethereumjs_util_1.isValidAddress(address)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid address "${address}".`);
    }
}
exports.validateTokenToWatch = validateTokenToWatch;
/**
 * Returns wether the given code corresponds to a smart contract
 *
 * @returns {string} - Corresponding code to review
 */
function isSmartContractCode(code) {
    /* istanbul ignore if */
    if (!code) {
        return false;
    }
    // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
    const smartContractCode = code !== '0x' && code !== '0x0';
    return smartContractCode;
}
exports.isSmartContractCode = isSmartContractCode;
/**
 * Execute fetch and verify that the response was successful
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the fetch response
 */
function successfulFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(request, options);
        if (!response.ok) {
            throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);
        }
        return response;
    });
}
exports.successfulFetch = successfulFetch;
/**
 * Execute fetch and return object response
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the result object of fetch
 */
function handleFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield successfulFetch(request, options);
        const object = yield response.json();
        return object;
    });
}
exports.handleFetch = handleFetch;
/**
 * Fetch that fails after timeout
 *
 * @param url - Url to fetch
 * @param options - Options to send with the request
 * @param timeout - Timeout to fail request
 *
 * @returns - Promise resolving the request
 */
function timeoutFetch(url, options, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            successfulFetch(url, options),
            new Promise((_, reject) => setTimeout(() => {
                reject(new Error('timeout'));
            }, timeout)),
        ]);
    });
}
exports.timeoutFetch = timeoutFetch;
/**
 * Normalizes the given ENS name.
 *
 * @param {string} ensName - The ENS name
 *
 * @returns - the normalized ENS name string
 */
function normalizeEnsName(ensName) {
    if (ensName && typeof ensName === 'string') {
        try {
            const normalized = ensNamehash.normalize(ensName.trim());
            // this regex is only sufficient with the above call to ensNamehash.normalize
            // TODO: change 7 in regex to 3 when shorter ENS domains are live
            // eslint-disable-next-line require-unicode-regexp
            if (normalized.match(/^(([\w\d\-]+)\.)*[\w\d\-]{7,}\.(eth|test)$/)) {
                return normalized;
            }
        }
        catch (_) {
            // do nothing
        }
    }
    return null;
}
exports.normalizeEnsName = normalizeEnsName;
exports.default = {
    BNToHex,
    fractionBN,
    getBuyURL,
    handleFetch,
    hexToBN,
    hexToText,
    isSmartContractCode,
    normalizeTransaction,
    safelyExecute,
    successfulFetch,
    timeoutFetch,
    validateTokenToWatch,
    validateTransaction,
    validateTypedSignMessageDataV1,
    validateTypedSignMessageDataV3,
};

}).call(this,require("buffer").Buffer)

//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/util.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/util.js",}],
[3189, {"../BaseController":3171,"../util":3192,"await-semaphore":1175,"eth-method-registry":3199,"eth-query":1744,"eth-rpc-errors":3196,"ethereumjs-tx":1794,"ethereumjs-util":3211,"events":1429,"uuid/v1":3463}, function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const MethodRegistry = require('eth-method-registry');
const EthQuery = require('eth-query');
const Transaction = require('ethereumjs-tx');
const random = require('uuid/v1');
const { BN } = require('ethereumjs-util');
const { Mutex } = require('await-semaphore');
/**
 * Multiplier used to determine a transaction's increased gas fee during cancellation
 */
exports.CANCEL_RATE = 1.5;
/**
 * Multiplier used to determine a transaction's increased gas fee during speed up
 */
exports.SPEED_UP_RATE = 1.1;
/**
 * Controller responsible for submitting and managing transactions
 */
class TransactionController extends BaseController_1.default {
    /**
     * Creates a TransactionController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.mutex = new Mutex();
        /**
         * Normalizes the transaction information from alethio
         * to be compatible with the TransactionMeta interface
         *
         * @param txMeta - Object containing the transaction information
         * @param currentNetworkID - string representing the current network id
         * @returns - TransactionMeta
         */
        this.normalizeTxFromAlehio = (txMeta, currentNetworkID) => {
            const { attributes: { symbol, blockCreationTime, decimals, transactionGasLimit, transactionGasPrice, value }, relationships: { to, from, transaction, token }, } = txMeta;
            const time = parseInt(blockCreationTime, 10) * 1000;
            return {
                id: random({ msecs: time }),
                isTransfer: true,
                networkID: currentNetworkID,
                status: 'confirmed',
                time: parseInt(blockCreationTime, 10) * 1000,
                transaction: {
                    chainId: 1,
                    from: from.data.id,
                    gas: transactionGasLimit,
                    gasPrice: transactionGasPrice,
                    to: to.data.id,
                    value,
                },
                transactionHash: transaction.data.id,
                transferInformation: {
                    contractAddress: token.data.id,
                    decimals,
                    symbol,
                },
            };
        };
        /**
         * EventEmitter instance used to listen to specific transactional events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TransactionController';
        /**
         * List of required sibling controllers this controller needs to function
         */
        this.requiredControllers = ['NetworkController'];
        this.defaultConfig = {
            interval: 5000,
            provider: undefined,
        };
        this.defaultState = {
            methodData: {},
            transactions: [],
        };
        this.initialize();
        this.poll();
    }
    failTransaction(transactionMeta, error) {
        transactionMeta.status = 'failed';
        transactionMeta.error = error;
        this.updateTransaction(transactionMeta);
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
    }
    query(method, args = []) {
        return new Promise((resolve, reject) => {
            this.ethQuery[method](...args, (error, result) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result);
            });
        });
    }
    registryLookup(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryMethod = yield this.registry.lookup(fourBytePrefix);
            const parsedRegistryMethod = this.registry.parse(registryMethod);
            return { registryMethod, parsedRegistryMethod };
        });
    }
    /**
     * Normalizes the transaction information from etherscan
     * to be compatible with the TransactionMeta interface
     *
     * @param txMeta - Object containing the transaction information
     * @param currentNetworkID - string representing the current network id
     * @returns - TransactionMeta
     */
    normalizeTxFromEtherscan(txMeta, currentNetworkID) {
        const time = parseInt(txMeta.timeStamp, 10) * 1000;
        /* istanbul ignore next */
        const status = txMeta.isError === '0' ? 'confirmed' : 'failed';
        return {
            blockNumber: txMeta.blockNumber,
            id: random({ msecs: time }),
            networkID: currentNetworkID,
            status,
            time,
            transaction: {
                data: txMeta.input,
                from: txMeta.from,
                gas: util_1.BNToHex(new BN(txMeta.gas)),
                gasPrice: util_1.BNToHex(new BN(txMeta.gasPrice)),
                nonce: util_1.BNToHex(new BN(txMeta.nonce)),
                to: txMeta.to,
                value: util_1.BNToHex(new BN(txMeta.value)),
            },
            transactionHash: txMeta.hash,
        };
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new transaction statuses
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.queryTransactionStatuses());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Handle new method data request
     *
     * @param fourBytePrefix - String corresponding to method prefix
     * @returns - Promise resolving to method data object corresponding to signature prefix
     */
    handleMethodData(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { methodData } = this.state;
                const knownMethod = Object.keys(methodData).find((knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix);
                if (knownMethod) {
                    return methodData[fourBytePrefix];
                }
                const registry = yield this.registryLookup(fourBytePrefix);
                this.update({ methodData: Object.assign(Object.assign({}, methodData), { [fourBytePrefix]: registry }) });
                return registry;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a new unapproved transaction to state. Parameters will be validated, a
     * unique transaction id will be generated, and gas and gasPrice will be calculated
     * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
     *
     * @param transaction - Transaction object to add
     * @param origin - Domain origin to append to the generated TransactionMeta
     * @returns - Object containing a promise resolving to the transaction hash if approved
     */
    addTransaction(transaction, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.context.NetworkController;
            const { transactions } = this.state;
            transaction = util_1.normalizeTransaction(transaction);
            util_1.validateTransaction(transaction);
            const transactionMeta = {
                id: random(),
                networkID: network ? network.state.network : /* istanbul ignore next */ '1',
                origin,
                status: 'unapproved',
                time: Date.now(),
                transaction,
            };
            try {
                const { gas, gasPrice } = yield this.estimateGas(transaction);
                transaction.gas = gas;
                transaction.gasPrice = gasPrice;
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case 'submitted':
                            return resolve(meta.transactionHash);
                        case 'rejected':
                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
                        case 'cancelled':
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
                        case 'failed':
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
                    }
                });
            });
            transactions.push(transactionMeta);
            this.update({ transactions: [...transactions] });
            this.hub.emit(`unapprovedTransaction`, transactionMeta);
            return { result, transactionMeta };
        });
    }
    /**
     * Approves a transaction and updates it's status in state. If this is not a
     * retry transaction, a nonce will be generated. The transaction is signed
     * using the sign configuration property, then published to the blockchain.
     * A `<tx.id>:finished` hub event is fired after success or failure.
     *
     * @param transactionID - ID of the transaction to approve
     * @returns - Promise resolving when this operation completes
     */
    approveTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const network = this.context.NetworkController;
            /* istanbul ignore next */
            const currentNetworkID = network ? network.state.network : '1';
            const index = transactions.findIndex(({ id }) => transactionID === id);
            const transactionMeta = transactions[index];
            const { from } = transactionMeta.transaction;
            if (!this.sign) {
                this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                return;
            }
            try {
                transactionMeta.status = 'approved';
                transactionMeta.transaction.nonce = yield this.query('getTransactionCount', [from, 'pending']);
                transactionMeta.transaction.chainId = parseInt(currentNetworkID, undefined);
                const ethTransaction = new Transaction(Object.assign({}, transactionMeta.transaction));
                yield this.sign(ethTransaction, transactionMeta.transaction.from);
                transactionMeta.status = 'signed';
                this.updateTransaction(transactionMeta);
                const rawTransaction = ethereumjs_util_1.bufferToHex(ethTransaction.serialize());
                transactionMeta.rawTransaction = rawTransaction;
                this.updateTransaction(transactionMeta);
                const transactionHash = yield this.query('sendRawTransaction', [rawTransaction]);
                transactionMeta.transactionHash = transactionHash;
                transactionMeta.status = 'submitted';
                this.updateTransaction(transactionMeta);
                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
            }
        });
    }
    /**
     * Cancels a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    cancelTransaction(transactionID) {
        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
        if (!transactionMeta) {
            return;
        }
        transactionMeta.status = 'rejected';
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
        this.update({ transactions: [...transactions] });
    }
    /**
     * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    stopTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            if (!transactionMeta) {
                return;
            }
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const existingGasPrice = transactionMeta.transaction.gasPrice;
            /* istanbul ignore next */
            const existingGasPriceDecimal = parseInt(existingGasPrice === undefined ? '0x0' : existingGasPrice, 16);
            const gasPrice = ethereumjs_util_1.addHexPrefix(`${parseInt(`${existingGasPriceDecimal * exports.CANCEL_RATE}`, 10).toString(16)}`);
            const ethTransaction = new Transaction({
                from: transactionMeta.transaction.from,
                gas: transactionMeta.transaction.gas,
                gasPrice,
                nonce: transactionMeta.transaction.nonce,
                to: transactionMeta.transaction.from,
                value: '0x0',
            });
            yield this.sign(ethTransaction, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(ethTransaction.serialize());
            yield this.query('sendRawTransaction', [rawTransaction]);
            transactionMeta.status = 'cancelled';
            this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        });
    }
    /**
     * Attemps to speed up a transaction increasing transaction gasPrice by ten percent
     *
     * @param transactionID - ID of the transaction to speed up
     */
    speedUpTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            /* istanbul ignore next */
            if (!transactionMeta) {
                return;
            }
            /* istanbul ignore next */
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const { transactions } = this.state;
            const existingGasPrice = transactionMeta.transaction.gasPrice;
            /* istanbul ignore next */
            const existingGasPriceDecimal = parseInt(existingGasPrice === undefined ? '0x0' : existingGasPrice, 16);
            const gasPrice = ethereumjs_util_1.addHexPrefix(`${parseInt(`${existingGasPriceDecimal * exports.SPEED_UP_RATE}`, 10).toString(16)}`);
            const ethTransaction = new Transaction(Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice }));
            yield this.sign(ethTransaction, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(ethTransaction.serialize());
            const transactionHash = yield this.query('sendRawTransaction', [rawTransaction]);
            const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: random(), time: Date.now(), transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice }), transactionHash });
            transactions.push(newTransactionMeta);
            this.update({ transactions: [...transactions] });
            this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);
        });
    }
    /**
     * Estimates required gas for a given transaction
     *
     * @param transaction - Transaction object to estimate gas for
     * @returns - Promise resolving to an object containing gas and gasPrice
     */
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimatedTransaction = Object.assign({}, transaction);
            const { gasLimit } = yield this.query('getBlockByNumber', ['latest', false]);
            const { gas, gasPrice: providedGasPrice, to, value, data } = estimatedTransaction;
            const gasPrice = typeof providedGasPrice === 'undefined' ? yield this.query('gasPrice') : providedGasPrice;
            // 1. If gas is already defined on the transaction, use it
            if (typeof gas !== 'undefined') {
                return { gas, gasPrice };
            }
            // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000
            /* istanbul ignore next */
            const code = to ? yield this.query('getCode', [to]) : undefined;
            /* istanbul ignore next */
            if (!to || (to && !data && (!code || code === '0x'))) {
                return { gas: '0x5208', gasPrice };
            }
            // if data, should be hex string format
            estimatedTransaction.data = !data ? data : /* istanbul ignore next */ ethereumjs_util_1.addHexPrefix(data);
            // 3. If this is a contract address, safely estimate gas using RPC
            estimatedTransaction.value = typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;
            const gasLimitBN = util_1.hexToBN(gasLimit);
            estimatedTransaction.gas = util_1.BNToHex(util_1.fractionBN(gasLimitBN, 19, 20));
            const gasHex = yield this.query('estimateGas', [estimatedTransaction]);
            // 4. Pad estimated gas without exceeding the most recent block gasLimit
            const gasBN = util_1.hexToBN(gasHex);
            const maxGasBN = gasLimitBN.muln(0.9);
            const paddedGasBN = gasBN.muln(1.5);
            /* istanbul ignore next */
            if (gasBN.gt(maxGasBN)) {
                return { gas: ethereumjs_util_1.addHexPrefix(gasHex), gasPrice };
            }
            /* istanbul ignore next */
            if (paddedGasBN.lt(maxGasBN)) {
                return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(paddedGasBN)), gasPrice };
            }
            return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(maxGasBN)), gasPrice };
        });
    }
    /**
     * Extension point called if and when this controller is composed
     * with other controllers using a ComposableController
     */
    onComposed() {
        super.onComposed();
        const network = this.context.NetworkController;
        const onProviderUpdate = () => {
            this.ethQuery = network.provider ? new EthQuery(network.provider) : /* istanbul ignore next */ null;
            this.registry = network.provider
                ? new MethodRegistry({ provider: network.provider }) /* istanbul ignore next */
                : null;
        };
        onProviderUpdate();
        network.subscribe(onProviderUpdate);
    }
    /**
     * Resiliently checks all submitted transactions on the blockchain
     * and verifies that it has been included in a block
     * when that happens, the tx status is updated to confirmed
     *
     * @returns - Promise resolving when this operation completes
     */
    queryTransactionStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const network = this.context.NetworkController;
            const currentNetworkID = network.state.network;
            let gotUpdates = false;
            yield util_1.safelyExecute(() => Promise.all(transactions.map((meta, index) => __awaiter(this, void 0, void 0, function* () {
                if (meta.status === 'submitted' && meta.networkID === currentNetworkID) {
                    const txObj = yield this.query('getTransactionByHash', [meta.transactionHash]);
                    /* istanbul ignore else */
                    if (txObj && txObj.blockNumber) {
                        transactions[index].status = 'confirmed';
                        this.hub.emit(`${meta.id}:confirmed`, meta);
                        gotUpdates = true;
                    }
                }
            }))));
            /* istanbul ignore else */
            if (gotUpdates) {
                this.update({ transactions: [...transactions] });
            }
        });
    }
    /**
     * Updates an existing transaction in state
     *
     * @param transactionMeta - New transaction meta to store in state
     */
    updateTransaction(transactionMeta) {
        const { transactions } = this.state;
        transactionMeta.transaction = util_1.normalizeTransaction(transactionMeta.transaction);
        util_1.validateTransaction(transactionMeta.transaction);
        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
        transactions[index] = transactionMeta;
        this.update({ transactions: [...transactions] });
    }
    /**
     * Removes all transactions from state, optionally based on the current network
     *
     * @param ignoreNetwork - Ignores network
     */
    wipeTransactions(ignoreNetwork) {
        /* istanbul ignore next */
        if (ignoreNetwork) {
            this.update({ transactions: [] });
            return;
        }
        const network = this.context.NetworkController;
        if (!network) {
            return;
        }
        const currentNetworkID = network.state.network;
        const newTransactions = this.state.transactions.filter(({ networkID }) => networkID !== currentNetworkID);
        this.update({ transactions: newTransactions });
    }
    /**
     * Gets all transactions from etherscan for a specific address
     * optionally starting from a specific block
     *
     * @param address - string representing the address to fetch the transactions from
     * @param opt - Object containing optional data, fromBlock and Alethio API key
     * @returns - Promise resolving to an string containing the block number of the latest incoming transaction.
     */
    fetchAll(address, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.context.NetworkController;
            const { state: { network: currentNetworkID, provider: { type: networkType }, }, } = network;
            const supportedNetworkIds = ['1', '3', '4', '42'];
            /* istanbul ignore next */
            if (supportedNetworkIds.indexOf(currentNetworkID) === -1) {
                return;
            }
            const [etherscanResponse, alethioResponse] = yield util_1.handleTransactionFetch(networkType, address, opt);
            const remoteTxList = {};
            const remoteTxs = [];
            etherscanResponse.result.forEach((tx) => {
                /* istanbul ignore next */
                if (!remoteTxList[tx.hash]) {
                    remoteTxs.push(this.normalizeTxFromEtherscan(tx, currentNetworkID));
                    remoteTxList[tx.hash] = 1;
                }
            });
            alethioResponse.data.forEach((tx) => {
                const cleanTx = this.normalizeTxFromAlehio(tx, currentNetworkID);
                remoteTxs.push(cleanTx);
                /* istanbul ignore next */
                remoteTxList[cleanTx.transactionHash || ''] = 1;
            });
            const localTxs = this.state.transactions.filter(
            /* istanbul ignore next */
            (tx) => !remoteTxList[`${tx.transactionHash}`]);
            const allTxs = [...remoteTxs, ...localTxs];
            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
            let latestIncomingTxBlockNumber;
            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
                /* istanbul ignore next */
                if (tx.networkID === currentNetworkID &&
                    tx.transaction.to &&
                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
                    if (tx.blockNumber &&
                        (!latestIncomingTxBlockNumber || parseInt(latestIncomingTxBlockNumber, 10) < parseInt(tx.blockNumber, 10))) {
                        latestIncomingTxBlockNumber = tx.blockNumber;
                    }
                }
                /* istanbul ignore else */
                if (tx.toSmartContract === undefined) {
                    // If not `to` is a contract deploy, if not `data` is send eth
                    if (tx.transaction.to && (!tx.transaction.data || tx.transaction.data !== '0x')) {
                        const code = yield this.query('getCode', [tx.transaction.to]);
                        tx.toSmartContract = util_1.isSmartContractCode(code);
                    }
                    else {
                        tx.toSmartContract = false;
                    }
                }
            }));
            // Update state only if new transactions were fetched
            if (allTxs.length > this.state.transactions.length) {
                this.update({ transactions: allTxs });
            }
            return latestIncomingTxBlockNumber;
        });
    }
}
exports.TransactionController = TransactionController;
exports.default = TransactionController;
//# sourceMappingURL=TransactionController.js.map
//# sourceMappingURL=node_modules/rpc-cap/node_modules/@metamask/controllers/dist/transaction/TransactionController.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/rpc-cap/node_modules/@metamask/controllers/dist/transaction/TransactionController.js",}],
[21, {"../../../../shared/constants/network":3595,"../../../../shared/constants/transaction":3599}, function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTxMetaForRpcResult = formatTxMetaForRpcResult;
exports.getNetworkDisplayName = void 0;

var _network = require("../../../../shared/constants/network");

var _transaction = require("../../../../shared/constants/transaction");

const getNetworkDisplayName = key => _network.NETWORK_TO_NAME_MAP[key];

exports.getNetworkDisplayName = getNetworkDisplayName;

function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    hash,
    txReceipt,
    txParams
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    accessList,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = txParams;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash,
    nonce,
    input: data || '0x',
    value: value || '0x0',
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null
  };

  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.gasPrice = maxFeePerGas;
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }

  return formattedTxMeta;
}

//# sourceMappingURL=app/scripts/controllers/network/util.js
}, {file:"/Users/jack/projects/monsta-wallet/app/scripts/controllers/network/util.js",}],
[1707, {"ethereumjs-abi":1708,"ethereumjs-util":1720}, function (require, module, exports) {
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')

module.exports = {

  concatSig: function (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize: function (input) {
    if (!input) return

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ' received ' + (typeof input) + ': ' + input
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign: function (privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data)
    var msgHash = ethUtil.hashPersonalMessage(message)
    var sig = ethUtil.ecsign(msgHash, privateKey)
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return '0x' + publicKey.toString('hex')
  },

  typedSignatureHash: function (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedData: function (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature: function (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  }

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data)
    ]
  )
}

function recoverPublicKey(hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  var myString = '' + number
  while (myString.length < length) {
    myString = '0' + myString
  }
  return myString
}

//# sourceMappingURL=node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js",}],
[3344, {"./util":3345}, function (require, module, exports) {
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

//# sourceMappingURL=node_modules/store/src/store-engine.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/store/src/store-engine.js",}],
[3342, {"./lib/json2":3343}, function (require, module, exports) {
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

//# sourceMappingURL=node_modules/store/plugins/json2.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/store/plugins/json2.js",}],
[3346, {"./cookieStorage":3347,"./localStorage":3348,"./memoryStorage":3349,"./oldFF-globalStorage":3350,"./oldIE-userDataStorage":3351,"./sessionStorage":3352}, function (require, module, exports) {
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

//# sourceMappingURL=node_modules/store/storages/all.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/store/storages/all.js",}],
[159, {"./config":158,"./utils/index":165,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;

var KeyValueStore =
/*#__PURE__*/
function () {
  /**
   * Please use **box.public** or **box.private** to get the instance of this class
   */
  function KeyValueStore(orbitdb, name, ensureConnected, threeId) {
    (0, _classCallCheck2["default"])(this, KeyValueStore);
    this._orbitdb = orbitdb;
    this._name = name;

    if (this._name.startsWith('3box.space.')) {
      this._space = this._name.split('.')[2];
    }

    this._ensureConnected = ensureConnected;
    this._3id = threeId;
  }
  /**
   * Get the value and optionally metadata of the given key
   *
   * @param     {String}    key                             the key
   * @param     {Object}    opts                            optional parameters
   * @param     {Boolean}   opts.metadata                   return both value and metadata
   * @return    {String|{value: String, timestamp: Number}} the value associated with the key, undefined if there's no such key
   */


  (0, _createClass2["default"])(KeyValueStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            x,
            metadata,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this._get(key);

              case 3:
                x = _context.sent;

                if (x) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", x);

              case 6:
                if (!opts.metadata) {
                  _context.next = 9;
                  break;
                }

                metadata = this._extractMetadata(x);
                return _context.abrupt("return", _objectSpread({}, metadata, {
                  value: x.value
                }));

              case 9:
                return _context.abrupt("return", x.value);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Get metadata for for a given key
     *
     * @param     {String}    key                     the key
     * @return    {Metadata}                          Metadata for the key, undefined if there's no such key
     */

  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        var x;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._get(key);

              case 2:
                x = _context2.sent;

                if (x) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", x);

              case 5:
                return _context2.abrupt("return", this._extractMetadata(x));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * Set a value for the given key
     *
     * @param     {String}    key                     the key
     * @param     {String}    value                   the value
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        var timeStamp;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                timeStamp = new Date().getTime();
                _context3.next = 6;
                return this._db.put(key, {
                  value: value,
                  timeStamp: timeStamp
                });

              case 6:
                return _context3.abrupt("return", true);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
    /**
    * Set multiple values for multiple keys
    *
    * @param     {Array<String>}    keys                     the keys
    * @param     {Array<String>}    values                   the values
    * @return    {Boolean}                                  true if successful, throw error if not
    */

  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(keys, values) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);

                this._requireLoad();

                this._ensureConnected();

                _context5.prev = 3;
                _context5.next = 6;
                return keys.reduce(
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4(previousPromise, nextKey, index) {
                    var timeStamp;
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return previousPromise;

                          case 2:
                            throwIfUndefined(nextKey, 'key');
                            timeStamp = new Date().getTime();
                            return _context4.abrupt("return", _this._db.put(nextKey, {
                              value: values[index],
                              timeStamp: timeStamp
                            }));

                          case 5:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x7, _x8, _x9) {
                    return _ref.apply(this, arguments);
                  };
                }(), Promise.resolve());

              case 6:
                return _context5.abrupt("return", true);

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](3);
                throw new Error(_context5.t0);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 9]]);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
    /**
     * Remove the value for the given key
     *
     * @param     {String}    key                     the key
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(key) {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                _context6.next = 5;
                return this._db.del(key);

              case 5:
                return _context6.abrupt("return", true);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function remove(_x10) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Extract metadata from store object
     * @private
     * @param x {Object} data from store
     * @return {Metadata} store metadata
     */

  }, {
    key: "_extractMetadata",
    value: function _extractMetadata(x) {
      // ms -> seconds, see issue #396 for details
      var timestamp = Math.floor(x.timeStamp / 1000);
      return {
        timestamp: timestamp
      };
    }
    /**
     * Get the raw value of the given key
     * @private
     *
     * @param     {String}    key                     the key
     * @return    {String}                            the value associated with the key
     */

  }, {
    key: "_get",
    value: function () {
      var _get3 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(key) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.get(key));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _get(_x11) {
        return _get3.apply(this, arguments);
      }

      return _get;
    }()
  }, {
    key: "_sync",
    value: function () {
      var _sync2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(numRemoteEntries) {
        var _this2 = this;

        var numEntriesDefined;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._requireLoad(); // let toid = null


                numEntriesDefined = !(numRemoteEntries === null || numRemoteEntries === undefined);

                if (!(numEntriesDefined && numRemoteEntries <= this._db._oplog.values.length)) {
                  _context8.next = 4;
                  break;
                }

                return _context8.abrupt("return", Promise.resolve());

              case 4:
                _context8.next = 6;
                return new Promise(function (resolve, reject) {
                  if (!numRemoteEntries) {
                    setTimeout(function () {
                      _this2._db.events.removeAllListeners('replicated');

                      _this2._db.events.removeAllListeners('replicate.progress');

                      resolve();
                    }, 3000);
                  }

                  _this2._db.events.on('replicated', function () {
                    if (numRemoteEntries <= _this2._db._oplog.values.length) resolve();
                  });
                  /*
                  this._db.events.on('replicate.progress', (_x, _y, _z, num, max) => {
                    if (toid) {
                      clearTimeout(toid)
                      toid = null
                    }
                    const total = numRemoteEntries || max
                    if (num >= total) {
                      this._db.events.on('replicated', resolve)
                      listenerAdded = true
                    }
                  })
                  */

                });

              case 6:
                return _context8.abrupt("return", this._db.address.toString());

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _sync(_x12) {
        return _sync2.apply(this, arguments);
      }

      return _sync;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(odbAddress) {
        var key, opts;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                key = this._3id.getKeyringBySpaceName(this._name).getPublicKeys(true).signingKey;
                opts = _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                });

                if (!this._space) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 5;
                return this._3id.getOdbId(this._space);

              case 5:
                opts.identity = _context9.sent;

              case 6:
                _context9.next = 8;
                return this._orbitdb.keyvalue(odbAddress || this._name, opts);

              case 8:
                this._db = _context9.sent;
                _context9.next = 11;
                return this._db.load();

              case 11:
                return _context9.abrupt("return", this._db.address.toString());

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _load(_x13) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._requireLoad();

                _context10.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Get all values and optionally metadata
     *
     * @param     {Object}    opts                                    optional parameters
     * @param     {Boolean}   opts.metadata                           return both values and metadata
     * @return    {Array<String|{value: String, timestamp: Number}>}  the values
     */

  }, {
    key: "all",
    value: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var _this3 = this;

        var opts,
            entries,
            allSimple,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                opts = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};

                this._requireLoad();

                entries = this._db.all;
                allSimple = {};
                Object.keys(entries).map(function (key) {
                  var entry = entries[key];

                  if (opts.metadata) {
                    allSimple[key] = _objectSpread({}, _this3._extractMetadata(entry), {
                      value: entry.value
                    });
                  } else {
                    allSimple[key] = entry.value;
                  }
                });
                return _context11.abrupt("return", allSimple);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function all() {
        return _all.apply(this, arguments);
      }

      return all;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: 'Name', value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "log",
    get: function get() {
      return this._db._oplog.values.map(function (obj) {
        return {
          op: obj.payload.op,
          key: obj.payload.key,
          value: obj.payload.value ? obj.payload.value.value : null,
          timeStamp: obj.payload.value ? obj.payload.value.timeStamp : null
        };
      });
    }
  }]);
  return KeyValueStore;
}();

module.exports = KeyValueStore;
//# sourceMappingURL=node_modules/3box/lib/keyValueStore.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/keyValueStore.js",}],
[182, {"./superPropBase":200}, function (require, module, exports) {
var superPropBase = require("./superPropBase");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
//# sourceMappingURL=node_modules/@babel/runtime/helpers/get.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/@babel/runtime/helpers/get.js",}],
[2838, {"cids":1446,"multihashes":2698,"path":2873}, function (require, module, exports) {
'use strict'
const path = require('path')
const multihash = require('multihashes')
const CID = require('cids')

const notEmpty = e => e !== '' && e !== ' '

class OrbitDBAddress {
  constructor (root, path) {
    this.root = root
    this.path = path
  }

  toString () {
    return path.join('/orbitdb', this.root, this.path)
  }

  static isValid (address) {
    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')

    const parts = address.toString()
      .split('/')
      .filter(containsProtocolPrefix)
      .filter(notEmpty)

    let accessControllerHash

    try {
      accessControllerHash = (parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1)
        ? new CID(parts[0]).toBaseEncodedString()
        : null
    } catch (e) {
      return false
    }

    return accessControllerHash !== null
  }

  static parse (address) {
    if (!address)
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    if (!OrbitDBAddress.isValid(address))
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    const parts = address.toString()
      .split('/')
      .filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb'))
      .filter(e => e !== '' && e !== ' ')

    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'))
  }
}

module.exports = OrbitDBAddress

//# sourceMappingURL=node_modules/orbit-db/src/orbit-db-address.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/orbit-db/src/orbit-db-address.js",}],
[163, {"./api":157,"./config":158,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/classCallCheck":177,"@babel/runtime/helpers/createClass":179,"@babel/runtime/helpers/defineProperty":180,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"is-ipfs":2244}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var isIPFS = require('is-ipfs');

var API = require('./api');

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;
var MODERATOR = 'MODERATOR';
var MEMBER = 'MEMBER';

var isValid3ID = function isValid3ID(did) {
  var parts = did.split(':');
  if (!parts[0] === 'did' || !parts[1] === '3') return false;
  return isIPFS.cid(parts[2]);
};

var Thread =
/*#__PURE__*/
function () {
  /**
   * Please use **space.joinThread** to get the instance of this class
   */
  function Thread(orbitdb, name, threeId, members, firstModerator, subscribe, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Thread);
    this._orbitdb = orbitdb;
    this._name = name;
    this._spaceName = name.split('.')[2];
    this._3id = threeId;
    this._subscribe = subscribe;
    this._ensureConnected = ensureConnected;
    this._queuedNewPosts = [];
    this._members = Boolean(members);
    this._firstModerator = firstModerator || this._3id.getSubDID(this._spaceName);
  }
  /**
   * Post a message to the thread
   *
   * @param     {Object}    message                 The message
   * @return    {String}                            The postId of the new post
   */


  (0, _createClass2["default"])(Thread, [{
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(message) {
        var timestamp;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._requireLoad();

                this._subscribe(this._address, {
                  firstModerator: this._firstModerator,
                  members: this._members,
                  name: this._name
                });

                this._ensureConnected(this._address, true);

                timestamp = Math.floor(new Date().getTime() / 1000); // seconds

                return _context.abrupt("return", this._db.add({
                  message: message,
                  timestamp: timestamp
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function post(_x) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "_getThreadAddress",
    value: function () {
      var _getThreadAddress2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var address;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._initConfigs();

              case 2:
                _context2.next = 4;
                return this._orbitdb._determineAddress(this._name, 'feed', {
                  accessController: this._accessController
                }, false);

              case 4:
                address = _context2.sent.toString();
                this._address = address;
                return _context2.abrupt("return", this._address);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getThreadAddress() {
        return _getThreadAddress2.apply(this, arguments);
      }

      return _getThreadAddress;
    }()
    /**
     * Add a moderator to this thread, throws error is user can not add a moderator
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "addModerator",
    value: function () {
      var _addModerator = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(id) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._requireLoad();

                if (!id.startsWith('0x')) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 4;
                return API.getSpaceDID(id, this._spaceName);

              case 4:
                id = _context3.sent;

              case 5:
                if (isValid3ID(id)) {
                  _context3.next = 7;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 7:
                return _context3.abrupt("return", this._db.access.grant(MODERATOR, id));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addModerator(_x2) {
        return _addModerator.apply(this, arguments);
      }

      return addModerator;
    }()
    /**
     * List moderators
     *
     * @return    {Array<String>}      Array of moderator DIDs
     */

  }, {
    key: "listModerators",
    value: function () {
      var _listModerators = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._requireLoad();

                return _context4.abrupt("return", this._db.access.capabilities['moderators']);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function listModerators() {
        return _listModerators.apply(this, arguments);
      }

      return listModerators;
    }()
    /**
     * Add a member to this thread, throws if user can not add member, throw is not member thread
     *
     * @param     {String}    id                      Member Id
     */

  }, {
    key: "addMember",
    value: function () {
      var _addMember = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(id) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._requireLoad();

                this._throwIfNotMembers();

                if (!id.startsWith('0x')) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return API.getSpaceDID(id, this._spaceName);

              case 5:
                id = _context5.sent;

              case 6:
                if (isValid3ID(id)) {
                  _context5.next = 8;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 8:
                this._throwIfNotMembers();

                return _context5.abrupt("return", this._db.access.grant(MEMBER, id));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addMember(_x3) {
        return _addMember.apply(this, arguments);
      }

      return addMember;
    }()
    /**
     * List members, throws if not member thread
     *
     * @return    {Array<String>}      Array of member DIDs
     */

  }, {
    key: "listMembers",
    value: function () {
      var _listMembers = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._throwIfNotMembers();

                this._requireLoad();

                return _context6.abrupt("return", this._db.access.capabilities['members']);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function listMembers() {
        return _listMembers.apply(this, arguments);
      }

      return listMembers;
    }()
  }, {
    key: "_throwIfNotMembers",
    value: function _throwIfNotMembers() {
      if (!this._members) throw new Error('Thread: Not a members only thread, function not available');
    }
    /**
     * Delete post
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "deletePost",
    value: function () {
      var _deletePost = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(hash) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.remove(hash));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function deletePost(_x4) {
        return _deletePost.apply(this, arguments);
      }

      return deletePost;
    }()
    /**
     * Returns an array of posts, based on the options.
     * If hash not found when passing gt, gte, lt, or lte,
     * the iterator will return all items (respecting limit and reverse).
     *
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.gt                 Greater than, takes an postId
     * @param     {String}    opts.gte                Greater than or equal to, takes an postId
     * @param     {String}    opts.lt                 Less than, takes an postId
     * @param     {String}    opts.lte                Less than or equal to, takes an postId
     * @param     {Integer}   opts.limit              Limiting the number of entries in result, defaults to -1 (no limit)
     * @param     {Boolean}   opts.reverse            If set to true will result in reversing the result
     *
     * @return    {Array<Object>}                           true if successful
     */

  }, {
    key: "getPosts",
    value: function () {
      var _getPosts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                this._requireLoad();

                if (!opts.limit) opts.limit = -1;
                return _context8.abrupt("return", this._db.iterator(opts).collect().map(function (entry) {
                  var post = entry.payload.value;
                  var metaData = {
                    postId: entry.hash,
                    author: entry.identity.id
                  };
                  return Object.assign(metaData, post);
                }));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPosts() {
        return _getPosts.apply(this, arguments);
      }

      return getPosts;
    }()
    /**
     * Register a function to be called after new updates
     * have been received from the network or locally.
     *
     * @param     {Function}  updateFn               The function that will get called
     */

  }, {
    key: "onUpdate",
    value: function () {
      var _onUpdate = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(updateFn) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._requireLoad();

                this._db.events.on('replicated', function (address, hash, entry, prog, tot) {
                  updateFn();
                });

                this._db.events.on('write', function (dbname, entry) {
                  updateFn();
                });

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onUpdate(_x5) {
        return _onUpdate.apply(this, arguments);
      }

      return onUpdate;
    }()
    /**
     * Register a function to be called for every new
     * capability that is added to the thread access controller.
     * This inlcudes when a moderator or member is added.
     * The function takes one parameter, which is the capabilities obj, or
     * you can call listModerator / listMembers again instead.
     *
     * @param     {Function}  updateFn     The function that will get called
     */

  }, {
    key: "onNewCapabilities",
    value: function () {
      var _onNewCapabilities = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(updateFn) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._db.access.on('updated', function (event) {
                  updateFn(_this._db.access.capabilities);
                });

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function onNewCapabilities(_x6) {
        return _onNewCapabilities.apply(this, arguments);
      }

      return onNewCapabilities;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(odbAddress) {
        var identity;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._initConfigs();

              case 2:
                identity = this._identity;
                _context11.next = 5;
                return this._orbitdb.feed(odbAddress || this._name, _objectSpread({}, ORBITDB_OPTS, {
                  identity: identity,
                  accessController: this._accessController
                }));

              case 5:
                this._db = _context11.sent;
                _context11.next = 8;
                return this._db.load();

              case 8:
                this._address = this._db.address.toString();

                this._ensureConnected(this._address, true);

                return _context11.abrupt("return", this._address);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _load(_x7) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._requireLoad();

                _context12.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_initConfigs",
    value: function () {
      var _initConfigs2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!this._identity) {
                  _context13.next = 2;
                  break;
                }

                return _context13.abrupt("return");

              case 2:
                _context13.next = 4;
                return this._3id.getOdbId(this._spaceName);

              case 4:
                this._identity = _context13.sent;

                if (!this._firstModerator.startsWith('0x')) {
                  _context13.next = 9;
                  break;
                }

                _context13.next = 8;
                return API.getSpaceDID(this._firstModerator, this._spaceName);

              case 8:
                this._firstModerator = _context13.sent;

              case 9:
                this._accessController = {
                  type: 'thread-access',
                  threadName: this._name,
                  members: this._members,
                  firstModerator: this._firstModerator,
                  identity: this._identity
                };

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _initConfigs() {
        return _initConfigs2.apply(this, arguments);
      }

      return _initConfigs;
    }()
  }, {
    key: "address",
    get: function get() {
      return this._db ? this._address : null;
    }
  }]);
  return Thread;
}();

module.exports = Thread;
//# sourceMappingURL=node_modules/3box/lib/thread.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/thread.js",}],
[166, {"./index":165,"@babel/runtime/helpers/asyncToGenerator":176,"@babel/runtime/helpers/interopRequireDefault":186,"@babel/runtime/regenerator":206,"did-jwt":168,"ethers":170,"https-did-resolver":1926,"muport-did-resolver":2716}, function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('./index'),
    fetchText = _require.fetchText,
    getMessageConsent = _require.getMessageConsent;

var didJWT = require('did-jwt');

var ethers = require('ethers');

require('https-did-resolver')["default"]();

require('muport-did-resolver')();

module.exports = {
  /**
   * Verifies that the gist contains the given muportDID and returns the users github username.
   * Throws an error otherwise.
   *
   * @param     {String}            did                     The muport DID of the user
   * @param     {Object}            gistUrl                 URL of the proof
   * @return    {Object}                                    Object containing username, and proof
   */
  verifyGithub: function () {
    var _verifyGithub = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, gistUrl) {
      var gistFileContent, username;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!gistUrl || gistUrl.trim() === '')) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", null);

            case 2:
              _context.next = 4;
              return fetchText(gistUrl);

            case 4:
              gistFileContent = _context.sent;

              if (!(gistFileContent.indexOf(did) === -1)) {
                _context.next = 7;
                break;
              }

              throw new Error('Gist File provided does not contain the correct DID of the user');

            case 7:
              username = gistUrl.split('/')[3];
              return _context.abrupt("return", {
                username: username,
                proof: gistUrl
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function verifyGithub(_x, _x2) {
      return _verifyGithub.apply(this, arguments);
    }

    return verifyGithub;
  }(),

  /**
   * Verifies that the tweet contains the given muportDID and returns the users twitter username.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyTwitter: function () {
    var _verifyTwitter = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (claim) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", null);

            case 2:
              _context2.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context2.sent;

              if (!(verified.payload.sub !== did)) {
                _context2.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (!(!claimData.twitter_handle || !claimData.twitter_proof)) {
                _context2.next = 10;
                break;
              }

              throw new Error('The claim for your twitter is not correct');

            case 10:
              return _context2.abrupt("return", {
                username: claimData.twitter_handle,
                proof: claimData.twitter_proof,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function verifyTwitter(_x3, _x4) {
      return _verifyTwitter.apply(this, arguments);
    }

    return verifyTwitter;
  }(),

  /**
   * Verifies that the code entered by the user is the same one that was sent via email.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyEmail: function () {
    var _verifyEmail = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (claim) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", null);

            case 2:
              _context3.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context3.sent;

              if (!(verified.payload.sub !== did)) {
                _context3.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (claimData.email_address) {
                _context3.next = 10;
                break;
              }

              throw new Error('The claim for your email address is not correct');

            case 10:
              return _context3.abrupt("return", {
                email_address: claimData.email_address,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function verifyEmail(_x5, _x6) {
      return _verifyEmail.apply(this, arguments);
    }

    return verifyEmail;
  }(),

  /**
   * Verifies that the proof for a did is correct
   *
   * @param     {String}            claim           A did-JWT with claim
   * @return    {String}                            The DID of the user
   */
  verifyDID: function () {
    var _verifyDID = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(claim) {
      var verified;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return didJWT.verifyJWT(claim);

            case 2:
              verified = _context4.sent;
              return _context4.abrupt("return", verified.payload.iss);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function verifyDID(_x7) {
      return _verifyDID.apply(this, arguments);
    }

    return verifyDID;
  }(),

  /**
   * Verifies that the proof for an ethereum address is correct
   *
   * @param     {Object}    ethProof                      The claim generated by getLinkConsent
   * @param     {string}    ethProof.consent_msg
   * @param     {string}    ethProof.consent_signature
   * @param     {string}    ethProof.linked_did
   * @param     {String}    did                           The box' did
   * @return    {String}                                  The ethereum address used to sign the message
   */
  verifyEthereum: function () {
    var _verifyEthereum = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee5(ethProof, did) {
      var consentMsg, consentSig, expected;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              consentMsg = ethProof.version ? ethProof.message : ethProof['consent_msg'];
              consentSig = ethProof.version ? ethProof.signature : ethProof['consent_signature']; // Make sure the message matches our expectation

              expected = getMessageConsent(did);

              if (!(consentMsg !== expected)) {
                _context5.next = 5;
                break;
              }

              throw new Error("Invalid consent message, got: \"".concat(consentMsg, "\", expected: \"").concat(expected, "\""));

            case 5:
              return _context5.abrupt("return", ethers.utils.verifyMessage(consentMsg, consentSig));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function verifyEthereum(_x8, _x9) {
      return _verifyEthereum.apply(this, arguments);
    }

    return verifyEthereum;
  }()
};
//# sourceMappingURL=node_modules/3box/lib/utils/verifier.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/3box/lib/utils/verifier.js",}],
[1892, {"./types":1893,"cross-fetch/polyfill":1894}, function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("./types");
var types_2 = require("./types");
exports.ClientError = types_2.ClientError;
require("cross-fetch/polyfill");
var GraphQLClient = /** @class */ (function () {
    function GraphQLClient(url, options) {
        this.url = url;
        this.options = options || {};
    }
    GraphQLClient.prototype.rawRequest = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, headers_1, status_1, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            headers_1 = response.headers, status_1 = response.status;
                            return [2 /*return*/, __assign({}, result, { headers: headers_1, status: status_1 })];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status, headers: response.headers }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.request = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            return [2 /*return*/, result.data];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.setHeaders = function (headers) {
        this.options.headers = headers;
        return this;
    };
    GraphQLClient.prototype.setHeader = function (key, value) {
        var headers = this.options.headers;
        if (headers) {
            headers[key] = value;
        }
        else {
            this.options.headers = (_a = {}, _a[key] = value, _a);
        }
        return this;
        var _a;
    };
    return GraphQLClient;
}());
exports.GraphQLClient = GraphQLClient;
function rawRequest(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.rawRequest(query, variables)];
        });
    });
}
exports.rawRequest = rawRequest;
function request(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.request(query, variables)];
        });
    });
}
exports.request = request;
exports.default = request;
function getResult(response) {
    return __awaiter(this, void 0, void 0, function () {
        var contentType;
        return __generator(this, function (_a) {
            contentType = response.headers.get('Content-Type');
            if (contentType && contentType.startsWith('application/json')) {
                return [2 /*return*/, response.json()];
            }
            else {
                return [2 /*return*/, response.text()];
            }
            return [2 /*return*/];
        });
    });
}
//# sourceMappingURL=index.js.map
//# sourceMappingURL=node_modules/graphql-request/dist/src/index.js
}, {file:"/Users/jack/projects/monsta-wallet/node_modules/graphql-request/dist/src/index.js",}]],[],{})

